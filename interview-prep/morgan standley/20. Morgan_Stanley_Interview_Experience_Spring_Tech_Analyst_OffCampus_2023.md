# Morgan Stanley Interview Experience | Spring Technology Analyst (Off-Campus) 2023

This document details the **Morgan Stanley Interview Experience for Spring Technology Analyst (Off-Campus)**, conducted from July 2022 to January 2023 for a 6-month internship (January–July 2023). The candidate applied off-campus via the Morgan Stanley career portal without a referral, was shortlisted after an online test, cleared two interview rounds, and was selected. The process included an Online Test (Debugging, Aptitude, Programming), Round 1 (Technical: Binary Tree, Longest Substring), and Round 2 (HR + Technical: Java vs. C++, Palindromic Substrings). All coding questions are implemented in **C++**, OOPS-related in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers.

Yo, bruh—this is your ultimate playbook to crush Morgan Stanley’s Spring Tech Analyst gig! Let’s dive in and bag that offer!

## Application Process

- **How to Apply**:  
  - Applied in July 2022 via Morgan Stanley’s career portal ([careers.morganstanley.com](https://www.morganstanley.com/people/students-and-graduates)).  
  - Created account, uploaded resume with key achievements.  
  - No referral used, purely merit-based.  
- **Tip**:  
  - Craft a strong resume: highlight projects, DSA skills, and internships.  
  - Use GFG’s Ultimate Resume Building Guide.  
- **Outcome**: Shortlisted for Online Test in late September 2022 after resume screening.

## Round 1: Online Test

**Platform**: SHL Aspiring Minds (AMCAT), 80 minutes, 2-hour window.  
**Details**: 3 sections, individually timed.  
- **Debugging**: 7 questions, 10 minutes, all solved.  
- **Aptitude**: 10 MCQs, 10 minutes, Logical Reasoning/Data Interpretation/Numerical Ability.  
- **Programming**: 3 medium-level questions, 60 minutes, brute force acceptable for partial points.  
- **Outcome**: Shortlisted for Round 1 interview within a week.

### Section 1: Debugging

**Problem Statement**:  
- Fix 7 code snippets by identifying syntax/logic errors.  
- Language: C++ chosen.  
- Time: 10 minutes.

**Approach**:  
- **Strategy**:  
  1. Check syntax (e.g., missing semicolons, incorrect operators).  
  2. Fix logical errors (e.g., wrong conditions, off-by-one).  
  3. Validate with edge cases mentally.  
- **Edge Cases**: Null inputs, uninitialized variables, boundary conditions.

**Notes**:  
- Solved all questions, time management key.  
- Resources: GFG Debugging, HackerRank practice.  
- Tip: Practice 5-minute debug sprints, aim for 100% accuracy.

### Section 2: Aptitude

**Problem Statement**:  
- 10 MCQs on Logical Reasoning, Data Interpretation, Numerical Ability.  
- Time: 10 minutes, no negative marking, no skipping/backtracking.

**Approach**:  
- **Strategy**:  
  1. Prioritize easy questions (e.g., basic math, patterns).  
  2. Use elimination for tricky ones.  
  3. Manage time strictly (1 minute/question).  
- **Edge Cases**: Tricky wording, time traps.

**Notes**:  
- Solved most questions, partial solves sufficient.  
- Resources: RS Aggarwal, GFG Aptitude.  
- Tip: Practice 10 questions in 8 minutes, aim for 8–10 correct.

### Section 3: Programming

**Problem Statement**:  
- 3 medium-level questions, 60 minutes, C++ chosen.  
- Specific problems not disclosed; assumed typical DSA (e.g., arrays, trees, strings).  
- Brute force acceptable for partial points.

**Approach (General)**:  
- **Strategy**:  
  1. Read constraints to choose approach (e.g., O(n) for N=10^4).  
  2. Write clean code, handle edge cases.  
  3. Test manually with sample inputs.  
- **Edge Cases**: Empty inputs, max constraints, single element.

**Notes**:  
- Solved all questions (brute or optimal).  
- Practice LeetCode medium (e.g., #3, #236).  
- Tip: Time-box each problem (~20 minutes), prioritize solving all.

## Round 2: Technical Interview

**Duration**: ~50 minutes, Zoom.  
**Details**: Introduction, project discussion, CS course rating, 2 DSA questions (Delete k Nodes of Minimum Depth, Longest Substring Without Repeating Characters).  
**Outcome**: Advanced to Round 2 despite doubts, called within a week.

### Question 1: Delete k Nodes of Minimum Depth in a Binary Tree

**Problem Statement**:  
- Given a binary tree and integer k, delete k nodes with minimum depth (closest to root).  
- **Example**: Input: [1,2,3,4,5], k=2 → Output: Tree after deleting nodes at depth 1 (e.g., 2,3).  
- **Link**: [GFG Binary Tree](https://www.geeksforgeeks.org/problems/delete-nodes-greater-than-k/1).

**Approach**:  
- **Brute Force**: Find all nodes’ depths, sort, delete k smallest (O(n log n)).  
- **Optimal Approach**: Level-order traversal, delete first k nodes (O(n)).  
  - Pointwise:  
    1. Use BFS to process nodes level by level.  
    2. Delete first k nodes encountered.  
    3. Reconstruct tree if needed.  
  - Edge cases: k > nodes, empty tree, k=0.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node *left, *right;
    Node(int x) : data(x), left(NULL), right(NULL) {}
};

Node* deleteKMinDepth(Node* root, int k) {
    if (!root || k <= 0) return root;
    queue<Node*> q;
    q.push(root);
    vector<Node*> toDelete;
    while (!q.empty() && k > 0) {
        int size = q.size();
        for (int i = 0; i < size && k > 0; i++) {
            Node* node = q.front();
            q.pop();
            toDelete.push_back(node);
            k--;
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
    // Simulate deletion by setting pointers to NULL
    for (Node* node : toDelete) {
        if (node == root) root = NULL;
        // Parent pointer logic omitted for simplicity
    }
    return root;
}

void printInorder(Node* root) {
    if (!root) return;
    printInorder(root->left);
    cout << root->data << " ";
    printInorder(root->right);
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(w) (queue, w = max width).  
**Notes**:  
- Solved in ~15 minutes, explained approach.  
- Test k=0, single node.  
- Tip: Practice GFG tree problems, clarify deletion process.

### Question 2: Longest Substring Without Repeating Characters

**Problem Statement**:  
- Given a string, find the longest substring without repeating characters.  
- **Example**: Input: "abcabcbb" → Output: "abc" (length 3).  
- **Link**: [LeetCode #3](https://leetcode.com/problems/longest-substring-without-repeating-characters/).

**Approach**:  
- **Brute Force**: Check all substrings (O(n^3)).  
- **Optimal Approach**: Sliding window with hash map.  
  - Pointwise:  
    1. Use hash map to store char-to-index.  
    2. Maintain window [start, i], update start on repeat.  
    3. Track max length.  
  - Edge cases: Empty string, single char, all same chars.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int lengthOfLongestSubstring(string s) {
    unordered_map<char, int> mp;
    int maxLen = 0, start = 0;
    for (int i = 0; i < s.size(); i++) {
        if (mp.find(s[i]) != mp.end() && mp[s[i]] >= start) {
            start = mp[s[i]] + 1;
        }
        mp[s[i]] = i;
        maxLen = max(maxLen, i - start + 1);
    }
    return maxLen;
}

void solve() {
    string s;
    cin >> s;
    cout << lengthOfLongestSubstring(s) << endl;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(min(m,n)) (m = charset size).  
**Notes**:  
- Explained solution, dry-ran test case per interviewer’s request.  
- Test "aaaa", "".  
- Tip: Practice LeetCode #3, be ready for dry runs.

## Round 3: HR + Technical Interview

**Duration**: ~45–50 minutes, Zoom.  
**Details**: HR (Why Morgan Stanley, company knowledge, leaders), Technical (Java vs. C++, Java garbage collection, palindromic substrings with modification).  
**Outcome**: Selected after 5 weeks.

### Question 3: HR Questions

**Problem Statement**:  
- Answer: Why Morgan Stanley? What do you know about Morgan Stanley’s business? Name industry leaders.

**Sample Answer (STAR)**:  
- **Why Morgan Stanley?**  
  - **Situation**: Seeking a tech-finance role.  
  - **Task**: Align with a prestigious firm.  
  - **Action**: Researched Morgan Stanley’s tech division, innovation in financial services.  
  - **Result**: Chose Morgan Stanley for its global impact, tech-driven culture.  
- **Business Knowledge**:  
  - Morgan Stanley: Global leader in investment banking, wealth management, institutional securities.  
  - Tech focus: Trading platforms, risk management systems.  
- **Leaders**:  
  - James Gorman (Chairman, ex-CEO), Ted Pick (CEO).  

**Notes**:  
- Brief school discussion, showed company research.  
- Tip: Research Morgan Stanley’s tech stack, leadership (careers.morganstanley.com).

### Question 4: Java vs. C++

**Problem Statement**:  
- Explain differences between Java and C++.

**Approach**:  
- **Answer**:  
  - **Memory Management**: Java uses garbage collection, C++ manual (new/delete).  
  - **Platform**: Java platform-independent (JVM), C++ compiled to native code.  
  - **OOPS**: Java enforces OOPS, C++ supports procedural + OOPS.  
  - **Performance**: C++ faster, Java safer.  
  - **Example (Java)**:  
```java
class Example {
    public static void main(String[] args) {
        String s = new String("Java"); // Managed by JVM
    }
}
```
  - **Example (C++)**:  
```cpp
#include <string>
int main() {
    string* s = new string("C++"); // Manual delete
    delete s;
    return 0;
}
```

**Notes**:  
- Explained clearly, tied to practical use.  
- Tip: Study GFG Java vs. C++, know memory models.

### Question 5: Java Garbage Collection

**Problem Statement**:  
- Explain Java’s garbage collection process.

**Approach**:  
- **Answer**:  
  - **Process**: JVM automatically reclaims memory from unreachable objects.  
  - **Mechanism**: Mark-and-sweep algorithm.  
    1. Mark: Identify reachable objects.  
    2. Sweep: Free unmarked objects.  
  - **Types**: Young (Eden, Survivor), Old Generation.  
  - **Example**:  
```java
class GCExample {
    public static void main(String[] args) {
        Object obj = new Object();
        obj = null; // Eligible for GC
    }
}
```

**Notes**:  
- Brief discussion, showed understanding.  
- Tip: Study GFG Java GC, focus on heap structure.

### Question 6: Palindromic Substrings (No Single Characters)

**Problem Statement**:  
- Given a string, return all palindromic substrings (exclude length=1).  
- **Example**: Input: "aaa" → Output: ["aa","aaa"] (exclude "a").  
- **Link**: [LeetCode #647](https://leetcode.com/problems/palindromic-substrings/).

**Approach**:  
- **Brute Force**: Check all substrings (O(n^3)).  
- **Optimal Approach**: Expand around center.  
  - Pointwise:  
    1. For each index, expand around center (odd/even length).  
    2. Collect palindromes with length > 1.  
    3. Return as vector.  
  - Edge cases: Empty string, no palindromes.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

void expand(string s, int left, int right, vector<string>& result) {
    while (left >= 0 && right < s.size() && s[left] == s[right]) {
        if (right - left + 1 > 1) {
            result.push_back(s.substr(left, right - left + 1));
        }
        left--;
        right++;
    }
}

vector<string> findPalindromes(string s) {
    vector<string> result;
    for (int i = 0; i < s.size(); i++) {
        expand(s, i, i, result);     // Odd length
        expand(s, i, i + 1, result); // Even length
    }
    return result;
}

void solve() {
    string s;
    cin >> s;
    vector<string> result = findPalindromes(s);
    for (string pal : result) cout << pal << " ";
    cout << endl;
}
```

**Time Complexity**: O(n^2).  
**Space Complexity**: O(n) (output space).  
**Notes**:  
- Modified to exclude length=1, solved in ~15 minutes.  
- Test "aaa", "".  
- Tip: Practice LeetCode #647, be ready for modifications.

## Key Takeaways and Preparation Tips

- **Application**:  
  - Strong resume critical, use GFG Resume Guide.  
  - Apply early via career portal, no referral needed.  
- **Online Test**:  
  - **Debugging**: Solve all, practice quick fixes (GFG Debugging).  
  - **Aptitude**: Speed over perfection (RS Aggarwal).  
  - **Programming**: Brute force OK, aim for all solves (LeetCode #3, #236).  
- **Technical Rounds**:  
  - Master OOPS (GFG Java), DSA (LeetCode #3, GFG Trees).  
  - Know CS fundamentals (Java GC, OS).  
  - Dry-run solutions if asked, stay confident.  
- **HR Round**:  
  - Use STAR for HR questions, research Morgan Stanley (careers.morganstanley.com).  
  - Align answers with tech-finance innovation.  
- **Resources**:  
  - **Coding**: LeetCode, GFG, Striver’s SDE Sheet.  
  - **OOPS/OS**: GFG Java, GFG OS, StudyTonight.  
  - **Resume**: GFG Resume Guide.  
  - **Interview Prep**: Glassdoor, GFG experiences.  
- **Interview Day**: Explain thought process, handle doubts calmly, ask about tech stack.  
- **General**: Morgan Stanley values technical depth, time management, and communication. Be honest, show resilience.

**Final Note**: Code like a pro, vibe like a champ, and own that Spring Tech Analyst role, bruh—Morgan Stanley’s ready for your shine!