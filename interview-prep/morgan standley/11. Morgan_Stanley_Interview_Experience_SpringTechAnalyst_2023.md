# Morgan Stanley Interview Experience for Spring Technology Analyst 2023 (Off-Campus)

This document details the **Morgan Stanley Interview Experience for Spring Technology Analyst (Off-Campus)**, shared on July 23, 2025, for the 2023 internship (January–July). The candidate applied through the Morgan Stanley career portal in July 2022, was shortlisted after resume screening, and completed the hiring process, including an Online Test (OT) on the SHL Aspiring Minds platform and two interview rounds. The candidate excelled in the OT, faced challenges in the first technical interview but performed well in the second, and was selected for the 6-month internship after a 5-week wait. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers for behavioral questions.

Let’s get into it, bruh—this is your guide to nailing Morgan Stanley’s off-campus internship hustle!

## Application Process

**Process**:  
- Applied directly via Morgan Stanley’s career portal for students and graduates in July 2022.  
- Created an account, uploaded resume highlighting key achievements (e.g., projects, hackathons).  
- No referral used.  
- Shortlisted after resume screening, invited for pre-placement talk and Online Test in late September.

**Notes**:  
- Pre-placement talk (50–60 minutes) covered compensation, job description, hiring process, and Q&A.  
- Tip: Craft a resume with strong projects and DSA skills (use GFG resume tips).

## Online Test

The OT was conducted on the SHL Aspiring Minds platform, with a 2-hour window and 80-minute duration, comprising three timed sections: Debugging, Aptitude, and Programming.

### Section 1: Debugging

**Problem Statement**:  
- 7 questions, 10 minutes, language choice (C++ chosen).  
- Task: Identify and fix bugs (syntax/logic) in code snippets to pass all test cases.  
- Topics: Loops, conditionals, pointers, basic algorithms.

**Approach**:  
- **Strategy**:  
  1. Scan for syntax errors (e.g., missing semicolons, incorrect operators).  
  2. Correct logical errors (e.g., wrong loop conditions, off-by-one errors).  
  3. Validate with mental dry-run for edge cases.  
- **Edge Cases**: Null inputs, uninitialized variables, incorrect outputs.

**Notes**:  
- Solved all 7 questions.  
- Resources: GFG Debugging Practice, HackerRank.  
- Tip: Practice quick fixes in 1–2 minutes per question, aim for 7/7.

### Section 2: Aptitude

**Problem Statement**:  
- 10 multiple-choice questions, 10 minutes, no negative marking, no skipping or changing answers.  
- Topics: Logical Reasoning (e.g., puzzles), Data Interpretation (e.g., charts), Numerical Ability (e.g., percentages).  
- Simple to medium difficulty.

**Approach**:  
- **Strategy**:  
  1. Prioritize numerical questions (e.g., ratios, profit-loss).  
  2. Solve logical puzzles using elimination.  
  3. Double-check calculations for accuracy.  
- **Edge Cases**: Tricky wording, decimal precision.

**Notes**:  
- Solved most questions.  
- Resources: RS Aggarwal, GFG Aptitude.  
- Tip: Practice 10-minute aptitude sets, aim for 8/10 under time pressure.

### Section 3: Programming

**Problem Statement**:  
- 3 medium-level questions, 60 minutes, C++ chosen.  
- Partial points for brute-force solutions, but aim for optimal.  
- Questions unspecified; assumed to be standard DSA (e.g., arrays, strings, trees).

**Approach (Assumed Questions)**:  
- **Question 1**: Array manipulation (e.g., find max subarray sum).  
- **Question 2**: String processing (e.g., reverse words in a string).  
- **Question 3**: Tree/Graph (e.g., level-order traversal).  
- **Strategy**:  
  1. Write brute-force solution to secure partial points.  
  2. Optimize using DSA (e.g., Kadane’s, two-pointer, BFS).  
  3. Test edge cases manually.  
- **Edge Cases**: Empty inputs, single element, large datasets.

**Sample Code (C++ - Max Subarray Sum)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int maxSubArray(vector<int>& nums) {
    int maxSum = nums[0], currSum = nums[0];
    for (int i = 1; i < nums.size(); i++) {
        currSum = max(nums[i], currSum + nums[i]);
        maxSum = max(maxSum, currSum);
    }
    return maxSum;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved all 3 questions, likely passed all test cases.  
- Resources: LeetCode #53 (Kadane’s), GFG DSA.  
- Tip: Practice medium-level DSA, ensure all test cases pass.

**OT Performance**:  
- Strong performance across all sections.  
- Shortlisted for interviews within a week.

## Technical Interview (Round 1)

**Duration**: ~50 minutes, via virtual platform.  
**Interviewer**: Focused on introduction, projects, CS knowledge, and coding.

### Question 1: Introduction and Projects

**Problem Statement**:  
- Introduce yourself, briefly discuss projects.

**Sample Answer**:  
- **Introduction**: “I’m a final-year CSE student, passionate about DSA and system design. I’ve worked on projects like a real-time chat app using React and NodeJS.”  
- **Projects**: “Developed a booking system with Java backend, optimized DB queries, reducing latency by 25%.”

**Notes**:  
- Kept concise, highlighted technical impact.  
- Tip: Prepare a 1-minute intro, focus on 1–2 key projects (GFG resume tips).

### Question 2: Rate CS Courses

**Problem Statement**:  
- Rate your knowledge (1–10) in CS courses (e.g., DSA, OS, DBMS, Networks).

**Sample Answer**:  
- DSA: 8/10 (solved 200+ LeetCode problems).  
- OS: 7/10 (strong in scheduling, memory management).  
- DBMS: 6/10 (proficient in SQL, normalization).  
- Networks: 6/10 (familiar with TCP/IP, OSI model).  

**Notes**:  
- Be honest, justify ratings with examples.  
- Tip: Review core CS subjects (GFG Last Minute Notes).

### Question 3: Delete K Nodes of Minimum Depth in Binary Tree

**Problem Statement**:  
- Delete k nodes with minimum depth in a binary tree.  
- **Example**: Input: root=[1,2,3,4,5], k=2 → Output: Tree after deleting 2 nodes at depth 1 (e.g., nodes 2,3).

**Approach**:  
- **Brute Force**: Find all nodes’ depths, sort, delete k lowest (O(n log n)).  
- **Optimal Approach**: Level-order traversal (BFS).  
  - Pointwise:  
    1. Use queue to process nodes level by level.  
    2. Track depth, collect k nodes at minimum depth.  
    3. Delete collected nodes by updating parent pointers.  
    - Edge cases: k > nodes, k=0, single node.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

void deleteKMinDepth(TreeNode* root, int k) {
    if (!root || k <= 0) return;
    queue<pair<TreeNode*, TreeNode*>> q; // node, parent
    q.push({root, nullptr});
    vector<pair<TreeNode*, TreeNode*>> toDelete;
    int currDepth = 0, nodesAtDepth = 0;
    while (!q.empty() && k > 0) {
        int size = q.size();
        nodesAtDepth = 0;
        for (int i = 0; i < size && k > 0; i++) {
            auto [node, parent] = q.front(); q.pop();
            nodesAtDepth++;
            if (k > 0) toDelete.push_back({node, parent});
            if (node->left) q.push({node->left, node});
            if (node->right) q.push({node->right, node});
        }
        currDepth++;
        k -= nodesAtDepth;
    }
    for (auto [node, parent] : toDelete) {
        if (parent) {
            if (parent->left == node) parent->left = nullptr;
            else parent->right = nullptr;
        }
        delete node;
    }
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(w) for queue (w = max width).  
**Notes**:  
- Solved in ~15 minutes.  
- GFG “Binary Tree Deletion.” Test k=0, unbalanced tree.

### Question 4: Longest Substring Without Repeating Characters

**Problem Statement**:  
- Given a string, find the longest substring without repeating characters.  
- **Example**: Input: "abcabcbb" → Output: 3 ("abc").  
- **Link**: [LeetCode #3](https://leetcode.com/problems/longest-substring-without-repeating-characters/).

**Approach**:  
- **Brute Force**: Check all substrings (O(n³)).  
- **Optimal Approach**: Sliding window with HashMap.  
  - Pointwise:  
    1. Use HashMap to store char-to-index mapping.  
    2. Maintain window [start, i], update start on repeat.  
    3. Track max length.  
    - Edge cases: Empty string, single char, all repeats.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int lengthOfLongestSubstring(string s) {
    unordered_map<char, int> seen;
    int maxLen = 0, start = 0;
    for (int i = 0; i < s.size(); i++) {
        if (seen.find(s[i]) != seen.end() && seen[s[i]] >= start) {
            start = seen[s[i]] + 1;
        }
        seen[s[i]] = i;
        maxLen = max(maxLen, i - start + 1);
    }
    return maxLen;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(min(m, n)), m=charset size.  
**Notes**:  
- Explained solution, struggled with dry run but clarified.  
- LeetCode #3. Test "aaaa", empty string.

**Technical Interview 1 Performance**:  
- Handled projects, CS ratings, coding; less confident in substring dry run.  
- Advanced to Round 2 within the same week.

## HR + Technical Interview (Round 2)

**Duration**: ~45–50 minutes, via virtual platform.  
**Interviewer**: Combined HR and technical focus.

### Question 5: Introduction

**Problem Statement**:  
- Introduce yourself.

**Sample Answer**:  
- **Situation**: “I’m a final-year CSE student with a passion for coding.”  
- **Task**: “I aim to build scalable systems.”  
- **Action**: “Developed projects like a booking app, solved 200+ DSA problems.”  
- **Result**: “Gained expertise in Java, C++, and system design.”

**Notes**:  
- Kept engaging, relevant.  
- Tip: Tailor intro to Morgan Stanley’s tech focus.

### Question 6: Why Morgan Stanley?

**Problem Statement**:  
- Why do you want to join Morgan Stanley?

**Sample Answer**:  
- **Situation**: “I’m drawn to financial tech innovation.”  
- **Task**: “Contribute to Morgan Stanley’s cutting-edge platforms.”  
- **Action**: “My skills in Java and DSA align with your trading systems.”  
- **Result**: “Excited to impact global finance tech.”

**Notes**:  
- Tied skills to company goals.  
- Tip: Research Morgan Stanley’s tech stack (e.g., Java, cloud).

### Question 7: About Morgan Stanley and Industry Leaders

**Problem Statement**:  
- What do you know about Morgan Stanley and its business? Name industry leaders.

**Sample Answer**:  
- **Morgan Stanley**: Global leader in investment banking, wealth management, and tech-driven trading systems.  
- **Business**: Leverages Java, Python for scalable platforms; focuses on data analytics, AI.  
- **Leaders**: James Gorman (CEO), known for digital transformation; peers like Jamie Dimon (JPMorgan).  

**Notes**:  
- Brief discussion, showed awareness.  
- Tip: Read Morgan Stanley’s annual reports, tech blogs.

### Question 8: School Discussion

**Problem Statement**:  
- Briefly discuss your school.

**Sample Answer**:  
- **Situation**: “Studied at [Your College], known for strong CSE programs.”  
- **Task**: “Highlight academic experience.”  
- **Action**: “Participated in hackathons, led coding clubs.”  
- **Result**: “Built a foundation in DSA and teamwork.”

**Notes**:  
- Kept short, relevant.  
- Tip: Connect school experience to skills.

### Question 9: Java vs. C++

**Problem Statement**:  
- Explain the difference between Java and C++.

**Approach**:  
- **Java**:  
  - Platform-independent (JVM), garbage-collected, no pointers.  
  - Used for enterprise apps, safer memory management.  
- **C++**:  
  - Platform-dependent, manual memory management, supports pointers.  
  - Used for system programming, high performance.  
- **Key Differences**:  
  - Java: Automatic memory (GC), no multiple inheritance.  
  - C++: Operator overloading, templates, faster execution.

**Notes**:  
- Explained clearly, discussed garbage collection.  
- Tip: Study language comparisons (GFG Java, C++).

### Question 10: Java Garbage Collection

**Problem Statement**:  
- Explain Java’s garbage collection.

**Approach**:  
- **Explanation**:  
  - Automatically reclaims memory of unused objects.  
  - Uses mark-and-sweep algorithm in JVM.  
  - Heap divided into Young (Eden, Survivor) and Old generations.  
  - Minor GC (Young), Major GC (Old).  
- **Edge Cases**: Memory leaks, finalize() misuse.

**Notes**:  
- Brief discussion, showed understanding.  
- Tip: Study JVM internals (GFG Java).

### Question 11: Palindromic Substrings

**Problem Statement**:  
- Write a function to find all palindromic substrings in a string, excluding single-character substrings.  
- **Example**: Input: "aaa" → Output: ["aa", "aaa"] (exclude "a").

**Approach**:  
- **Brute Force**: Check all substrings for palindrome (O(n³)).  
- **Optimal Approach**: Expand around center.  
  - Pointwise:  
    1. For each index i, expand around i (odd length) and i,i+1 (even length).  
    2. Check palindrome by comparing chars, exclude length=1.  
    3. Collect valid substrings.  
    - Edge cases: Empty string, no palindromes, all same chars.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<string> findPalindromicSubstrings(string s) {
    vector<string> result;
    int n = s.size();
    // Expand around center
    for (int i = 0; i < n; i++) {
        // Odd length palindromes
        for (int len = 0; i - len >= 0 && i + len < n; len++) {
            if (s[i - len] != s[i + len]) break;
            if (2 * len + 1 > 1) result.push_back(s.substr(i - len, 2 * len + 1));
        }
        // Even length palindromes
        for (int len = 0; i - len >= 0 && i + 1 + len < n; len++) {
            if (s[i - len] != s[i + 1 + len]) break;
            if (2 * len + 2 > 1) result.push_back(s.substr(i - len, 2 * len + 2));
        }
    }
    return result;
}
```

**Time Complexity**: O(n²).  
**Space Complexity**: O(n) for output.  
**Notes**:  
- Solved, modified to exclude single chars.  
- LeetCode #647 variant. Test "aaa", empty string.

**Round 2 Performance**:  
- Handled HR and technical questions well.  
- Selected after 5 weeks.

## Key Takeaways and Preparation Tips

- **Application**: Apply early via career portal, craft a strong resume (projects, hackathons).  
- **Online Test**:  
  - Debugging: Practice quick fixes (HackerRank).  
  - Aptitude: Solve under time pressure (RS Aggarwal).  
  - Coding: Secure partial points with brute force, optimize later (LeetCode, GFG).  
- **Interviews**:  
  - Technical: Master DSA (trees, strings), OOPS (Java, C++), be ready for dry runs.  
  - HR: Use STAR method, research Morgan Stanley’s business.  
- **Resources**:  
  - **Coding**: LeetCode, GFG, HackerRank.  
  - **OOPS**: GFG Java, JavaTpoint.  
  - **Aptitude**: RS Aggarwal.  
  - **System Design**: GFG System Design (for context).  
- **Interview Day**: Stay calm during dry runs, clarify doubts, manage time.  
- **General**: Time management is critical in timed sections; practice stress handling.

**Final Note**: Nail all test cases and dry runs, bruh—Morgan Stanley loves precision and confidence!