# Morgan Stanley Interview Experience | Technology Analyst Intern (Off-Campus) 2024

This document details the **Morgan Stanley Interview Experience for Technology Analyst Intern (6-Month, Off-Campus)**, conducted in 2024 for a role with a CTC of 26 LPA + 87k stipend. The candidate, with no prior experience, applied off-campus and was selected after four rounds: Online Coding Test (3 problems), two Technical Rounds (OOPS, DSA, System Design, OS, Projects, Behavioral), and an HR/Managerial Round. The candidate solved all coding problems, excelled in technical discussions, and was selected. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR/Behavioral Questions**: STAR-method sample answers.

Yo, bruh—this is your ultimate roadmap to nail Morgan Stanley’s Technology Analyst Intern role! Let’s dive in and make it happen!

## Preparation

- **Topics**: OS, DBMS, OOPS, DSA, System Design.
- **Duration**: 1 month + strong competitive coding background.
- **Resources**:
  - Striver’s SDE Sheet (DSA).
  - LeetCode (Blind 75, company-wise problems).
  - GeeksforGeeks (CS fundamentals, interview experiences).
  - YouTube (system design, OS tutorials).
  - Ultimate Resume Building Guide (GFG).
- **Tips**:
  - Solve company-wise LeetCode/GFG problems.
  - Master CS fundamentals (OS, DBMS, OOPS).
  - Practice system design for top companies.
  - Ensure resume is honest, know every detail.
  - Stay positive, read interview experiences.

## Round 1: Online Coding Test

**Platform**: Likely HackerRank or AMCAT, ~180 minutes.  
**Details**: 3 problems, medium difficulty.  
- **Problem 1**: Valid Parentheses.
- **Problem 2**: Minimum Cost to Reduce Array.
- **Problem 3**: Max Points on a Line.
- **Outcome**: Solved all problems, shortlisted for Round 2.

### Problem 1: Valid Parentheses

**Problem Statement**:  
- Given a string `s` containing ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘, ‘]’, determine if it’s valid (open brackets closed by same type in correct order).  
- **Example**: Input: s="()[]{}" → Output: true; s="([)]" → Output: false.  
- **Link**: [LeetCode #20](https://leetcode.com/problems/valid-parentheses/).

**Approach**:  
- **Brute Force**: Recursive matching (O(2^n)).  
- **Optimal Approach**: Stack-based.  
  - Pointwise:  
    1. Push opening brackets onto stack.  
    2. For closing bracket, check if stack top matches.  
    3. Pop if match, else invalid.  
    4. Check if stack empty at end.  
  - Edge cases: Empty string, unmatched brackets, odd length.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

bool isValid(string s) {
    stack<char> st;
    for (char c : s) {
        if (c == '(' || c == '{' || c == '[') {
            st.push(c);
        } else {
            if (st.empty()) return false;
            char top = st.top();
            if ((c == ')' && top != '(') || (c == '}' && top != '{') || (c == ']' && top != '[')) {
                return false;
            }
            st.pop();
        }
    }
    return st.empty();
}

void solve() {
    string s;
    cin >> s;
    cout << (isValid(s) ? "true" : "false") << endl;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(n).  
**Notes**:  
- Solved efficiently using stack.  
- Test "((()))", "([)]".  
- Tip: Practice LeetCode #20, focus on stack operations.

### Problem 2: Minimum Cost to Reduce Array to Size 1

**Problem Statement**:  
- Given an array, pick two numbers, sum them, add sum to array (cost = sum). Find minimum cost to reduce array to size 1.  
- **Example**: Input: [1,2,3] → Output: 9 (merge 1+2=3, cost=3; merge 3+3=6, cost=6).  
- **Link**: [LeetCode #1000](https://leetcode.com/problems/minimum-cost-to-merge-stones/).

**Approach**:  
- **Brute Force**: Try all merge orders (O(n!)).  
- **Optimal Approach**: Min-heap.  
  - Pointwise:  
    1. Push all elements to min-heap.  
    2. Repeatedly pop two smallest, add sum to heap, add sum to cost.  
    3. Continue until one element remains.  
  - Edge cases: N=1, negative numbers.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

long long minCost(vector<int>& arr) {
    priority_queue<long long, vector<long long>, greater<long long>> pq;
    for (int x : arr) pq.push(x);
    long long cost = 0;
    while (pq.size() > 1) {
        long long a = pq.top(); pq.pop();
        long long b = pq.top(); pq.pop();
        cost += a + b;
        pq.push(a + b);
    }
    return cost;
}

void solve() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];
    cout << minCost(arr) << endl;
}
```

**Time Complexity**: O(n log n).  
**Space Complexity**: O(n).  
**Notes**:  
- Solved using min-heap, efficient for constraints.  
- Test [1], [1,2,3,4].  
- Tip: Practice LeetCode #1000, understand heap operations.

### Problem 3: Max Points on a Line

**Problem Statement**:  
- Given N 2D points, find the maximum number of points that lie on a single line.  
- **Example**: Input: [[1,1],[2,2],[3,3]] → Output: 3.  
- **Link**: [LeetCode #149](https://leetcode.com/problems/max-points-on-a-line/).

**Approach**:  
- **Brute Force**: Check all pairs of points, count points on each line (O(n^3)).  
- **Optimal Approach**: Slope-based with hash map.  
  - Pointwise:  
    1. For each point, compute slopes to all other points.  
    2. Use hash map to count points with same slope.  
    3. Handle vertical lines and duplicates separately.  
    4. Track max points on any line.  
  - Edge cases: N=1, duplicate points, vertical lines.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int maxPoints(vector<vector<int>>& points) {
    int n = points.size();
    if (n <= 2) return n;
    int maxPoints = 0;
    for (int i = 0; i < n; i++) {
        unordered_map<double, int> slopeCount;
        int duplicates = 0, vertical = 0;
        for (int j = i + 1; j < n; j++) {
            if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {
                duplicates++;
            } else if (points[i][0] == points[j][0]) {
                vertical++;
            } else {
                double slope = (double)(points[j][1] - points[i][1]) / (points[j][0] - points[i][0]);
                slopeCount[slope]++;
            }
        }
        maxPoints = max(maxPoints, vertical + duplicates + 1);
        for (auto& p : slopeCount) {
            maxPoints = max(maxPoints, p.second + duplicates + 1);
        }
    }
    return maxPoints;
}

void solve() {
    int n;
    cin >> n;
    vector<vector<int>> points(n, vector<int>(2));
    for (int i = 0; i < n; i++) cin >> points[i][0] >> points[i][1];
    cout << maxPoints(points) << endl;
}
```

**Time Complexity**: O(n^2).  
**Space Complexity**: O(n).  
**Notes**:  
- Solved using hash map for slopes.  
- Test [[1,1]], [[1,1],[1,1]].  
- Tip: Practice LeetCode #149, handle precision issues.

## Round 2: Technical Interview (Onsite/Video Call)

**Duration**: ~60–90 minutes, Zoom.  
**Details**: System Design (Logging System), DSA (Lexicographically Minimum Path), OS/Threading questions.  
**Outcome**: Advanced to Round 3.

### Question 4: Design a Logging System Using OOPS

**Problem Statement**:  
- Design a logging system using all 4 OOPS concepts (Polymorphism, Inheritance, Abstraction, Encapsulation).  
- **Requirements**: Log messages with levels (INFO, ERROR), support multiple outputs (console, file).

**Approach**:  
- **OOPS Design**:  
  - **Abstraction**: Abstract `Logger` class with log method.  
  - **Inheritance**: `ConsoleLogger`, `FileLogger` inherit from `Logger`.  
  - **Polymorphism**: Override `log` method for different outputs.  
  - **Encapsulation**: Private log storage, public log interface.  
- **Classes**:  
  - `Logger`: Abstract base class.  
  - `ConsoleLogger`: Logs to console.  
  - `FileLogger`: Logs to file (simulated).  
  - `LogMessage`: Stores level, message, timestamp.  
- **Edge Cases**: Invalid log levels, file write errors.

**Code Snippet (Java)**:  
```java
import java.util.*;

abstract class Logger {
    protected List<LogMessage> logs = new ArrayList<>();
    abstract void log(String message, String level);
}

class LogMessage {
    String message, level, timestamp;
    LogMessage(String message, String level, String timestamp) {
        this.message = message;
        this.level = level;
        this.timestamp = timestamp;
    }
}

class ConsoleLogger extends Logger {
    @Override
    void log(String message, String level) {
        String timestamp = new Date().toString();
        logs.add(new LogMessage(message, level, timestamp));
        System.out.println("[" + level + "] " + timestamp + ": " + message);
    }
}

class FileLogger extends Logger {
    @Override
    void log(String message, String level) {
        String timestamp = new Date().toString();
        logs.add(new LogMessage(message, level, timestamp));
        // Simulate file write
        System.out.println("Writing to file: [" + level + "] " + timestamp + ": " + message);
    }
}

class LoggingSystem {
    private Logger logger;
    LoggingSystem(Logger logger) { this.logger = logger; }
    void log(String message, String level) {
        if (Arrays.asList("INFO", "ERROR").contains(level)) {
            logger.log(message, level);
        }
    }
}
```

**Notes**:  
- Designed with all OOPS concepts, explained clearly.  
- Tip: Study system design (Grokking OOD), practice LLD.

### Question 5: Lexicographically Minimum Path in Graph

**Problem Statement**:  
- Given a graph of cities, find the lexicographically minimum path from source to destination (not shortest).  
- **Example**: Input: Graph {A->B,C; B->D; C->D}, Source=A, Dest=D → Output: [A,C,D].

**Approach**:  
- **Brute Force**: DFS to find all paths, sort lexicographically (O(n!)).  
- **Optimal Approach**: Modified DFS with priority queue.  
  - Pointwise:  
    1. Use DFS, prioritize neighbors lexicographically.  
    2. Track visited nodes, build path.  
    3. Return first valid path (lexicographically smallest).  
  - Edge cases: No path, cycles, single node.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

class Graph {
    unordered_map<string, vector<string>> adj;
public:
    void addEdge(string u, string v) { adj[u].push_back(v); }
    vector<string> lexMinPath(string src, string dest) {
        for (auto& p : adj) sort(p.second.begin(), p.second.end());
        vector<string> path, result;
        set<string> visited;
        dfs(src, dest, visited, path, result);
        return result;
    }
private:
    void dfs(string curr, string dest, set<string>& visited, vector<string>& path, vector<string>& result) {
        if (!result.empty()) return;
        path.push_back(curr);
        visited.insert(curr);
        if (curr == dest) {
            result = path;
            return;
        }
        for (string next : adj[curr]) {
            if (!visited.count(next)) {
                dfs(next, dest, visited, path, result);
            }
        }
        path.pop_back();
        visited.erase(curr);
    }
};

void solve() {
    Graph g;
    // Input graph edges, source, destination
    // Example: g.addEdge("A", "B"); g.addEdge("A", "C"); ...
    string src, dest;
    cin >> src >> dest;
    vector<string> path = g.lexMinPath(src, dest);
    for (string city : path) cout << city << " ";
    cout << endl;
}
```

**Time Complexity**: O(V!), optimized to O(V+E) for first valid path.  
**Space Complexity**: O(V).  
**Notes**:  
- Solved using DFS with lexicographical sorting.  
- Test acyclic graphs, no path cases.  
- Tip: Practice GFG graph problems, focus on DFS.

### Question 6: OS and Threading Questions

**Problem Statement**:  
- Questions on OS fundamentals, focusing on threading.

**Approach**:  
- **Sample Questions**:  
  - **What is a thread?**: Lightweight process, shares memory.  
  - **Thread vs. Process**: Process is independent, thread shares process resources.  
  - **Multithreading Benefits**: Parallelism, efficient resource use.  
  - **Mutex vs. Semaphore**: Mutex for mutual exclusion, semaphore for signaling.  
- **Example (C++)**:  
```cpp
#include <thread>
#include <mutex>
std::mutex mtx;
void task() {
    mtx.lock();
    // Critical section
    mtx.unlock();
}
```

**Notes**:  
- Answered clearly, tied to practical examples.  
- Tip: Study OS (GFG OS), focus on threading, synchronization.

## Round 3: Technical Interview (Onsite/Video Call)

**Duration**: ~60–90 minutes, Zoom.  
**Details**: DSA (Next/Previous Permutation), project discussion, behavioral questions.  
**Outcome**: Advanced to Round 4.

### Question 7: Next Permutation

**Problem Statement**:  
- Find the next lexicographically greater permutation of a number in O(n).  
- **Example**: Input: [1,2,3] → Output: [1,3,2].  
- **Link**: [LeetCode #31](https://leetcode.com/problems/next-permutation/).

**Approach**:  
- **Optimal Approach**:  
  - Pointwise:  
    1. Find first i where arr[i] < arr[i+1] from right.  
    2. Find smallest j > i where arr[j] > arr[i].  
    3. Swap arr[i] and arr[j].  
    4. Reverse arr[i+1] to end.  
  - Edge cases: Last permutation, single element.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

void nextPermutation(vector<int>& arr) {
    int n = arr.size(), i = n - 2;
    while (i >= 0 && arr[i] >= arr[i + 1]) i--;
    if (i >= 0) {
        int j = n - 1;
        while (j > i && arr[j] <= arr[i]) j--;
        swap(arr[i], arr[j]);
    }
    reverse(arr.begin() + i + 1, arr.end());
}

void solve() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];
    nextPermutation(arr);
    for (int x : arr) cout << x << " ";
    cout << endl;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved correctly, from Striver’s SDE Sheet.  
- Test [3,2,1], [1].  
- Tip: Practice LeetCode #31, master permutation logic.

### Question 8: Previous Permutation

**Problem Statement**:  
- Find the previous lexicographically smaller permutation of a number in O(n).  
- **Example**: Input: [1,3,2] → Output: [1,2,3].  
- **Link**: [LeetCode #1053](https://leetcode.com/problems/previous-permutation-with-one-swap/).

**Approach**:  
- **Optimal Approach**:  
  - Pointwise:  
    1. Find first i where arr[i] > arr[i+1] from right.  
    2. Find largest j > i where arr[j] < arr[i].  
    3. Swap arr[i] and arr[j].  
    4. Reverse arr[i+1] to end (optional, depends on problem).  
  - Edge cases: First permutation, single element.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

void prevPermutation(vector<int>& arr) {
    int n = arr.size(), i = n - 2;
    while (i >= 0 && arr[i] <= arr[i + 1]) i--;
    if (i >= 0) {
        int j = n - 1;
        while (j > i && arr[j] >= arr[i]) j--;
        swap(arr[i], arr[j]);
    }
    // No reverse needed for one swap
}

void solve() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];
    prevPermutation(arr);
    for (int x : arr) cout << x << " ";
    cout << endl;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved correctly, similar to next permutation.  
- Test [1,2,3], [1].  
- Tip: Practice LeetCode #1053, compare with next permutation.

### Question 9: Project Discussion

**Problem Statement**:  
- Discuss your projects in detail.

**Sample Answer**:  
- **Situation**: “Built a real-time stock analytics platform.”  
- **Task**: “Develop efficient data processing.”  
- **Action**: “Used C++, optimized queries, integrated APIs.”  
- **Result**: “Reduced latency by 30%, processed 10k records/sec.”  

**Notes**:  
- Highlighted technical impact, tied to role.  
- Tip: Know resume projects thoroughly, quantify results (GFG resume guide).

### Question 10: Behavioral Questions

**Problem Statement**:  
- Answer behavioral questions (e.g., teamwork, challenges).

**Sample Answer**:  
- **Situation**: “Led a team in a hackathon.”  
- **Task**: “Deliver a working app under tight deadlines.”  
- **Action**: “Assigned roles, coded backend, resolved conflicts.”  
- **Result**: “Won second place, improved team collaboration.”  

**Notes**:  
- Used STAR, showed soft skills.  
- Tip: Prepare 2–3 STAR stories (JavaTpoint HR).

## Round 4: HR/Managerial Round

**Duration**: ~30–60 minutes, Zoom.  
**Details**: Behavioral questions, managerial focus.  
**Outcome**: Selected as Technology Analyst Intern.

### Question 11: HR/Managerial Questions

**Problem Statement**:  
- Answer managerial questions (e.g., leadership, career goals).

**Sample Answer**:  
- **Situation**: “Managed a project team of 5.”  
- **Task**: “Ensure timely delivery.”  
- **Action**: “Set milestones, conducted reviews, mentored juniors.”  
- **Result**: “Delivered project 2 days early, gained leadership skills.”  

**Notes**:  
- Emphasized leadership, aligned with Morgan Stanley’s values.  
- Tip: Research company culture (careers.morganstanley.com), use STAR.

## Key Takeaways and Preparation Tips

- **Online Coding**:  
  - Master medium DSA (LeetCode #20, #1000, #149).  
  - Solve all problems, focus on edge cases.  
  - Use Striver’s SDE Sheet, Blind 75.  
- **Technical Rounds**:  
  - OOPS: Master 4 pillars, practice LLD (Grokking OOD).  
  - DSA: Solve permutation, graph problems (LeetCode #31, #1053).  
  - OS: Study threading, mutex (GFG OS).  
  - Projects: Quantify impact, know tech stack.  
- **HR/Managerial**:  
  - Use STAR for behavioral questions.  
  - Align answers with Morgan Stanley’s tech-finance focus.  
- **Resources**:  
  - **Coding**: Striver’s SDE Sheet, LeetCode, GFG.  
  - **OOPS/System Design**: GFG Java, Grokking OOD, YouTube.  
  - **OS**: GFG OS, StudyTonight.  
  - **HR**: JavaTpoint, Glassdoor.  
  - **Resume**: GFG Resume Guide.  
- **Interview Day**: Explain thought process, stay confident, ask about team projects.  
- **General**: Morgan Stanley values DSA, OOPS, system design, and communication. Don’t exaggerate resume, stay positive.

**Final Note**: Grind DSA, own your projects, and bring the vibe, bruh—Morgan Stanley’s calling your name!