# Morgan Stanley Interview Experience for FTE (On-Campus) 2025

This document details the **Morgan Stanley Interview Experience for FTE (On-Campus) 2025**, conducted on the AMCAT platform, as shared on July 12, 2025. The process included an Online Assessment (OA) with Debugging, MCQs, and Coding sections, followed by three interview rounds (Technical, System Design, HR). The candidate solved all coding questions (including the tough DP problem), answered all Technical Round questions, excelled in System Design, and was one of 3 selected out of 31 shortlisted. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers for behavioral/situational questions.

Let’s dive in, bruh—this is your ultimate guide to crushing Morgan Stanley’s FTE process!

## Online Assessment (OA)

The OA was on the **AMCAT platform** with three sections: Debugging (20 min, 7 questions), MCQs (20 min, 10 questions), and Coding (60 min, 3 questions). No debugging was allowed in the coding section.

### Section 1: Debugging

**Problem Statement**:  
- 7 easy questions, 20 minutes.
- Goal: Fix code by correcting signs, logic, syntax, or completing functions to pass test cases.
- Examples: Adjust loop bounds, fix operators, complete logic (e.g., swap variables).

**Approach**:  
- **Strategy**:  
  1. Read problem and expected output.  
  2. Identify syntax errors (e.g., missing semicolons, extra colons).  
  3. Correct logical errors (e.g., off-by-one, wrong conditions).  
  4. Implement incomplete functions.  
- **Edge Cases**: Empty inputs, boundary values, incorrect output formats.

**Code Snippet (C++ Example)**:  
```cpp
// Example: Fix swap function (incorrect logic)
#include <bits/stdc++.h>
using namespace std;

// Incorrect code (given)
void swap(int a, int b) {
    a = b;  // Error: Doesn't swap
    b = a;
}

// Corrected code
void swap(int& a, int& b) {  // Fix: Use references
    int temp = a;
    a = b;
    b = temp;
}
```

**Time Complexity**: O(1) to O(n) depending on problem.  
**Space Complexity**: O(1) or O(n).  
**Notes**:  
- Solved all 7 questions (easy with practice).  
- Tip: Practice debugging on HackerRank/LeetCode. Focus on common errors: uninitialized variables, pointer issues. Test edge cases like n=0.

### Section 2: MCQs (Aptitude and Quant)

**Problem Statement**:  
- 10 questions, 20 minutes, easy to medium difficulty.
- Topics: Quantitative Aptitude (e.g., time-and-work, probability), Logical Reasoning, Data Interpretation.

**Approach**:  
- **Preparation**:  
  - Practice quants (ratios, percentages), permutations, data interpretation.  
  - Study logical reasoning puzzles.  
- **Strategy**:  
  1. Prioritize easy questions (e.g., basic arithmetic).  
  2. Use elimination for MCQs to save time.  
  3. Read graphs/tables carefully for data interpretation.  
- **Edge Cases**: Tricky wording, misleading options.

**Notes**:  
- Solved most questions; practice critical for speed.  
- Resources: GeeksforGeeks Quantitative Aptitude, RS Aggarwal, AMCAT mock tests.  
- Tip: Aim for 8/10 correct in 15 minutes to leave buffer time.

### Section 3: Coding Round

Three coding questions (easy, easy, medium), 60 minutes, no debugging allowed. The candidate solved all, including the medium DP problem.

#### Question 1: First Negative Number in Every Window of Size K

**Problem Statement**:  
Given an array of size n and window size k, find the first negative number in every window of size k. If no negative number exists, return 0 for that window.  
- **Example**: Input: arr = [12, -1, -7, 8, -15, 30, 16, 28], k = 3  
  Output: [-1, -1, -7, -15, -15, 0]  
- **Constraints**: O(n) time complexity.

**Approach**:  
- **Brute Force**: Check each window (O(n*k)).  
- **Optimal Approach**: Use deque to track negative numbers.  
  - Pointwise:  
    1. Use deque to store indices of negative numbers in window.  
    2. For each window: Remove out-of-window indices, add new negative numbers.  
    3. Output front of deque (if non-empty) or 0.  
    - Edge cases: No negatives, k=1, k=n, empty array.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> firstNegative(vector<int>& arr, int n, int k) {
    deque<int> dq;
    vector<int> result;
    // Process first k elements
    for (int i = 0; i < k; i++) {
        if (arr[i] < 0) dq.push_back(i);
    }
    // Process windows
    for (int i = k; i <= n; i++) {
        result.push_back(dq.empty() ? 0 : arr[dq.front()]);
        // Remove out-of-window indices
        while (!dq.empty() && dq.front() <= i - k) dq.pop_front();
        // Add new negative number
        if (i < n && arr[i] < 0) dq.push_back(i);
    }
    return result;
}
```

**Time Complexity**:  
- Brute: O(n*k).  
- Optimal: O(n) with deque.  
**Space Complexity**: O(k) for deque.  
**Notes**:  
- Solved with O(n) complexity.  
- GFG “First negative integer in every window.” Practice with k=n, no negatives.

#### Question 2: Merge Intervals

**Problem Statement**:  
Given a collection of intervals, merge overlapping intervals and return the merged intervals.  
- **Example**: Input: [[1,3], [2,6], [8,10], [15,18]]  
  Output: [[1,6], [8,10], [15,18]]  
- **Link**: https://www.geeksforgeeks.org/dsa/merging-intervals/

**Approach**:  
- **Brute Force**: Check all pairs for overlap (O(n²)).  
- **Optimal Approach**: Sort and merge.  
  - Pointwise:  
    1. Sort intervals by start time.  
    2. Iterate: Merge if current start ≤ previous end, else add new interval.  
    3. Output merged intervals.  
    - Edge cases: No overlap, single interval, empty input.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<vector<int>> mergeIntervals(vector<vector<int>>& intervals) {
    if (intervals.empty()) return {};
    sort(intervals.begin(), intervals.end());
    vector<vector<int>> result;
    int start = intervals[0][0], end = intervals[0][1];
    for (int i = 1; i < intervals.size(); i++) {
        if (intervals[i][0] <= end) {
            end = max(end, intervals[i][1]);
        } else {
            result.push_back({start, end});
            start = intervals[i][0];
            end = intervals[i][1];
        }
    }
    result.push_back({start, end});
    return result;
}
```

**Time Complexity**:  
- Brute: O(n²).  
- Optimal: O(n log n) for sort + O(n) for merge.  
**Space Complexity**: O(1) excluding output.  
**Notes**:  
- Solved; GFG “Merging Intervals.”  
- LeetCode #56. Test cases like [[1,4], [4,5]] (touching intervals).

#### Question 3: Building Bridges (DP)

**Problem Statement**:  
Given n pairs of points representing south and north banks of a river, find max number of non-crossing bridges. Each bridge connects a south point to a north point, and no two bridges can cross.  
- **Example**: Input: south = [1,2,4,5], north = [2,1,5,4]  
  Output: 3 (bridges: 1-2, 2-1, 4-5)  
- **Link**: https://www.geeksforgeeks.org/dsa/dynamic-programming-building-bridges/

**Approach**:  
- **Brute Force**: Try all permutations (O(n!)).  
- **Optimal Approach**: Longest Increasing Subsequence (LIS) variant.  
  - Pointwise:  
    1. Sort pairs by south coordinates.  
    2. Apply LIS on north coordinates.  
    3. dp[i] = max non-crossing bridges ending at i.  
    - Edge cases: Identical points, n=1, no valid bridges.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int maxBridges(vector<int>& south, vector<int>& north) {
    int n = south.size();
    vector<pair<int, int>> points(n);
    for (int i = 0; i < n; i++) points[i] = {south[i], north[i]};
    sort(points.begin(), points.end());
    vector<int> dp(n, 1);
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (points[j].second <= points[i].second) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }
    return *max_element(dp.begin(), dp.end());
}
```

**Time Complexity**:  
- Brute: O(n!).  
- Optimal: O(n²) for LIS.  
**Space Complexity**: O(n) for dp array.  
**Notes**:  
- Solved (1 of 2-3 students); confusing wording but LIS-based.  
- GFG “Building Bridges.” Practice LIS variations (LeetCode #300).

**OA Performance**:  
- Solved all sections; only 2-3 solved DP question.  
- 31 shortlisted for interviews.

## Technical Interview Round 1

**Duration**: 45 minutes, conducted virtually.  
**Interviewer**: Skipped unanswered questions, focused on OOPS, DSA, OS, SQL.

### Question 4: Introduce Yourself

**Problem Statement**:  
- Provide a 1-2 minute introduction covering background, skills, and interests.

**Sample Answer**:  
- "Hi, I’m [Your Name], a B.Tech student in Computer Science with a CGPA of [X]. I’m passionate about DSA and system design, with skills in C++, Java, and SQL. I’ve built projects like a placement portal, optimizing for scalability. I’m excited to contribute to Morgan Stanley’s innovative financial systems."

**Notes**:  
- Keep concise, align with role.  
- Tip: Highlight projects and Morgan Stanley’s tech focus.

### Question 5: Difference Between C++ and Java

**Problem Statement**:  
- Explain key differences between C++ and Java.

**Approach**:  
- **C++**:  
  - Platform-dependent, compiled to machine code.  
  - Manual memory management (new/delete).  
  - Supports pointers, multiple inheritance.  
- **Java**:  
  - Platform-independent (JVM).  
  - Automatic garbage collection.  
  - No pointers, single inheritance (interfaces).  
- **Key Points**: Performance (C++ faster), portability (Java better), use cases (C++ for systems, Java for enterprise).

**Notes**:  
- Answered clearly.  
- Tip: Study memory management, inheritance. Resources: GeeksforGeeks, JavaTpoint.

### Question 6: Virtual Functions and Garbage Collector

**Problem Statement**:  
- Explain virtual functions and Java garbage collector in detail.

**Approach**:  
- **Virtual Functions (C++)**:  
  - Enable runtime polymorphism via virtual keyword.  
  - Stored in vtable, resolved dynamically.  
  - Example: Base class pointer calls derived class function.  
- **Garbage Collector (Java)**:  
  - Automatically reclaims unreachable objects.  
  - Process: Mark (find live objects), Sweep (reclaim), Compact (reduce fragmentation).  
  - Types: Serial, Parallel, CMS, G1 (low-pause).  
  - Generations: Young (Eden, Survivor), Old.

**Notes**:  
- Answered in detail.  
- Tip: Study vtables, GC algorithms (G1). Resources: Oracle Java Docs, C++ Reference.

### Question 7: Linked List – Loop Detection and Removal

**Problem Statement**:  
- Detect and remove a loop in a linked list, prove Floyd’s cycle detection mathematically.

**Approach**:  
- **Detect Loop (Floyd’s)**:  
  - Slow (1 step) and fast (2 steps) pointers meet if loop exists.  
- **Remove Loop**:  
  1. Find meeting point.  
  2. Move slow to head, advance both at 1 step to find loop start.  
  3. Set next of loop start to null.  
- **Proof**:  
  - Let loop start at k, loop length L.  
  - Slow enters loop after k steps, fast after k/2 (approx).  
  - Relative speed = 1, meet after L steps (gcd-based).  
- **Edge Cases**: No loop, single node, full loop.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

bool detectLoop(ListNode* head) {
    ListNode *slow = head, *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}

void removeLoop(ListNode* head) {
    ListNode *slow = head, *fast = head;
    bool loop = false;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            loop = true;
            break;
        }
    }
    if (!loop) return;
    slow = head;
    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }
    while (fast->next != slow) fast = fast->next;
    fast->next = nullptr;
}
```

**Time Complexity**: O(n) for detection/removal.  
**Space Complexity**: O(1).  
**Notes**:  
- Answered with proof.  
- LeetCode #141, #142. Practice edge cases (loop at head).

### Question 8: Linked List – Y-Shape Intersection

**Problem Statement**:  
- Find intersection point of Y-shaped linked lists. Identify case where standard solution fails.

**Approach**:  
- **Standard Solution**:  
  1. Get lengths of both lists.  
  2. Move longer list’s pointer by difference.  
  3. Advance both pointers; intersection is where they meet.  
- **Failure Case**: No intersection (lists don’t merge).  
- **Edge Cases**: Equal lengths, one list empty, intersection at head.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
    if (!headA || !headB) return nullptr;
    int lenA = 0, lenB = 0;
    ListNode *a = headA, *b = headB;
    while (a) { lenA++; a = a->next; }
    while (b) { lenB++; b = b->next; }
    a = headA; b = headB;
    if (lenA > lenB) {
        for (int i = 0; i < lenA - lenB; i++) a = a->next;
    } else {
        for (int i = 0; i < lenB - lenA; i++) b = b->next;
    }
    while (a && b && a != b) {
        a = a->next;
        b = b->next;
    }
    return a;
}
```

**Time Complexity**: O(n + m) for lengths, O(max(n,m)) for intersection.  
**Space Complexity**: O(1).  
**Notes**:  
- Identified failure case (no intersection).  
- LeetCode #160. Practice with no intersection, same length.

### Question 9: Boundary Order Traversal of a Tree (Logic)

**Problem Statement**:  
- Explain logic for boundary traversal of a binary tree (left boundary, leaves, right boundary in reverse).

**Approach**:  
- **Logic**:  
  1. Print left boundary (top-down, exclude leaves).  
  2. Print all leaf nodes (left-to-right).  
  3. Print right boundary (bottom-up, exclude leaves).  
- **Edge Cases**: Single node, skewed tree.

**Notes**:  
- Explained logic (no code required).  
- GFG “Boundary Traversal.” Practice with unbalanced trees.

### Question 10: Process vs. Thread

**Problem Statement**:  
- Explain process vs. thread, how to view threads on Windows.

**Approach**:  
- **Process vs. Thread**:  
  - Process: Independent program with own memory, resources.  
  - Thread: Lightweight unit within process, shares memory.  
- **View Threads on Windows**:  
  - Task Manager: Details tab, view threads per process.  
  - Performance Monitor: Monitor thread count.  
  - Programmatically: Use Windows API (GetThreadId).

**Notes**:  
- Answered clearly.  
- Tip: Study OS concepts, Windows tools. Resources: GFG OS Notes.

### Question 11: Topological Sorting

**Problem Statement**:  
- Explain topological sorting and implement it.

**Approach**:  
- **Logic**: Order vertices such that for every edge u->v, u comes before v.  
- **Algorithm**: DFS or Kahn’s (BFS).  
  - DFS: Recurse, push to stack post-visit.  
  - Kahn’s: Use in-degree, process nodes with in-degree 0.  
- **Edge Cases**: Cyclic graph, disconnected graph.

**Code Snippet (C++ DFS)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

void topologicalSortUtil(int v, vector<vector<int>>& adj, vector<bool>& visited, stack<int>& st) {
    visited[v] = true;
    for (int u : adj[v]) {
        if (!visited[u]) topologicalSortUtil(u, adj, visited, st);
    }
    st.push(v);
}

vector<int> topologicalSort(int V, vector<vector<int>>& adj) {
    vector<bool> visited(V, false);
    stack<int> st;
    for (int i = 0; i < V; i++) {
        if (!visited[i]) topologicalSortUtil(i, adj, visited, st);
    }
    vector<int> result;
    while (!st.empty()) {
        result.push_back(st.top());
        st.pop();
    }
    return result;
}
```

**Time Complexity**: O(V + E).  
**Space Complexity**: O(V) for stack/visited.  
**Notes**:  
- Answered with implementation.  
- LeetCode #207, #210. Practice Kahn’s algorithm.

### Question 12: SQL – WHERE vs. HAVING vs. GROUP BY

**Problem Statement**:  
- Explain differences between WHERE, HAVING, GROUP BY clauses.

**Approach**:  
- **WHERE**: Filters rows before grouping (e.g., `WHERE salary > 50000`).  
- **GROUP BY**: Groups rows by column (e.g., `GROUP BY dept_id`).  
- **HAVING**: Filters groups after GROUP BY (e.g., `HAVING COUNT(*) > 5`).  
- **Order**: WHERE → GROUP BY → HAVING.

**Notes**:  
- Answered clearly.  
- Tip: Practice SQL queries with aggregations. Resources: LeetCode SQL, GFG.

### Question 13: Normalization Types and Disadvantages

**Problem Statement**:  
- Explain database normalization types and their disadvantages.

**Approach**:  
- **Types**:  
  - 1NF: Atomic values, no repeating groups.  
  - 2NF: 1NF + no partial dependencies.  
  - 3NF: 2NF + no transitive dependencies.  
  - BCNF: 3NF + stricter functional dependencies.  
- **Disadvantages**:  
  - Increased complexity, more tables.  
  - Slower queries due to JOINs.  
  - Higher storage for indexes/keys.

**Notes**:  
- Answered fully.  
- Tip: Study normalization vs. denormalization trade-offs. Resources: GFG DBMS.

**Round 1 Performance**:  
- Answered all questions.  
- 20/31 shortlisted for Round 2.

## System Design Round 2

**Duration**: ~1 hour, communication-based.  
**Interviewer**: Helpful, focused on requirements and scalability.

### Question 14: Placement Portal Design

**Problem Statement**:  
- Design a web portal for college placement process, with prototype, scalability, and cross-question handling.

**Approach**:  
- **Requirements**:  
  - Student registration, job listings, application tracking.  
  - Admin features: Add jobs, manage applications.  
  - Company features: Post jobs, shortlist candidates.  
- **Entities**: Student, Job, Application, Company, Admin.  
- **APIs**:  
  - POST /register/student  
  - GET /jobs  
  - POST /apply/{jobId}  
  - GET /admin/applications  
- **Database**: MySQL (tables: Students, Jobs, Applications).  
- **Scalability**:  
  - Load balancer for API servers.  
  - Cache (Redis) for job listings.  
  - Shard DB by college ID.  
- **Concurrency**: Transactions for application submission.  
- **Prototype**:  
  - Initial: Simple REST API, single DB.  
  - Scaled: Add caching, sharding, async processing.  
- **Edge Cases**: High traffic, duplicate applications, data consistency.

**Notes**:  
- Impressed interviewer with iterative design, handled cross-questions.  
- Tip: Draw ER diagrams, discuss trade-offs (SQL vs. NoSQL). Resources: Gaurav Sen, GFG System Design.

**Round 2 Performance**:  
- 9/20 shortlisted for HR.

## HR Round 3

**Duration**: ~30 minutes, conducted by VP/ED with prior round reports.

### Question 15: Introduce Yourself and Previous Rounds

**Problem Statement**:  
- Introduce yourself, summarize previous rounds.

**Sample Answer**:  
- "I’m [Your Name], a B.Tech CSE student passionate about DSA and system design. In the OA, I solved all coding questions, including a tough DP problem. In Technical Round, I answered OOPS, DSA, and SQL questions confidently. In System Design, I designed a scalable placement portal, addressing concurrency and scalability."

**Notes**:  
- Be concise, highlight strengths.  
- Tip: Align with Morgan Stanley’s tech focus.

### Question 16: What Motivates You to Get Into Software Technology?

**Problem Statement**:  
- What drives your interest in software technology?

**Sample Answer**:  
- "I’m motivated by solving real-world problems through code. Building systems like a placement portal taught me how technology streamlines processes. The constant learning in software, like mastering DP or system design, excites me, and Morgan Stanley’s innovative financial systems align with my passion."

**Notes**:  
- Show genuine interest, tie to role.  
- Tip: Use personal anecdotes (e.g., first project).

### Question 17: Helping a Friend Out of Station

**Problem Statement**:  
- If your friend in another company asks for help while you’re out of station, what help would you provide, and what wouldn’t you do?

**Sample Answer**:  
- **Help**: "I’d offer remote guidance via call or chat, like debugging tips or resource links, ensuring it’s within my capacity and ethical boundaries."  
- **Not Do**: "I wouldn’t share proprietary code or violate company policies, as integrity is key."  

**Notes**:  
- Emphasize ethics, teamwork.  
- Tip: Highlight professionalism.

### Question 18: Where Do You See Yourself in 5 Years?

**Problem Statement**:  
- Where do you envision yourself in 5 years?

**Sample Answer**:  
- "In 5 years, I see myself as a senior engineer at Morgan Stanley, leading projects in financial systems, mentoring juniors, and mastering technologies like distributed systems. I aim to contribute to innovative solutions while growing as a technical leader."

**Notes**:  
- Align with career growth, company goals.  
- Tip: Avoid generic answers, focus on role-specific aspirations.

### Question 19: Qualities Lacking as a Team Leader

**Problem Statement**:  
- What qualities do you lack as a team leader, and how are you improving?

**Sample Answer**:  
- **Situation**: "I sometimes lack assertiveness in delegating tasks."  
- **Task**: "As a project lead, I needed to balance team dynamics."  
- **Action**: "I’m improving by setting clear expectations and practicing decisive communication in group projects."  
- **Result**: "My recent project saw better task distribution and timely delivery."

**Notes**:  
- Be honest, show improvement.  
- Tip: Use STAR method, avoid critical flaws.

### Question 20: Friends’ Suggestions for Improvement

**Problem Statement**:  
- What do your friends suggest you improve?

**Sample Answer**:  
- "My friends suggest I improve my time management, as I sometimes overcommit. I’m addressing this by using tools like Trello to prioritize tasks, which helped me balance academics and projects effectively."

**Notes**:  
- Choose minor, fixable flaws.  
- Tip: Show proactive steps.

### Question 21: Situation Where You Felt Useless to Friends

**Problem Statement**:  
- Describe a situation where you felt useless to your friends.

**Sample Answer**:  
- **Situation**: "During a hackathon, my team struggled with a UI bug, and I couldn’t help as I lacked frontend experience."  
- **Task**: "I needed to support my team despite my limitations."  
- **Action**: "I researched solutions online and coordinated with a frontend expert, enabling quick resolution."  
- **Result**: "We delivered the project, and I started learning React to avoid such situations."

**Notes**:  
- Show learning from failure.  
- Tip: Use STAR, emphasize growth.

**Round 3 Performance**:  
- 3/9 selected, including candidate.

## Key Takeaways and Preparation Tips

- **Practice DSA**: Solve medium-hard problems on LeetCode, InterviewBit, GFG. Focus on arrays, trees, DP, graphs.  
- **System Design**: Practice LLD (e.g., booking systems) and HLD (scalability, concurrency). Use diagrams, clarify requirements.  
- **SQL/OOPS/OS**: Master JOINs, GROUP BY, normalization; C++/Java differences; process/thread concepts.  
- **HR Prep**: Use STAR method for behavioral questions. Prepare stories for teamwork, leadership, failure. Research Morgan Stanley’s values (integrity, excellence).  
- **Communication**: Think aloud, ask clarifying questions, stay calm. If stuck, discuss partial solutions.  
- **Edge Cases**: Test code for empty inputs, boundaries, extremes.  
- **Resources**:  
  - **Coding**: LeetCode (medium-hard), GFG, InterviewBit.  
  - **System Design**: Gaurav Sen, GFG System Design.  
  - **OS/DBMS**: GFG Last Minute Notes.  
  - **Aptitude**: RS Aggarwal, AMCAT mocks.  
- **Interview Day**: Review resume, rest well, align answers with Morgan Stanley’s tech focus.