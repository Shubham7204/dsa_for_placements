# Morgan Stanley Interview Experience for Technology Analyst (On-Campus) 2022

This document details the **Morgan Stanley Interview Experience for Technology Analyst (On-Campus)**, shared on July 23, 2025, for the 2022 hiring cycle. Over 600 students with CGPA > 9 and 80% in 10th/12th were shortlisted for the Online Assessment (OA) on the Aspiring Minds (SHL) platform, with a choice between Enterprise Engineer and App Development tracks. The candidate chose App Development, excelled in the OA (6/7 debugging, 3/3 coding), and was among 8 selected for App Development interviews. The process included an OA, Technical Interview (Round 1), and Projects + HR Interview (Round 2), with 7/14 advancing to Round 2 and all 7 selected. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers for behavioral questions.

Let’s jump in, bruh—this is your ultimate guide to smashing Morgan Stanley’s Tech Analyst interview!

## Online Assessment

The OA lasted 2 hours on the SHL platform, with 3 sections: Debugging, Reasoning Ability, and Coding. No switching between sections, but backtracking within sections was allowed.

### Section 1: Debugging Round

**Problem Statement**:  
- 7 easy questions, 20 minutes, language of choice (C++ chosen).  
- Task: Amend code (reverse sign, fix logic/syntax) to pass test cases.  
- Topics: Basic syntax, logical errors (e.g., incorrect loops, conditions).  
- Solved 6/7.

**Approach**:  
- **Strategy**:  
  1. Read requirements carefully.  
  2. Identify syntax errors (e.g., missing semicolons, wrong operators).  
  3. Fix logic (e.g., incorrect loop bounds, conditionals).  
  4. Test mentally with sample inputs.  
- **Edge Cases**: Null inputs, boundary values, incorrect outputs.

**Notes**:  
- Fast debugging key due to time limit.  
- Resources: GFG Debugging Practice, HackerRank.  
- Tip: Practice fixing 5-minute code snippets, aim for 7/7.

### Section 2: Reasoning Ability

**Problem Statement**:  
- 10 questions, 20 minutes, medium difficulty.  
- Topics: Quantitative aptitude (e.g., probability, percentages), logical reasoning (e.g., puzzles).  
- Minimal calculations required.

**Approach**:  
- **Strategy**:  
  1. Solve arithmetic questions first (e.g., ratios, averages).  
  2. Use elimination for logical puzzles.  
  3. Verify units/conditions in quants.  
- **Edge Cases**: Tricky wording, negative numbers.

**Notes**:  
- Solved most, time management critical.  
- Resources: RS Aggarwal, GFG Aptitude.  
- Tip: Practice 10-minute aptitude sets, aim for 8/10.

### Section 3: Coding Round

**Duration**: 60 minutes, 3 questions (2 easy, 1 hard), C++ chosen.

#### Question 1: Maximum Profit by Buying and Selling Shares

**Problem Statement**:  
Given an array of stock prices and integer k, find the maximum profit by buying and selling at most k times.  
- **Link**: [GFG - Maximum Profit](https://www.geeksforgeeks.org/dsa/maximum-profit-by-buying-and-selling-a-share-at-most-k-times/).  
- **Example**: Input: prices=[10,22,5,75,65,80], k=2 → Output: 87 (buy 10, sell 22; buy 5, sell 80).  
- **Constraints**: k ≤ 10^9, n ≤ 10^3.

**Approach**:  
- **Brute Force**: Try all transaction combinations (O(n^(2k))).  
- **Optimal Approach**: Dynamic Programming.  
  - Pointwise:  
    1. If k ≥ n/2, use greedy approach (sum all positive price differences).  
    2. Else, use DP: dp[i][j][0/1] = max profit till day i with j transactions, holding/not holding.  
    - Edge cases: k=0, empty array, k > n/2.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int maxProfit(vector<int>& prices, int k) {
    int n = prices.size();
    if (n < 2) return 0;
    // If k is large, use greedy
    if (k >= n/2) {
        int profit = 0;
        for (int i = 1; i < n; i++) {
            if (prices[i] > prices[i-1]) profit += prices[i] - prices[i-1];
        }
        return profit;
    }
    // DP: dp[i][j][0/1] = max profit till day i, j transactions, holding/not
    vector<vector<vector<int>>> dp(n, vector<vector<int>>(k+1, vector<int>(2, 0)));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j <= k; j++) {
            if (i == 0) {
                dp[i][j][0] = 0;
                dp[i][j][1] = -prices[i];
                continue;
            }
            dp[i][j][0] = dp[i-1][j][0];
            if (j > 0 && dp[i-1][j-1][1] != INT_MIN)
                dp[i][j][0] = max(dp[i][j][0], dp[i-1][j-1][1] + prices[i]);
            dp[i][j][1] = dp[i-1][j][1];
            if (dp[i-1][j][0] != INT_MIN)
                dp[i][j][1] = max(dp[i][j][1], dp[i-1][j][0] - prices[i]);
        }
    }
    return dp[n-1][k][0];
}
```

**Time Complexity**: O(min(n², n*k)).  
**Space Complexity**: O(n*k).  
**Notes**:  
- Solved with DP, handled large k.  
- LeetCode #188. Test k=0, single price.

#### Question 2: Range Selection in Tree

**Problem Statement**:  
Given a tree and range [low, high], select nodes with values in range. Input includes fake inputs to discard.  
- **Example**: Input: Tree=[5,3,7,2,4], low=3, high=5 → Output: [3,4,5].  
- **Constraints**: Standard tree, fake inputs ignored.

**Approach**:  
- **Assumption**: Tree traversal (inorder) to collect nodes in range.  
- **Optimal Approach**: DFS traversal.  
  - Pointwise:  
    1. Perform inorder DFS, check if node value in [low, high].  
    2. Ignore fake inputs (e.g., metadata).  
    3. Collect valid nodes in result.  
    - Edge cases: Empty tree, no nodes in range, invalid range.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

void rangeSelection(TreeNode* root, int low, int high, vector<int>& result) {
    if (!root) return;
    rangeSelection(root->left, low, high, result);
    if (root->val >= low && root->val <= high) result.push_back(root->val);
    rangeSelection(root->right, low, high, result);
}

vector<int> getNodesInRange(TreeNode* root, int low, int high) {
    vector<int> result;
    rangeSelection(root, low, high, result);
    return result;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(h) for recursion stack (h = tree height).  
**Notes**:  
- Solved by ignoring fake inputs, used inorder.  
- GFG “Range Queries.” Test empty range, single node.

#### Question 3: Fixed-Length Sliding Window

**Problem Statement**:  
Given an array and window size k, solve a sliding window problem (likely max sum or similar).  
- **Example**: Input: arr=[1,4,2,10,2,3,1], k=3 → Output: 16 (max sum: 4+2+10).  
- **Constraints**: k ≤ n.

**Approach**:  
- **Brute Force**: Compute sum for each window (O(n*k)).  
- **Optimal Approach**: Sliding window.  
  - Pointwise:  
    1. Compute sum of first k elements.  
    2. Slide window, subtract first element, add next.  
    3. Track maximum sum.  
    - Edge cases: k=n, k=1, negative numbers.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int maxSlidingWindowSum(vector<int>& arr, int k) {
    int n = arr.size();
    if (k > n) return 0;
    int currSum = 0;
    for (int i = 0; i < k; i++) currSum += arr[i];
    int maxSum = currSum;
    for (int i = k; i < n; i++) {
        currSum += arr[i] - arr[i-k];
        maxSum = max(maxSum, currSum);
    }
    return maxSum;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved with sliding window.  
- LeetCode #239 variant. Test negative numbers, k=n.

**OA Performance**:  
- Solved 6/7 debugging, all 3 coding questions.  
- 14/600+ shortlisted (8 for App Development).

## Technical Interview (Round 1)

**Duration**: ~45 minutes, technical focus, next day after OA.  
**Interviewer**: Asked behavioral, OOPS, coding, and OS questions.

### Question 4: Introduction and Behavioral

**Problem Statement**:  
- Introduce yourself, answer behavioral questions (unspecified).

**Sample Answer**:  
- **Introduction**: "I’m a final-year CSE student with a 9.2 CGPA, passionate about DSA and web development. I’ve freelanced for 1.5 years, building scalable apps."  
- **Behavioral**: "I prioritize teamwork and problem-solving, demonstrated in hackathons where I led teams to success."

**Notes**:  
- Kept concise, relevant.  
- Tip: Prepare a 1-minute intro, tie to role.

### Question 5: Polymorphism in Databases

**Problem Statement**:  
- How is polymorphism used in databases?

**Approach**:  
- **Explanation**:  
  - Polymorphism in DB: Storing different data types in a column (e.g., JSON in NoSQL, VARCHAR for mixed types).  
  - Example: MongoDB stores varied objects in a collection, queried uniformly.  
  - Relational DB: Inheritance-like tables (e.g., Employee table with subtypes Manager, Engineer).  
- **Edge Cases**: Schema flexibility vs. consistency, query performance.

**Notes**:  
- Answered with examples.  
- Tip: Study NoSQL/Relational DB concepts (GFG DBMS).

### Question 6: Predict Output (Return by Reference)

**Problem Statement**:  
- Predict output of a C++ code snippet using return by reference.  
- **Link**: [GFG - Return by Reference](https://www.geeksforgeeks.org/cpp/return-by-reference-in-c-with-examples/).

**Approach**:  
- **Explanation**:  
  - Return by reference returns a reference to a variable, allowing modification.  
  - Example: `int& func(int& x) { return x; }` returns reference to x.  
  - Initially thought compilation error, corrected with hint (valid in C++).  
- **Sample Code**:  
  ```cpp
  int& func(int& x) { return x; }
  int main() {
      int a = 10;
      int& b = func(a);
      b = 20;
      cout << a; // Outputs 20
  }
  ```

**Notes**:  
- Corrected with hint, answered follow-up.  
- Tip: Study C++ references, pointers (GFG C++).

### Question 7: Predict Output (Inheritance)

**Problem Statement**:  
- Predict output of a code snippet on inheritance, answer follow-up.

**Approach**:  
- **Assumption**: Code involves virtual functions/overriding.  
- **Explanation**:  
  - Base class with virtual function, derived class overrides.  
  - Polymorphic call via base pointer invokes derived method.  
- **Sample Code (Java)**:  
  ```java
  class Base {
      void show() { System.out.println("Base"); }
  }
  class Derived extends Base {
      void show() { System.out.println("Derived"); }
  }
  class Main {
      public static void main(String[] args) {
          Base b = new Derived();
          b.show(); // Outputs: Derived
      }
  }
  ```
- **Follow-up**: Likely on virtual functions or overriding rules.

**Notes**:  
- Answered correctly.  
- Tip: Study inheritance, polymorphism (GFG Java).

### Question 8: Sum of Squares of Diagonal Elements

**Problem Statement**:  
- Given a 2D matrix, compute the sum of squares of elements in both diagonals.  
- **Example**: Input: [[1,2,3],[4,5,6],[7,8,9]] → Output: 1²+5²+9²+3²+5²+7² = 1+25+81+9+25+49 = 190.

**Approach**:  
- **Brute Force**: Iterate matrix, check diagonal conditions (O(n²)).  
- **Optimal Approach**: Direct diagonal traversal.  
  - Pointwise:  
    1. Sum squares of primary diagonal (i==j).  
    2. Sum squares of secondary diagonal (i+j==n-1).  
    3. Handle overlap (i==j==n-1-i) to avoid double-counting.  
    - Edge cases: 1×1 matrix, non-square matrix.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int sumOfDiagonalSquares(vector<vector<int>>& matrix) {
    int n = matrix.size(), sum = 0;
    for (int i = 0; i < n; i++) {
        sum += matrix[i][i] * matrix[i][i]; // Primary diagonal
        sum += matrix[i][n-1-i] * matrix[i][n-1-i]; // Secondary diagonal
        if (i == n-1-i) sum -= matrix[i][i] * matrix[i][i]; // Avoid double-counting
    }
    return sum;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved efficiently.  
- GFG “Matrix Diagonals.” Test 1×1, overlapping diagonals.

### Question 9: Circular List Operations

**Problem Statement**:  
- Given a circular list, implement: (1) Delete from end, (2) Insert at given index.  
- **Example**: Input: 1↔2↔3, delete end → 1↔2, insert 4 at index 1 → 1↔4↔2.  
- **Constraints**: Use doubly linked list.

**Approach**:  
- **Delete from End**:  
  - Traverse to last node, update prev/next pointers.  
- **Insert at Index**:  
  - Traverse to index, adjust prev/next pointers.  
- **Edge Cases**: Empty list, single node, index=0, invalid index.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int val;
    Node *prev, *next;
    Node(int x) : val(x), prev(nullptr), next(nullptr) {}
};

class CircularList {
    Node* head;
public:
    CircularList() : head(nullptr) {}
    void deleteEnd() {
        if (!head) return;
        if (head->next == head) {
            delete head;
            head = nullptr;
            return;
        }
        Node* last = head->prev;
        last->prev->next = head;
        head->prev = last->prev;
        delete last;
    }
    void insertAtIndex(int val, int index) {
        if (index < 0) return;
        Node* newNode = new Node(val);
        if (!head) {
            if (index == 0) {
                head = newNode;
                head->next = head->prev = head;
            }
            return;
        }
        Node* curr = head;
        for (int i = 0; i < index && curr->next != head; i++) curr = curr->next;
        newNode->next = curr;
        newNode->prev = curr->prev;
        curr->prev->next = newNode;
        curr->prev = newNode;
        if (index == 0) head = newNode;
    }
};
```

**Time Complexity**:  
- Delete: O(1) with tail pointer, else O(n).  
- Insert: O(n) for traversal.  
**Space Complexity**: O(1).  
**Notes**:  
- Implemented delete, struggled with insert due to time.  
- GFG “Circular Doubly Linked List.” Test index=0, single node.

### Question 10: Namespaces in C++

**Problem Statement**:  
- Explain namespaces in C++. Purpose and usage.

**Approach**:  
- **Explanation**:  
  - Namespaces prevent name conflicts by grouping code (e.g., `std::cout`).  
  - Purpose: Organize code, avoid ambiguity in large projects.  
  - Usage: `namespace ns { int x; }`, access via `ns::x` or `using namespace ns;`.  
- **Edge Cases**: Nested namespaces, namespace aliasing.

**Notes**:  
- Answer unsatisfactory, advised to clear basics.  
- Tip: Study C++ namespaces (GFG C++).

### Question 11: OS and OOPS Rapid-Fire

**Problem Statement**:  
- Answer questions on OS and OOPS:  
  - Process vs. Threads.  
  - Virtual Memory.  
  - Scheduling Algorithms.

**Approach**:  
- **Process vs. Threads**:  
  - Process: Independent program with own memory, heavier.  
  - Thread: Lightweight, shares process memory, runs concurrently.  
- **Virtual Memory**:  
  - Abstracts physical memory, uses paging/swapping for isolation, efficiency.  
- **Scheduling Algorithms**:  
  - FCFS, SJF, Round Robin, Priority Scheduling.  
  - Example: Round Robin ensures fairness with time quanta.  
- **Edge Cases**: Deadlocks, priority inversion, memory thrashing.

**Notes**:  
- Answered all, redeemed namespace mistake.  
- Tip: Study OS basics (GFG OS Notes), OOPS (GFG Java).

### Question 12: Questions for Interviewer

**Problem Statement**:  
- Ask about interviewer’s experience at Morgan Stanley.

**Sample Answer**:  
- “What’s been your most exciting project at Morgan Stanley? How does the App Development team collaborate on tech solutions?”

**Notes**:  
- Cut short due to time.  
- Tip: Prepare 2-3 thoughtful questions.

**Round 1 Performance**:  
- Handled most questions, struggled with namespaces and insert operation.  
- 7/14 shortlisted for Round 2.

## Projects + HR Interview (Round 2)

**Duration**: ~45 minutes, focused on projects and HR.  
**Interviewer**: Senior, impressed with freelancing projects.

### Question 13: About Yourself (Not on Resume)

**Problem Statement**:  
- Tell something about yourself not on your resume.

**Sample Answer**:  
- **Situation**: “Beyond my resume, I’m passionate about mentoring.”  
- **Task**: “I help peers with DSA and freelancing.”  
- **Action**: “Organized coding workshops, shared project tips.”  
- **Result**: “Built a community, enhanced my leadership skills.”

**Notes**:  
- Highlighted unique traits.  
- Tip: Share personal passions, tie to teamwork.

### Question 14: Hobbies

**Problem Statement**:  
- What are your hobbies?

**Sample Answer**:  
- **Situation**: “I enjoy competitive programming and hiking.”  
- **Task**: “Balance technical and outdoor activities.”  
- **Action**: “Participate in Codeforces, hike weekly to recharge.”  
- **Result**: “Improved focus and problem-solving.”

**Notes**:  
- Kept relevant, engaging.  
- Tip: Choose hobbies showing balance or skills.

### Question 15: Project Discussion

**Problem Statement**:  
- Discuss your freelancing projects (1.5 years, solo/team).

**Sample Answer**:  
- **Situation**: “Freelanced for startups, built web and mobile apps.”  
- **Task**: “Delivered scalable, user-friendly solutions.”  
- **Action**: “Developed a booking app with React and NodeJS, optimized DB queries.”  
- **Result**: “Clients saw 30% user growth, learned full-stack development.”

**Notes**:  
- Impressed interviewer with impact.  
- Tip: Prepare 2-3 projects, highlight challenges and tech stack.

### Question 16: Ethical Decision

**Problem Statement**:  
- Describe a moral/ethical decision others disagreed with.

**Sample Answer**:  
- **Situation**: “During a freelance project, client pushed for rushed delivery.”  
- **Task**: “Ensure quality over speed.”  
- **Action**: “Advocated for proper testing, delayed release by a week.”  
- **Result**: “App had zero bugs, client gained trust, team respected decision.”

**Notes**:  
- Showed integrity.  
- Tip: Use STAR, emphasize ethics (Morgan Stanley’s value).

### Question 17: Entrepreneurial Spirit vs. Company Job

**Problem Statement**:  
- With your freelancing entrepreneurial spirit, why join Morgan Stanley?

**Sample Answer**:  
- **Situation**: “Freelancing gave me flexibility and ownership.”  
- **Task**: “I want to scale my impact in a global firm.”  
- **Action**: “Morgan Stanley’s tech-driven finance aligns with my system design skills.”  
- **Result**: “I’m excited to contribute to innovative platforms.”

**Notes**:  
- Tied freelancing to company goals.  
- Tip: Research Morgan Stanley’s tech focus.

### Question 18: Freedom in Projects

**Problem Statement**:  
- Describe a time when you didn’t have freedom in tech stack or hours.

**Sample Answer**:  
- **Situation**: “Worked on a client project with fixed PHP stack.”  
- **Task**: “Deliver under strict deadlines, unfamiliar tech.”  
- **Action**: “Learned PHP quickly, optimized workflows within constraints.”  
- **Result**: “Met deadlines, improved adaptability.”

**Notes**:  
- Showed resilience.  
- Tip: Highlight adaptability, learning curve.

### Question 19: Questions for Interviewer

**Problem Statement**:  
- Any questions for the interviewer?

**Sample Answer**:  
- “How does Morgan Stanley foster innovation in its tech teams? What’s the typical career path for a Technology Analyst?”

**Notes**:  
- Asked relevant questions.  
- Tip: Prepare questions on culture, growth.

**Outcome**:  
- All 7 candidates from Round 2 selected.

## Key Takeaways and Preparation Tips

- **Academics**: Maintain CGPA > 9, 80% in 10th/12th to qualify.  
- **DSA**: Solve easy-medium problems on LeetCode, GFG (matrices, linked lists, trees, DP).  
- **OOPS**: Master C++ (references, namespaces), Java (inheritance, polymorphism).  
- **OS/DBMS**: Study processes, threads, virtual memory, scheduling (GFG OS Notes).  
- **Projects**: Prepare 2-3 strong projects, emphasize impact and scalability.  
- **HR Prep**: Use STAR method, highlight ethics, adaptability, and alignment with Morgan Stanley’s values.  
- **Debugging**: Practice quick syntax/logic fixes on HackerRank.  
- **Resources**:  
  - **Coding**: LeetCode, GFG, HackerRank.  
  - **OOPS/OS**: GFG Last Minute Notes, JavaTpoint.  
  - **Aptitude**: RS Aggarwal.  
  - **System Design**: GFG System Design (for context).  
- **Interview Day**: Review resume, rest well, stay confident despite tough feedback (e.g., namespaces).

**Final Note**: Solve problems to build skills, not just memorize, bruh—Morgan Stanley tests your problem-solving grit!