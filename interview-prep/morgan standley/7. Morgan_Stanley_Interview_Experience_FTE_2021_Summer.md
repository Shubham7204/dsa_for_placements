# Morgan Stanley Interview Experience for FTE 2021 Summer (On-Campus)

This document details the **Morgan Stanley Interview Experience for FTE 2021 Summer (On-Campus)** at VJTI, Mumbai, conducted in July 2020, as shared on July 15, 2025. The process included an Online Assessment (OA) on the AMCAT platform and three interview rounds (Technical 1, Technical 2, HR) via Zoom. The candidate solved 12-13/20 aptitude, 5/7 debugging (due to internet issues), all 3 coding questions, and performed well in interviews but chose a Microsoft PPO over Morgan Stanley’s offer. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers for inferred questions.

Let’s get to it, bruh—this is your roadmap to smashing Morgan Stanley’s FTE process!

## Online Assessment (OA)

The OA was on the **AMCAT platform**, lasting ~2 hours, with three sections: Aptitude (20 questions, 20 min), Debugging (7 questions, 20 min), Coding (3 questions, 60 min).

### Section 1: Aptitude

**Problem Statement**:  
- 20 questions, 20 minutes, easy to medium difficulty.
- Topics: Quantitative Aptitude (e.g., probability, time-and-work), Logical Reasoning, Data Interpretation.
- Solved 12-13 questions.

**Approach**:  
- **Preparation**: Practice quants (ratios, percentages), permutations, logical puzzles.  
- **Strategy**:  
  1. Prioritize familiar questions (e.g., basic arithmetic).  
  2. Use elimination for MCQs to save time.  
  3. Read graphs/tables carefully for data interpretation.  
- **Edge Cases**: Tricky wording, misleading options.

**Notes**:  
- Solved 12-13/20; internet issues impacted debugging.  
- Resources: GeeksforGeeks Quantitative Aptitude, RS Aggarwal, AMCAT mocks.  
- Tip: Practice 20-minute MCQ sets, aim for 15/20 in 15 minutes.

### Section 2: Debugging

**Problem Statement**:  
- 7 questions, 20 minutes, easy difficulty.
- Goal: Fix code by correcting syntax, logic, or completing functions.
- Examples: Fix loop bounds, operators, or implement logic.
- Solved 5/7 (internet disconnected for last 2).

**Approach**:  
- **Strategy**:  
  1. Read problem and test cases.  
  2. Fix syntax errors (e.g., missing semicolons).  
  3. Correct logical errors (e.g., off-by-one).  
  4. Implement incomplete functions.  
- **Edge Cases**: Null inputs, boundary values, output format issues.

**Code Snippet (C++ Example)**:  
```cpp
// Example: Fix function to reverse string (incorrect logic)
#include <bits/stdc++.h>
using namespace std;

// Incorrect code (given)
string reverseString(string s) {
    string res = "";
    for (int i = 0; i <= s.length(); i++) {  // Error: <= causes out-of-bounds
        res += s[s.length() - i];
    }
    return res;
}

// Corrected code
string reverseString(string s) {
    string res = "";
    for (int i = 0; i < s.length(); i++) {  // Fix: Use < s.length()
        res += s[s.length() - 1 - i];
    }
    return res;
}
```

**Time Complexity**: O(n) for typical fixes.  
**Space Complexity**: O(1) or O(n).  
**Notes**:  
- Solved 5/7 due to internet issue.  
- Tip: Practice debugging on HackerRank/LeetCode. Test edge cases like empty strings.

### Section 3: Coding Round

Three coding questions (easy to medium), solved all in 45 minutes.

#### Question 1: Fourth Point of Parallelogram

**Problem Statement**:  
Given three points of a parallelogram and which two form a diagonal, find the fourth point.  
- **Example**: Points A(1,1), B(2,2), C(4,2), diagonal AB → Output: D(3,1).  
- **Explanation**: In parallelogram ABCD, AB is diagonal, so A + C = B + D (vector sum).

**Approach**:  
- **Brute Force**: Try all configurations (O(1) but tedious).  
- **Optimal Approach**: Use vector sum property.  
  - Pointwise:  
    1. If AB is diagonal, A + C = B + D → D = A + C - B.  
    2. Compute coordinates: Dx = Ax + Cx - Bx, Dy = Ay + Cy - By.  
    - Edge cases: Collinear points, invalid diagonal.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Point {
    int x, y;
};

Point findFourthPoint(Point A, Point B, Point C, string diagonal) {
    Point D;
    if (diagonal == "AB") {
        D.x = A.x + C.x - B.x;
        D.y = A.y + C.y - B.y;
    } else if (diagonal == "AC") {
        D.x = A.x + B.x - C.x;
        D.y = A.y + B.y - C.y;
    } else {  // BC
        D.x = B.x + C.x - A.x;
        D.y = B.y + C.y - A.y;
    }
    return D;
}
```

**Time Complexity**: O(1).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved; easy geometry problem.  
- Practice vector-based geometry. Test collinear points.

#### Question 2: Max Heights for All Nodes as Root

**Problem Statement**:  
Given a binary tree with nodes < 1000, find max height considering each node as root.  
- **Example**: Input: [1,2,3,4,5] → Output: [3,2,2,1,1] (heights for each node as root).

**Approach**:  
- **Brute Force**: For each node, run DFS to compute height (O(n²)).  
- **Optimal Approach**: Use single DFS with post-order traversal.  
  - Pointwise:  
    1. Compute heights of left/right subtrees.  
    2. For each node, max height = 1 + max(left, right).  
    3. Store heights in array.  
    - Edge cases: Single node, skewed tree.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

void computeHeights(TreeNode* root, vector<int>& heights, int id) {
    if (!root) return;
    int leftHeight = root->left ? heights[root->left->val] : 0;
    int rightHeight = root->right ? heights[root->right->val] : 0;
    heights[id] = 1 + max(leftHeight, rightHeight);
    computeHeights(root->left, heights, root->left ? root->left->val : -1);
    computeHeights(root->right, heights, root->right ? root->right->val : -1);
}

vector<int> maxHeights(TreeNode* root, int n) {
    vector<int> heights(n, 0);
    computeHeights(root, heights, root->val);
    return heights;
}
```

**Time Complexity**:  
- Brute: O(n²).  
- Optimal: O(n) with DFS.  
**Space Complexity**: O(n) for heights array/recursion.  
**Notes**:  
- Solved; brute force sufficed for n < 1000.  
- LeetCode #543 variant. Practice with unbalanced trees.

#### Question 3: Group Strings by Character Set

**Problem Statement**:  
Given a list of strings, group them by their set of characters (ignoring order), sort groups lexicographically, and print each group on separate lines.  
- **Example**: Input: ["cat", "act", "dog", "god"]  
  Output:  
  act cat  
  dog god  

**Approach**:  
- **Brute Force**: Compare each pair’s char sets (O(n²)).  
- **Optimal Approach**: Use hash map with sorted chars as key.  
  - Pointwise:  
    1. For each string, sort its chars to create key.  
    2. Map key to list of strings.  
    3. Sort keys, print each group sorted.  
    - Edge cases: Empty strings, single string, same chars.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

void groupStrings(vector<string>& strs) {
    map<string, vector<string>> groups;
    for (string& s : strs) {
        string key = s;
        sort(key.begin(), key.end());
        groups[key].push_back(s);
    }
    for (auto& group : groups) {
        sort(group.second.begin(), group.second.end());
        for (string& s : group.second) {
            cout << s << " ";
        }
        cout << endl;
    }
}
```

**Time Complexity**: O(n * k * log k) for sorting strings (k = max string length).  
**Space Complexity**: O(n * k) for map.  
**Notes**:  
- Solved; medium difficulty.  
- LeetCode #49 (Group Anagrams). Test with empty strings, duplicates.

**OA Performance**:  
- Solved 12-13/20 aptitude, 5/7 debugging, all 3 coding.  
- Shortlisted for Technical Round 1.

## Technical Round 1

**Duration**: 1 hour, via Zoom.  
**Focus**: DSA, C++, OOPS, coding (COVID-19 contact tracing).

### Question 4: Virtual Functions and Virtual Table in C++

**Problem Statement**:  
- Explain virtual functions and virtual table (vtable) in C++.

**Approach**:  
- **Virtual Functions**:  
  - Enable runtime polymorphism using `virtual` keyword.  
  - Base class pointer calls derived class function.  
- **Vtable**:  
  - Table of function pointers created per class with virtual functions.  
  - Each object stores vptr pointing to vtable.  
  - Resolves function calls dynamically at runtime.  
- **Example**: Base class `Animal` with virtual `speak()`, derived `Dog` overrides it.

**Notes**:  
- Answered clearly.  
- Tip: Study vtable memory layout. Resources: C++ Reference, GFG.

### Question 5: Diamond Problem in C++ and Java

**Problem Statement**:  
- Explain the Diamond Problem in C++ and its solution. Does Java have a similar issue?

**Approach**:  
- **Diamond Problem (C++)**:  
  - Occurs in multiple inheritance when a class inherits same base class via two paths (e.g., D inherits B and C, both inherit A).  
  - Causes ambiguity (e.g., which A’s method to call?).  
  - Solution: Use virtual inheritance (`class B : virtual A`).  
- **Java**:  
  - No Diamond Problem due to single inheritance.  
  - Interfaces (Java 8+) with default methods can cause conflicts, resolved by overriding or specifying (e.g., `SuperInterface.super.method()`).  
- **Example**: C++ virtual inheritance ensures single A instance.

**Code Snippet (C++ Example)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

class A { public: virtual void show() { cout << "A"; } };
class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};

int main() {
    D d;
    d.show();  // No ambiguity with virtual inheritance
    return 0;
}
```

**Notes**:  
- Answered with Java comparison.  
- Tip: Study multiple inheritance vs. interfaces. Resources: GFG, JavaTpoint.

### Question 6: References vs. Pointers

**Problem Statement**:  
- Explain differences between references and pointers, when to use each.

**Approach**:  
- **Differences**:  
  - **References**: Alias to variable, cannot be null, must be initialized, immutable binding.  
  - **Pointers**: Store memory address, can be null, can be reassigned, support arithmetic.  
- **When to Use**:  
  - References: Pass by reference, avoid null checks (e.g., function args).  
  - Pointers: Dynamic memory, nullability, data structures (e.g., linked lists).  
- **Example**: Reference for swap, pointer for linked list.

**Notes**:  
- Answered clearly.  
- Tip: Compare syntax, safety. Resources: GFG C++.

### Question 7: COVID-19 Contact Tracing (Coding)

**Problem Statement**:  
- Design a solution using a contact graph to find people in contact with a given person in the last x days. Code on Notepad, shared screen.

**Approach**:  
- **Graph Representation**:  
  - Nodes: People; Edges: Contacts with timestamps.  
  - Adjacency list for undirected weighted graph.  
- **Solution**: BFS to find all nodes within x days.  
  - Pointwise:  
    1. Start BFS from given person.  
    2. Track visited nodes and timestamps.  
    3. Collect nodes with contact ≤ x days.  
    - Edge cases: No contacts, x=0, disconnected graph.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Edge {
    int person;
    int timestamp;
};

vector<int> findContacts(vector<vector<Edge>>& graph, int person, int x) {
    vector<int> result;
    vector<bool> visited(graph.size(), false);
    queue<int> q;
    q.push(person);
    visited[person] = true;
    while (!q.empty()) {
        int curr = q.front();
        q.pop();
        for (const Edge& e : graph[curr]) {
            if (!visited[e.person] && e.timestamp <= x) {
                visited[e.person] = true;
                q.push(e.person);
                result.push_back(e.person);
            }
        }
    }
    return result;
}
```

**Time Complexity**: O(V + E) for BFS.  
**Space Complexity**: O(V) for queue/visited.  
**Notes**:  
- Coded live on Notepad.  
- Tip: Practice graph traversal, discuss storage (e.g., DB for timestamps). Test disconnected graphs.

**Round 1 Performance**:  
- Answered all questions, selected for Technical Round 2.

## Technical Round 2

**Duration**: 1.5 hours, via Zoom.  
**Focus**: DSA (Binary Matrix, Linked List), Low-Level Design (Chess Game).

### Question 8: Row with Maximum 1s in Binary Matrix

**Problem Statement**:  
Given a row-wise sorted binary matrix, find the row with maximum 1s.  
- **Example**: Input: [[0,1,1], [0,0,1], [1,1,1]] → Output: 2 (row 2 has 3 1s).

**Approach**:  
- **Brute Force**: Count 1s per row (O(n*m)).  
- **Binary Search**: Use sorted property, find first 1 per row (O(n*log m)).  
- **Optimal Approach**: Linear scan from top-right (O(n+m)).  
  - Pointwise:  
    1. Start at top-right (row=0, col=m-1).  
    2. If 1, move left, update max.  
    3. If 0, move down.  
    - Edge cases: All 0s, all 1s, single row/column.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int rowWithMax1s(vector<vector<int>>& matrix) {
    int n = matrix.size(), m = matrix[0].size();
    int maxRow = -1, maxOnes = 0;
    int row = 0, col = m - 1;
    while (row < n && col >= 0) {
        if (matrix[row][col] == 1) {
            int ones = col + 1;
            if (ones > maxOnes) {
                maxOnes = ones;
                maxRow = row;
            }
            col--;
        } else {
            row++;
        }
    }
    return maxRow;
}
```

**Time Complexity**:  
- Brute: O(n*m).  
- Binary Search: O(n*log m).  
- Optimal: O(n+m).  
**Space Complexity**: O(1).  
**Notes**:  
- Gave all three solutions.  
- GFG “Row with max 1s.” Test with empty matrix, single row.

### Question 9: Improve Search Time in Linked List

**Problem Statement**:  
- Improve search time in a linked list, including sqrt(n) distance links.

**Approach**:  
- **Standard Search**: O(n) per search.  
- **Solutions**:  
  1. **Skip List**: Add layers of links at intervals (e.g., every sqrt(n) nodes).  
     - Reduces search to O(sqrt(n)) with extra pointers.  
  2. **Hash Table**: Store node pointers (O(1) average, but O(n) space).  
  3. **Balanced BST**: Convert list to BST (O(log n) search, but O(n) space).  
- **Sqrt(n) Links**:  
  - Add pointers every sqrt(n) nodes.  
  - Search: Jump to nearest skip node, then linear search.  
- **Edge Cases**: Small lists, frequent updates.

**Code Snippet (C++ for Sqrt(n) Links)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int val;
    Node *next, *skip;
    Node(int x) : val(x), next(nullptr), skip(nullptr) {}
};

Node* searchSqrtN(Node* head, int target) {
    Node* curr = head;
    while (curr) {
        if (curr->val == target) return curr;
        if (curr->skip && curr->skip->val <= target) curr = curr->skip;
        else curr = curr->next;
    }
    return nullptr;
}
```

**Time Complexity**: O(sqrt(n)) with skip links.  
**Space Complexity**: O(sqrt(n)) for skip pointers.  
**Notes**:  
- Proposed skip list solution.  
- Tip: Discuss trade-offs (space vs. time). Practice skip list implementation.

### Question 10: Design Chess Game (Low-Level Design)

**Problem Statement**:  
- Design a chess game program, including entities, classes, and abstractions for functionalities.

**Approach**:  
- **Requirement Gathering**:  
  - Players, board (8x8), pieces (pawn, rook, etc.), moves, rules (castling, checkmate).  
- **Entities**:  
  - Board: 8x8 grid, tracks pieces.  
  - Piece: Abstract class (move, validate).  
  - Player: Manages pieces, turn.  
  - Game: Controls flow, validates moves.  
- **Classes (Java)**:  
  - Abstract `Piece` with `move()`, `validateMove()`.  
  - Derived classes: `Pawn`, `Rook`, etc.  
  - `Board`: 2D array, update position.  
  - `Player`: Color, pieces.  
  - `Game`: Manages turns, checks checkmate.  
- **Functionalities**:  
  - `move(from, to)`: Validate and update board.  
  - `isCheckmate()`: Check game state.  
- **Edge Cases**: Invalid moves, stalemate, promotion.

**Code Snippet (Java Example)**:  
```java
abstract class Piece {
    protected int x, y;
    protected String color;
    public Piece(int x, int y, String color) { this.x = x; this.y = y; this.color = color; }
    abstract boolean validateMove(int newX, int newY, Board board);
}

class Pawn extends Piece {
    public Pawn(int x, int y, String color) { super(x, y, color); }
    boolean validateMove(int newX, int newY, Board board) {
        // Implement pawn movement rules
        return true; // Placeholder
    }
}

class Board {
    Piece[][] grid = new Piece[8][8];
    void movePiece(int fromX, int fromY, int toX, int toY) {
        if (grid[fromX][fromY].validateMove(toX, toY, this)) {
            grid[toX][toY] = grid[fromX][fromY];
            grid[fromX][fromY] = null;
        }
    }
}

class Game {
    Board board;
    Player white, black;
    boolean isWhiteTurn;
    void playMove(int fromX, int fromY, int toX, int toY) {
        board.movePiece(fromX, fromY, toX, toY);
    }
}
```

**Notes**:  
- Discussed for 1 hour, covered entities and abstractions.  
- Tip: Practice LLD (e.g., Tic-Tac-Toe, Snake). Clarify requirements, use OOP principles. Resources: GFG System Design.

**Round 2 Performance**:  
- Answered all questions, selected for HR.

## HR Round 3

**Duration**: ~30 minutes, standard HR questions.  
**Note**: Candidate chose Microsoft PPO over Morgan Stanley.

### Question 11: Why Morgan Stanley?

**Problem Statement**:  
- Why do you want to work at Morgan Stanley?

**Sample Answer**:  
- **Situation**: "I’m passionate about building robust financial systems."  
- **Task**: "I want to contribute to Morgan Stanley’s innovative platforms."  
- **Action**: "I’ve honed skills in C++, Java, and system design through projects like a chess game, aligning with Morgan Stanley’s tech stack."  
- **Result**: "I’m eager to grow as an engineer and deliver impactful solutions at Morgan Stanley."

**Notes**:  
- Align with company values (innovation, excellence).  
- Tip: Research Morgan Stanley’s tech initiatives.

### Question 12: Teamwork Experience

**Problem Statement**:  
- Describe a time you worked in a team.

**Sample Answer**:  
- **Situation**: "In a hackathon, my team built a real-time chat app."  
- **Task**: "As backend lead, I ensured API integration."  
- **Action**: "I coordinated with frontend developers, debugged APIs, and held daily syncs to align tasks."  
- **Result**: "We delivered a functional app, winning second place."

**Notes**:  
- Use STAR method, emphasize collaboration.  
- Tip: Prepare 2-3 teamwork stories.

### Question 13: Handling Pressure

**Problem Statement**:  
- Describe a situation where you handled pressure.

**Sample Answer**:  
- **Situation**: "During a coding contest, I had 1 hour to solve a graph problem."  
- **Task**: "I needed to optimize a solution to pass all test cases."  
- **Action**: "I broke the problem into steps, implemented BFS, and tested edge cases under time constraints."  
- **Result**: "My solution passed, ranking me in the top 10%."

**Notes**:  
- Show problem-solving under stress.  
- Tip: Highlight technical skills in story.

**Outcome**:  
- Selected but chose Microsoft PPO.

## Key Takeaways and Preparation Tips

- **Practice DSA**: Solve medium-hard problems on LeetCode, InterviewBit, GFG (arrays, trees, graphs, DP).  
- **OOPS and C++**: Master virtual functions, vtables, inheritance, pointers vs. references. Use Java for OOPS clarity.  
- **System Design**: Practice LLD (e.g., chess, booking systems). Focus on entities, abstractions, OOP principles.  
- **Aptitude/Debugging**: Practice AMCAT mocks, debugging on HackerRank.  
- **HR Prep**: Use STAR method for behavioral questions. Research Morgan Stanley’s values (integrity, innovation).  
- **Communication**: Think aloud, clarify requirements, discuss trade-offs.  
- **Edge Cases**: Test code for empty inputs, boundaries, extremes.  
- **Resources**:  
  - **Coding**: LeetCode, GFG, InterviewBit.  
  - **OOPS**: GFG, JavaTpoint.  
  - **System Design**: Gaurav Sen, GFG.  
  - **Aptitude**: RS Aggarwal, AMCAT mocks.  
- **Interview Day**: Review resume, rest well, align answers with Morgan Stanley’s focus.