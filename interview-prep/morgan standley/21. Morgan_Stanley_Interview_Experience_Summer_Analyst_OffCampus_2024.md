# Morgan Stanley Interview Experience | Summer Analyst 2024 (Off-Campus)

This document details the **Morgan Stanley Interview Experience for Summer Analyst (Off-Campus)**, conducted from October 2023 to February 2024 for a summer 2024 internship. The candidate applied via the Morgan Stanley career portal without a referral, was shortlisted after an online assessment, cleared two interview rounds, and was selected. The process included an Online Assessment (Debugging, Aptitude, Coding), a Technical Interview (SQL, C, DSA), and an HR Round (Projects, Behavioral). All coding questions are implemented in **C++**, OOPS-related in **Java**, SQL for database queries, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers.

Yo, bruh—this is your ultimate cheat sheet to slay Morgan Stanley’s Summer Analyst role! Let’s dive in, nail it, and make it *perfect*!

## Application Process

- **How to Apply**:  
  - Applied in October 2023 via Morgan Stanley’s career portal ([careers.morganstanley.com](https://www.morganstanley.com/people/students-and-graduates)).  
  - Uploaded resume highlighting projects, DSA skills, and achievements.  
  - No referral, merit-based selection.  
- **Tip**:  
  - Build a strong resume: emphasize coding projects, internships, and competitive programming.  
  - Use GFG’s Ultimate Resume Building Guide.  
- **Outcome**: Shortlisted for Online Assessment, received mail on February 12, 2024.

## Round 1: Online Assessment

**Platform**: SHL Aspiring Minds (AMCAT), 80 minutes, conducted on February 15, 2024.  
**Details**: 3 sections, individually timed.  
- **Debugging**: 7 questions, 20 minutes, easy.  
- **Aptitude**: 10 MCQs, 20 minutes, easy to moderate.  
- **Coding**: 3 questions, 60 minutes, LeetCode easy-medium (Merging Intervals, Level Order Traversal, one unspecified).  
- **Outcome**: Solved all debugging, aptitude, and coding questions, shortlisted for Round 2.

### Section 1: Debugging

**Problem Statement**:  
- Fix 7 code snippets by identifying syntax/logic errors.  
- Language: C++ chosen.  
- Time: 20 minutes, all solved.

**Approach**:  
- **Strategy**:  
  1. Check syntax errors (e.g., missing semicolons, incorrect operators).  
  2. Fix logical errors (e.g., wrong loop conditions, off-by-one).  
  3. Validate with edge cases mentally.  
- **Edge Cases**: Null inputs, uninitialized variables, boundary conditions.

**Notes**:  
- Easy section, solved all questions.  
- Resources: GFG Debugging, HackerRank practice.  
- Tip: Practice 5-minute debug sprints, aim for 100% accuracy.

### Section 2: Aptitude

**Problem Statement**:  
- 10 MCQs on Logical Reasoning, Data Interpretation, Numerical Ability.  
- Time: 20 minutes, easy to moderate.

**Approach**:  
- **Strategy**:  
  1. Prioritize easy questions (e.g., basic math, patterns).  
  2. Use elimination for moderate ones.  
  3. Manage time (~2 minutes/question).  
- **Edge Cases**: Tricky wording, time traps.

**Notes**:  
- Solved most questions, time management key.  
- Resources: RS Aggarwal, GFG Aptitude.  
- Tip: Practice 10 questions in 15 minutes, aim for 8–10 correct.

### Section 3: Coding

**Problem Statement**:  
- 3 LeetCode easy-medium questions, 60 minutes, C++ chosen.  
- Known problems:  
  1. Merging Intervals ([GFG](https://www.geeksforgeeks.org/dsa/merging-intervals/)).  
  2. Level Order Traversal ([GFG](https://www.geeksforgeeks.org/dsa/level-order-tree-traversal/)).  
  3. Unspecified (assumed medium array/string problem).  
- All solved.

#### Problem 1: Merging Intervals

**Problem Statement**:  
- Given a collection of intervals, merge overlapping intervals.  
- **Example**: Input: [[1,3],[2,6],[8,10],[15,18]] → Output: [[1,6],[8,10],[15,18]].  
- **Link**: [LeetCode #56](https://leetcode.com/problems/merge-intervals/).

**Approach**:  
- **Brute Force**: Check each interval against others (O(n^2)).  
- **Optimal Approach**: Sort and merge.  
  - Pointwise:  
    1. Sort intervals by start time.  
    2. Iterate, merge if current interval overlaps with previous.  
    3. Add non-overlapping intervals to result.  
  - Edge cases: Empty input, single interval, all overlapping.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<vector<int>> merge(vector<vector<int>>& intervals) {
    if (intervals.empty()) return {};
    sort(intervals.begin(), intervals.end());
    vector<vector<int>> result;
    result.push_back(intervals[0]);
    for (int i = 1; i < intervals.size(); i++) {
        if (result.back()[1] >= intervals[i][0]) {
            result.back()[1] = max(result.back()[1], intervals[i][1]);
        } else {
            result.push_back(intervals[i]);
        }
    }
    return result;
}

void solve() {
    int n;
    cin >> n;
    vector<vector<int>> intervals(n, vector<int>(2));
    for (int i = 0; i < n; i++) cin >> intervals[i][0] >> intervals[i][1];
    vector<vector<int>> result = merge(intervals);
    for (auto& interval : result) cout << interval[0] << " " << interval[1] << endl;
}
```

**Time Complexity**: O(n log n).  
**Space Complexity**: O(n) (output space).  
**Notes**:  
- Solved efficiently, tested with overlapping cases.  
- Test [[1,4],[4,5]], [].  
- Tip: Practice LeetCode #56, focus on sorting logic.

#### Problem 2: Level Order Traversal

**Problem Statement**:  
- Given a binary tree, return the level-order traversal of its nodes’ values.  
- **Example**: Input: [1,2,3] → Output: [[1],[2,3]].  
- **Link**: [LeetCode #102](https://leetcode.com/problems/binary-tree-level-order-traversal/).

**Approach**:  
- **Brute Force**: Recursive level tracking (O(n)).  
- **Optimal Approach**: BFS with queue.  
  - Pointwise:  
    1. Use queue to process nodes level by level.  
    2. For each level, collect node values.  
    3. Add to result vector.  
  - Edge cases: Empty tree, single node.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        vector<int> level;
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front();
            q.pop();
            level.push_back(node->val);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        result.push_back(level);
    }
    return result;
}

void solve() {
    // Input tree (simplified for example)
    vector<vector<int>> result = levelOrder(/* root */);
    for (auto& level : result) {
        for (int val : level) cout << val << " ";
        cout << endl;
    }
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(w) (queue, w = max width).  
**Notes**:  
- Solved using BFS, efficient.  
- Test [1], [1,2,3].  
- Tip: Practice LeetCode #102, master queue-based traversal.

#### Problem 3: Unspecified Medium DSA

**Problem Statement**:  
- Medium-level DSA problem (assumed array/string, e.g., Two Sum).  
- **Example**: Input: [2,7,11,15], target=9 → Output: [0,1].  
- **Link**: [LeetCode #1](https://leetcode.com/problems/two-sum/).

**Approach**:  
- **Brute Force**: Check all pairs (O(n^2)).  
- **Optimal Approach**: Hash map.  
  - Pointwise:  
    1. Store number-to-index in hash map.  
    2. For each number, check if target-number exists.  
    3. Return indices if found.  
  - Edge cases: No solution, duplicate numbers.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> mp;
    for (int i = 0; i < nums.size(); i++) {
        if (mp.find(target - nums[i]) != mp.end()) {
            return {mp[target - nums[i]], i};
        }
        mp[nums[i]] = i;
    }
    return {};
}

void solve() {
    int n, target;
    cin >> n >> target;
    vector<int> nums(n);
    for (int i = 0; i < n; i++) cin >> nums[i];
    vector<int> result = twoSum(nums, target);
    for (int x : result) cout << x << " ";
    cout << endl;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(n).  
**Notes**:  
- Solved assumed problem, aligns with medium difficulty.  
- Test [2,7,11], target=9.  
- Tip: Practice LeetCode #1, be ready for array problems.

## Round 2: Technical Interview

**Duration**: ~60+ minutes, Zoom, February 20, 2024.  
**Details**: Introduction, SQL queries (9–10), C memory question, call by value vs. reference, medium DSA (pseudo-code), conducted by two friendly interviewers.  
**Outcome**: Positive response, HR round scheduled next day.

### Question 4: SQL Queries

**Problem Statement**:  
- Write 9–10 SQL queries (e.g., joins, aggregations, subqueries).  
- **Example**:  
  - Select employees with salary > 50000 from two tables.  
  - Find top 3 departments by average salary.

**Approach**:  
- **Strategy**:  
  1. Clarify table schema (e.g., columns, relationships).  
  2. Write precise SQL with correct syntax.  
  3. Handle edge cases (e.g., nulls, empty tables).  
- **Sample Query (SQL)**:  
```sql
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id
WHERE e.salary > 50000;
```
- **Edge Cases**: Null values, missing joins, no results.

**Notes**:  
- Solved almost all queries correctly.  
- Resources: LeetCode SQL, GFG SQL.  
- Tip: Practice joins, group by, subqueries (LeetCode #185, #601).

### Question 5: C Memory Question

**Problem Statement**:  
- Given:  
```c
void func() {
    int arr[10];
}
```
- Called recursively infinite times with 2MB memory. Will it crash, run indefinitely, or error?

**Approach**:  
- **Answer**:  
  - **Stack Overflow**: Each call allocates `arr[10]` (40 bytes for int=4 bytes).  
  - **Memory**: 2MB = 2*10^6 bytes, ~50,000 calls possible (2*10^6 / 40).  
  - **Outcome**: Crashes due to stack overflow after ~50,000 calls.  
- **Edge Cases**: Compiler optimizations, stack size variations.

**Notes**:  
- Answered correctly, interviewer satisfied.  
- Tip: Study stack vs. heap (GFG C), test recursion limits.

### Question 6: Call by Value vs. Call by Reference

**Problem Statement**:  
- Explain difference between call by value and call by reference with an example.

**Approach**:  
- **Answer**:  
  - **Call by Value**: Copies value, changes don’t affect original.  
  - **Call by Reference**: Passes memory address, changes affect original.  
- **Example (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

void byValue(int x) { x = 100; }
void byReference(int& x) { x = 100; }

int main() {
    int a = 10, b = 10;
    byValue(a);
    byReference(b);
    cout << a << " " << b << endl; // Output: 10 100
    return 0;
}
```

**Notes**:  
- Explained with example, clear understanding.  
- Tip: Study GFG C++ pointers, practice examples.

### Question 7: Medium DSA Question

**Problem Statement**:  
- Medium-level DSA question (unspecified, assumed array/string, e.g., Group Anagrams).  
- **Example**: Input: ["eat","tea","tan","ate","nat","bat"] → Output: [["eat","tea","ate"],["tan","nat"],["bat"]].  
- **Link**: [LeetCode #49](https://leetcode.com/problems/group-anagrams/).

**Approach**:  
- **Brute Force**: Compare each pair (O(n*k*log k)).  
- **Optimal Approach**: Hash map with sorted string as key.  
  - Pointwise:  
    1. Sort each string, use as key in hash map.  
    2. Group strings with same key.  
    3. Return grouped result.  
  - Edge cases: Empty input, single string.

**Pseudo-Code (C++)**:  
```cpp
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> mp;
    for (string s : strs) {
        string key = s;
        sort(key.begin(), key.end());
        mp[key].push_back(s);
    }
    vector<vector<string>> result;
    for (auto& p : mp) result.push_back(p.second);
    return result;
}
```

**Time Complexity**: O(n*k*log k) (k = max string length).  
**Space Complexity**: O(n*k).  
**Notes**:  
- Provided logic, wrote pseudo-code, interviewer happy.  
- Test ["eat","tea"], [].  
- Tip: Practice LeetCode #49, be ready for pseudo-code.

## Round 3: HR Round

**Duration**: ~30 minutes, Zoom, February 22, 2024.  
**Details**: Project discussion (MongoDB vs. SQL), behavioral questions (aspirations, career goals).  
**Outcome**: Selected after 3 weeks (mid-March 2024).

### Question 8: Project Discussion (MongoDB vs. SQL)

**Problem Statement**:  
- Why used MongoDB over SQL in your project?

**Approach**:  
- **Answer**:  
  - **MongoDB**: NoSQL, schema-less, ideal for unstructured data, horizontal scaling.  
  - **SQL**: Structured, relational, better for complex queries, transactions.  
  - **Choice**: Used MongoDB for flexible schema, faster prototyping.  
- **Example (Java - MongoDB)**:  
```java
import com.mongodb.client.MongoClient;
import com.mongodb.client.MongoClients;
import com.mongodb.client.MongoDatabase;

public class MongoExample {
    public static void main(String[] args) {
        MongoClient client = MongoClients.create("mongodb://localhost:27017");
        MongoDatabase db = client.getDatabase("myDB");
        // Flexible schema operations
    }
}
```

**Notes**:  
- Justified choice with project context.  
- Tip: Know project tech stack, compare DBs (GFG MongoDB vs. SQL).

### Question 9: Behavioral Questions

**Problem Statement**:  
- What are your aspirations and career goals?

**Sample Answer (STAR)**:  
- **Situation**: “Final-year student aiming for tech-finance.”  
- **Task**: “Build a career in innovative tech solutions.”  
- **Action**: “Mastered DSA, built finance-related projects, interned at startups.”  
- **Result**: “Prepared to contribute to Morgan Stanley’s trading platforms.”  

**Notes**:  
- Aligned with company values, showed ambition.  
- Tip: Use STAR, research Morgan Stanley’s core values (careers.morganstanley.com).

## Key Takeaways and Preparation Tips

- **Application**:  
  - Strong resume critical, highlight DSA/projects (GFG Resume Guide).  
  - Apply early via career portal, no referral needed.  
- **Online Assessment**:  
  - **Debugging**: Solve all, practice quick fixes (GFG Debugging).  
  - **Aptitude**: Speed over perfection (RS Aggarwal).  
  - **Coding**: Solve all, practice LeetCode easy-medium (#56, #102, #1).  
- **Technical Interview**:  
  - Master SQL (LeetCode #185), C++ memory (GFG C), DSA (LeetCode #49).  
  - Be ready for pseudo-code, explain logic clearly.  
- **HR Round**:  
  - Use STAR for behavioral questions, justify project choices.  
  - Research Morgan Stanley’s tech-finance focus.  
- **Resources**:  
  - **Coding**: LeetCode, GFG, Striver’s SDE Sheet.  
  - **SQL**: LeetCode SQL, GFG SQL.  
  - **OOPS/C**: GFG C++, StudyTonight.  
  - **DB**: GFG MongoDB vs. SQL.  
  - **HR**: JavaTpoint, Glassdoor.  
- **Interview Day**: Stay calm, explain thought process, ask about team projects.  
- **General**: Morgan Stanley values technical depth, communication, and resilience. Be patient, believe in yourself.

**Final Note**: Code hard, vibe smart, and own that Summer Analyst role, bruh—Morgan Stanley’s waiting for your fire! Stay patient and keep the faith! 😎