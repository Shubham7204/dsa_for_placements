# Morgan Stanley Interview Experience | Set 32 (On-Campus) 2019

This document details the **Morgan Stanley Interview Experience for FTE (On-Campus)**, shared on July 25, 2019. Conducted in 2018, the process included an Aptitude Test on HackerRank (MCQs and coding), followed by four interview rounds: Technical Interview 1, Group Activity, Technical Interview 2 (System Design), Technical + HR, and a re-interview for system design. The candidate performed well in MCQs and coding, excelled in interviews, with 10/unknown shortlisted after Technical Interview 1, and was selected after a re-interview. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers for behavioral questions.

Let’s dive in, bruh—this is your roadmap to crushing Morgan Stanley’s intense interview gauntlet!

## Aptitude Test

The Aptitude Test was conducted on **HackerRank**, lasting 90 minutes, with 14 MCQs (7 Aptitude, 7 Technical) and 2 coding questions.

### Section 1: MCQs

**Problem Statement**:  
- **Aptitude (7 questions)**: Math and logic-based (e.g., probability, combinatorics).  
- **Technical (7 questions)**: Data Structures (hashing, BST, graphs, recursion), OS (page faults).  
- **Questions**:  
  1. Hashing (Linear Probing): Collision resolution.  
  2. Counting Page Faults: Given page references, calculate faults.  
  3. BST Preorder and Postorder: Identify or validate traversals.  
  4. Graph Minimum Distance: Shortest path in a graph.  
  5. Recursion: Given `f(int a)`, find `f(8)`.  
  6. Inorder Successor in BST: Find next node in inorder traversal.  
  7. (One more DS/OS question, unspecified).

**Approach**:  
- **Aptitude**:  
  - Solve arithmetic/probability first, use elimination for puzzles.  
  - Example: Probability requires careful numerator/denominator calculation.  
- **Technical**:  
  - **Hashing**: Understand linear probing (O(1) average, O(n) worst).  
  - **Page Faults**: Simulate LRU/FIFO for page references.  
  - **BST Traversals**: Validate preorder/postorder properties.  
  - **Graph**: Use Dijkstra’s for shortest path.  
  - **Recursion**: Trace recursive calls for `f(8)`.  
  - **Inorder Successor**: Use BST properties (right subtree or parent).  
- **Edge Cases**: Ambiguous options, edge cases in traversals, disconnected graphs.

**Notes**:  
- Solved most MCQs.  
- Resources: GFG (Hashing, BST, Graphs, OS), RS Aggarwal (Aptitude).  
- Tip: Practice 15-minute MCQ mocks, aim for 12/14 accuracy.

### Section 2: Coding Questions

Two coding questions, solved with modulo for large outputs.

#### Question 1: String Manipulation (Unique Strings)

**Problem Statement**:  
Given two strings A and B of same length, replace substring A[i:j] with B[i:j] (same indices). Find count of unique strings possible, modulo 10^9+7. Substring can be empty.  
- **Example**:  
  - Input: A="aaa", B="aaa" → Output: 1 (only "aaa").  
  - Input: A="abc", B="xyz" → Output: 8 (abc, xyz, ayz, xbc, ayc, xbz, abz, xyc).  
- **Constraints**: Length ≤ 10^5.

**Approach**:  
- **Brute Force**: Try all substring replacements (O(2^n)).  
- **Optimal Approach**: Dynamic Programming.  
  - Pointwise:  
    1. For each index i, decide to keep A[i] or replace with B[i].  
    2. Use set to track unique strings or count combinations.  
    3. For each prefix, compute unique suffixes.  
    - Edge cases: Empty substring, identical strings.  
- **Formula**: If A[i] ≠ B[i], each position doubles choices (2^n); else, no new strings.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 1000000007;

long long countUniqueStrings(string A, string B) {
    int n = A.size();
    long long result = 1;
    for (int i = 0; i < n; i++) {
        if (A[i] != B[i]) {
            result = (result * 2) % MOD;
        }
    }
    return result;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved; key insight is binary choice per differing character.  
- GFG “String Manipulation.” Test identical strings, single char.

#### Question 2: Largest Square Submatrix with At Most K Red Cells

**Problem Statement**:  
Given an N×N matrix of 0s (blue) and 1s (red), find the side length of the largest square submatrix with at most K red cells.  
- **Example**: Input: N=3, K=2, Matrix=[[1,1,1],[1,0,1],[1,1,0]] → Output: 2 (submatrix at (1,1) to (2,2) has 2 red cells).  
- **Constraints**: N ≤ 500, K ≤ N².

**Approach**:  
- **Brute Force**: Check all submatrices (O(N^4)).  
- **Optimal Approach**: Prefix Sum + Binary Search.  
  - Pointwise:  
    1. Compute 2D prefix sum for red cells count.  
    2. For each possible square size (1 to N), check if any submatrix has ≤ K red cells using prefix sum.  
    3. Binary search on square size for efficiency.  
    - Edge cases: K=0, all 1s, N=1.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int largestSquare(vector<vector<int>>& A, int K) {
    int N = A.size();
    vector<vector<int>> prefix(N+1, vector<int>(N+1, 0));
    // Compute prefix sum
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            prefix[i][j] = A[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1];
        }
    }
    // Binary search on square size
    int left = 1, right = N, result = 0;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        bool found = false;
        for (int i = mid; i <= N; i++) {
            for (int j = mid; j <= N; j++) {
                int red = prefix[i][j] - prefix[i-mid][j] - prefix[i][j-mid] + prefix[i-mid][j-mid];
                if (red <= K) {
                    found = true;
                    break;
                }
            }
            if (found) break;
        }
        if (found) {
            result = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}
```

**Time Complexity**: O(N² log N).  
**Space Complexity**: O(N²) for prefix sum.  
**Notes**:  
- Solved with prefix sum and binary search.  
- GFG “Maximum Size Square Sub-matrix.” Test K=0, all 1s.

**Aptitude Test Performance**:  
- Solved most MCQs, both coding questions.  
- 10 candidates shortlisted for Technical Interview 1.

## Technical Interview 1

**Duration**: ~45 minutes, via onsite.  
**Interviewer**: Focused on Java, Data Structures, OS, DBMS.

### Question 1: Java - Abstract vs. Interface

**Problem Statement**:  
- Explain difference between abstract class and interface. Should “Animal” be abstract or interface? Why were interfaces introduced? Deep questions on abstract vs. interface. Polymorphic reference in Java.

**Approach**:  
- **Abstract vs. Interface**:  
  - **Abstract Class**: Partial implementation, single inheritance, instance variables, constructors.  
  - **Interface**: Fully abstract, multiple inheritance, only constants, method signatures (pre-Java 8).  
- **Animal**:  
  - **Interface** if defining behaviors (e.g., `move()`, `eat()`).  
  - **Abstract Class** if partial implementation needed (e.g., common `age` attribute).  
- **Why Interfaces**: Enable multiple inheritance, loose coupling, contract-based programming.  
- **Polymorphic Reference**: Reference of parent type (class/interface) holds child object, resolved at runtime.  
- **Example**: `Animal a = new Dog(); a.move();` calls Dog’s `move()`.

**Code Snippet (Java Example)**:  
```java
interface Animal {
    void move();
}

abstract class AbstractAnimal {
    int age;
    abstract void eat();
}

class Dog implements Animal {
    public void move() { System.out.println("Dog runs"); }
}

class Main {
    public static void main(String[] args) {
        Animal a = new Dog(); // Polymorphic reference
        a.move(); // Dog runs
    }
}
```

**Notes**:  
- Answered thoroughly, discussed trade-offs.  
- Tip: Study Java OOPS (GFG, JavaTpoint). Prepare examples.

### Question 2: Recursive Palindrome Check

**Problem Statement**:  
- Write recursive code to check if a string is a palindrome.

**Approach**:  
- **Base Case**: Empty or single-char string is palindrome.  
- **Recursive Case**: Compare first/last chars, recurse on substring.  
- **Edge Cases**: Empty string, case sensitivity.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

bool isPalindrome(string s, int start, int end) {
    if (start >= end) return true;
    if (s[start] != s[end]) return false;
    return isPalindrome(s, start + 1, end - 1);
}

bool checkPalindrome(string s) {
    return isPalindrome(s, 0, s.size() - 1);
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(n) for recursion stack.  
**Notes**:  
- Solved recursively.  
- LeetCode #125 variant. Test empty, single char.

### Question 3: Palindrome Using Stack and Queue

**Problem Statement**:  
- Check if a string is a palindrome using a stack and queue.

**Approach**:  
- Push all chars to stack (LIFO) and queue (FIFO).  
- Pop from stack, dequeue from queue, compare.  
- **Edge Cases**: Empty string, odd/even length.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

bool isPalindrome(string s) {
    stack<char> st;
    queue<char> q;
    for (char c : s) {
        st.push(c);
        q.push(c);
    }
    while (!st.empty()) {
        if (st.top() != q.front()) return false;
        st.pop();
        q.pop();
    }
    return true;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(n) for stack and queue.  
**Notes**:  
- Solved with stack and queue.  
- GFG “Palindrome Check.” Test odd-length strings.

### Question 4: Pair Sum in Array

**Problem Statement**:  
- Given an array and sum, find if a pair exists with the given sum.  
- **Example**: Input: [1,4,3,2], sum=7 → Output: True (4+3).

**Approach**:  
- **Brute Force**: Check all pairs (O(n²)).  
- **Optimal Approach**: Use HashMap.  
  - Pointwise:  
    1. Store elements in HashMap.  
    2. For each element x, check if sum-x exists.  
    - Edge cases: Empty array, duplicates.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

bool hasPairSum(vector<int>& arr, int sum) {
    unordered_set<int> seen;
    for (int x : arr) {
        if (seen.count(sum - x)) return true;
        seen.insert(x);
    }
    return false;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(n).  
**Notes**:  
- Used HashMap, discussed complexity.  
- LeetCode #1. Test duplicates, negative numbers.

### Question 5: Triplet Sum in Array

**Problem Statement**:  
- Given an array and sum, find if a triplet exists with the given sum.  
- **Example**: Input: [1,4,3,2], sum=12 → Output: True (4+3+5 if 5 exists).

**Approach**:  
- **Brute Force**: Check all triplets (O(n³)).  
- **Optimal Approach**: Two-pointer after sorting.  
  - Pointwise:  
    1. Sort array.  
    2. For each i, find pair with sum-arr[i] using two pointers.  
    - Edge cases: Duplicates, no triplet.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

bool hasTripletSum(vector<int>& arr, int sum) {
    sort(arr.begin(), arr.end());
    int n = arr.size();
    for (int i = 0; i < n-2; i++) {
        int target = sum - arr[i];
        int left = i + 1, right = n - 1;
        while (left < right) {
            int curr = arr[left] + arr[right];
            if (curr == target) return true;
            if (curr < target) left++;
            else right--;
        }
    }
    return false;
}
```

**Time Complexity**: O(n²).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved with two-pointer.  
- LeetCode #15 variant. Test duplicates.

### Question 6: OS - Scheduling Animation and Movie

**Problem Statement**:  
- Schedule an animation and movie to run simultaneously on a TV. Discuss scheduling algorithms.

**Approach**:  
- **Requirements**: Animation (light, continuous), movie (heavy, sequential).  
- **Scheduling Algorithms**:  
  - **Round Robin**: Fair time slices, good for animation responsiveness.  
  - **Priority Scheduling**: Prioritize movie for smooth playback, animation lower priority.  
  - **Multilevel Queue**: Separate queues for animation (interactive) and movie (batch).  
- **Implementation**: Use OS scheduler, assign time quanta, context switch.  
- **Edge Cases**: Resource contention, high CPU load.

**Notes**:  
- Discussed multiple algorithms.  
- Tip: Study OS scheduling (GFG OS Notes).

### Question 7: DBMS - Third Highest Salary

**Problem Statement**:  
- Find the tuple with the third highest salary in a table.  
- **Example**: Table: Employee(id, salary) → Return employee with third highest salary.

**Approach**:  
- **Using LIMIT/OFFSET**: `SELECT * FROM Employee ORDER BY salary DESC LIMIT 1 OFFSET 2;`  
- **Using Subquery**:  
  - Find distinct salaries, order by salary, pick third.  
- **Edge Cases**: Fewer than 3 salaries, ties.

**Code Snippet (SQL)**:  
```sql
SELECT *
FROM Employee
WHERE salary = (
    SELECT DISTINCT salary
    FROM Employee
    ORDER BY salary DESC
    LIMIT 1 OFFSET 2
);
```

**Notes**:  
- Solved with subquery, discussed alternatives.  
- GFG “Nth Highest Salary.” Test ties, small tables.

**Technical Interview 1 Performance**:  
- Answered OOPS, DSA, OS, DBMS questions well.  
- 10 candidates shortlisted for Group Activity.

## Group Activity

**Duration**: ~35 minutes, non-elimination, 10 candidates.  
**Task**: Build a product (solar panel house) using Lego blocks in 30 minutes, pitch to investors in 5 minutes, including features, logo, company name.

**Approach**:  
- **Product**: Solar panel house.  
  - **Features**: Eco-friendly energy, smart home integration, modular design.  
  - **Logo**: Lego-based sun and house symbol.  
  - **Company Name**: “GreenTech Innovations.”  
- **Strategy**:  
  1. Assign roles (builder, presenter, designer).  
  2. Build functional model with Lego blocks.  
  3. Pitch: Highlight sustainability, market potential.  
- **Edge Cases**: Time constraints, investor objections.

**Notes**:  
- Emphasized teamwork, creativity.  
- Tip: Practice pitching, group coordination. Be confident in presentation.

## Technical Interview 2 (System Design)

**Duration**: ~45 minutes, non-elimination.  
**Interviewer**: Focused on system design.

### Question 8: Ticket Booking Portal

**Problem Statement**:  
- Design a ticket booking portal for airplanes using APIs from airlines (e.g., JET Airways, Indigo). Confirm availability and book tickets. Include database, class diagrams, system flow.

**Approach**:  
- **Requirements**:  
  - Search flights, check availability, book tickets, user accounts.  
  - Scalability for high traffic, real-time updates.  
- **Architecture**:  
  - **Frontend**: React for UI, Tailwind CSS for styling.  
  - **Backend**: NodeJS with Express, REST APIs to interface with airline APIs.  
  - **Database**: MySQL for users/bookings, Redis for caching availability.  
  - **External APIs**: Query JET/Indigo APIs for flight data.  
- **Class Diagram (Java)**:  
  - `User`: ID, name, bookings.  
  - `Flight`: ID, airline, seats, schedule.  
  - `Booking`: UserID, FlightID, status.  
- **System Flow**:  
  1. User searches flights → Query Redis, then airline APIs.  
  2. Display availability → Cache results.  
  3. Book ticket → Lock seat, confirm via API, update DB.  
- **Scalability**: Load balancers, microservices, Redis caching.  
- **Edge Cases**: Concurrent bookings, API failures, seat conflicts.

**Code Snippet (Java - Sample Booking Service)**:  
```java
class Flight {
    String id, airline;
    int seats;
    public Flight(String id, String airline, int seats) {
        this.id = id; this.airline = airline; this.seats = seats;
    }
}

class BookingService {
    Map<String, Flight> flights;
    Map<String, String> bookings; // UserID -> FlightID
    public BookingService() {
        flights = new HashMap<>();
        bookings = new HashMap<>();
    }
    boolean checkAvailability(String flightID) {
        // Query airline API (mocked)
        return flights.get(flightID).seats > 0;
    }
    boolean bookTicket(String userID, String flightID) {
        if (checkAvailability(flightID)) {
            flights.get(flightID).seats--;
            bookings.put(userID, flightID);
            return true;
        }
        return false;
    }
}
```

**Notes**:  
- Designed DB, classes, flow; addressed concurrency.  
- Tip: Practice system design (GFG System Design, System Design Primer). Focus on API integration, locking.

## Technical + HR Round

**Duration**: ~45 minutes, non-elimination, senior interviewer.  
**Focus**: Internship, group work, HR, coding experience.

### Question 9: Internship Experience

**Problem Statement**:  
- Discuss your internship experience.

**Sample Answer**:  
- **Situation**: "Interned at a tech startup building a real-time dashboard."  
- **Task**: "Developed scalable APIs using NodeJS."  
- **Action**: "Optimized queries with MySQL, implemented caching with Redis."  
- **Result**: "Improved response time by 40%, learned scalable system design."

**Notes**:  
- Highlighted technical impact.  
- Tip: Prepare 1-2 internship stories, tie to Morgan Stanley’s tech stack.

### Question 10: Group Work Experience

**Problem Statement**:  
- Share experience working in groups.

**Sample Answer**:  
- **Situation**: "Led a team in a college hackathon."  
- **Task**: "Built a web app under tight deadlines."  
- **Action**: "Assigned roles, coordinated via Agile, resolved conflicts."  
- **Result**: "Won first place, learned effective collaboration."

**Notes**:  
- Emphasized teamwork.  
- Tip: Use STAR method, highlight leadership.

### Question 11: Coding Experience

**Problem Statement**:  
- Discuss your coding experience.

**Sample Answer**:  
- **Situation**: "Coded in C++, Java, Python for projects and contests."  
- **Task**: "Solved DSA problems, built web apps."  
- **Action**: "Competed on HackerRank, built a booking system in Java."  
- **Result**: "Improved problem-solving, ranked top 10% in contests."

**Notes**:  
- Showed versatility.  
- Tip: Highlight competitive programming, projects.

### Question 12: Idol and Why

**Problem Statement**:  
- Who is your idol and why?

**Sample Answer**:  
- **Situation**: "I admire Elon Musk for his innovation."  
- **Task**: "I aspire to solve complex problems like him."  
- **Action**: "Inspired by Tesla’s tech, I built an IoT project."  
- **Result**: "Learned to think big and innovate, aligning with Morgan Stanley’s vision."

**Notes**:  
- Chose relevant idol.  
- Tip: Pick someone tied to tech/finance, use STAR.

### Question 13: Why Morgan Stanley?

**Problem Statement**:  
- Why do you want to work at Morgan Stanley?

**Sample Answer**:  
- **Situation**: "I’m passionate about financial tech."  
- **Task**: "I want to build scalable systems at Morgan Stanley."  
- **Action**: "My experience in Java and system design aligns with your trading platforms."  
- **Result**: "I’m excited to contribute to Morgan Stanley’s innovation."

**Notes**:  
- Tied skills to company.  
- Tip: Research Morgan Stanley’s tech stack, be genuine.

## Re-interview (System Design)

**Duration**: ~30 minutes, focused on system design and OOPS.  
**Interviewer**: Re-evaluated system design skills.

### Question 14: Design Uber

**Problem Statement**:  
- Design Uber, including database structure and OOP model.  
- Discuss compile-time polymorphism.

**Approach**:  
- **Requirements**:  
  - Features: User ride booking, driver matching, payment, tracking.  
  - Scalability: Handle millions of users, real-time updates.  
- **Architecture**:  
  - **Frontend**: React for UI, maps integration.  
  - **Backend**: NodeJS with Express, microservices.  
  - **Database**: MySQL for users/rides, Redis for caching, MongoDB for trip logs.  
  - **Services**: Ride Matching, Geolocation, Payment Gateway.  
- **Database**:  
  - Tables: Users(userID, name), Drivers(driverID, location), Rides(rideID, userID, driverID, status).  
- **OOP Model (Java)**:  
  - `User`: Book ride, track ride.  
  - `Driver`: Accept/reject ride, update location.  
  - `Ride`: Manage status, fare calculation.  
- **System Flow**:  
  1. User requests ride → Match with nearest driver (geolocation).  
  2. Driver accepts → Update ride status, notify user.  
  3. Complete ride → Process payment, log trip.  
- **Compile-time Polymorphism**:  
  - Achieved via method overloading, static method dispatch.  
  - Example: `calculateFare(distance)` vs. `calculateFare(distance, surge)`.  
- **Edge Cases**: Driver unavailability, concurrent bookings, location errors.

**Code Snippet (Java - Sample Ride Service)**:  
```java
class Ride {
    String rideID, userID, driverID;
    String status;
    public Ride(String rideID, String userID, String driverID) {
        this.rideID = rideID; this.userID = userID; this.driverID = driverID; this.status = "pending";
    }
    // Compile-time polymorphism
    double calculateFare(double distance) { return distance * 2.0; }
    double calculateFare(double distance, double surge) { return distance * 2.0 * surge; }
}

class RideService {
    Map<String, Ride> rides;
    public RideService() { rides = new HashMap<>(); }
    void bookRide(String userID, String driverID) {
        String rideID = generateID();
        rides.put(rideID, new Ride(rideID, userID, driverID));
    }
    private String generateID() { return UUID.randomUUID().toString(); }
}
```

**Notes**:  
- Designed scalable Uber system, explained overloading.  
- Tip: Practice ride-sharing design (GFG System Design). Study compile-time vs. runtime polymorphism.

**Outcome**:  
- Selected after re-interview.

## Key Takeaways and Preparation Tips

- **Academics**: Maintain CGPA > 8.5 (preferably 9) to qualify for aptitude round.  
- **Programming**: Master Java/C++ (syntax, OOPS), practice on HackerRank, CodeChef, Codeforces.  
- **DSA**: Solve medium-hard problems on GFG, LeetCode (strings, matrices, BST, hashing).  
- **System Design**: Practice LLD (ticket booking, Uber) and HLD (scalability, APIs).  
- **OS/DBMS**: Study scheduling, page faults, SQL queries (GFG Last Minute Notes).  
- **Group Activity**: Practice teamwork, creative pitching. Be vocal, align with theme.  
- **HR Prep**: Use STAR method, prepare internship/project stories, research Morgan Stanley.  
- **Resources**:  
  - **Coding**: GFG, LeetCode, HackerRank, Codeforces.  
  - **System Design**: Gaurav Sen, System Design Primer.  
  - **OS/DBMS**: GFG Last Minute Notes.  
  - **Aptitude**: RS Aggarwal.  
- **Interview Day**: Review resume, rest well, stay confident through long rounds.

**Final Note**: As advised, solve GFG problems to build problem-solving skills, not just memorize, bruh!