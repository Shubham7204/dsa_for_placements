# Morgan Stanley Interview Experience for Technology Analyst | On-Campus 2021 (Virtual)

This document details the **Morgan Stanley Interview Experience for Technology Analyst (On-Campus, Virtual)**, shared on April 5, 2024, for the 2021 hiring cycle. Approximately 350 students attempted the Online Assessment (OA) on the Aspiring Minds platform, with 48 shortlisted (26 for App Development, 22 for Enterprise Engineer). The candidate, in the App Development track, excelled in the OA (decent Aptitude/Technical MCQ, all test cases passed in Debug/Coding) and was selected for a 6-month internship (9 total hires: 6 FTE, 3 internships). The process included an OA, two Technical Interviews, and a Pro-Fit Round, conducted virtually on Zoom. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR/Pro-Fit Questions**: STAR-method sample answers for behavioral questions.

Let’s dive in, bruh—this is your playbook to dominate Morgan Stanley’s Tech Analyst interview grind!

## Online Assessment

The OA lasted 2 hours on the Aspiring Minds platform, with four sections: Aptitude, Technical MCQ, Code Debug, and Coding. No switching between sections.

### Section 1: Aptitude

**Problem Statement**:  
- 10 questions, 20 minutes, moderate difficulty.  
- Topics: Quantitative aptitude (e.g., probability, permutations), logical reasoning (e.g., puzzles).

**Approach**:  
- **Strategy**:  
  1. Solve arithmetic questions first (e.g., percentages, ratios).  
  2. Use elimination for logical puzzles.  
  3. Double-check units/conditions.  
- **Edge Cases**: Tricky wording, decimal precision.

**Notes**:  
- Performed decently.  
- Resources: RS Aggarwal, GFG Aptitude.  
- Tip: Practice 10-minute aptitude sets, aim for 8/10.

### Section 2: Technical MCQ

**Problem Statement**:  
- 20 questions, 20 minutes, based on OS, DBMS, Networks.  
- Topics: Process scheduling, SQL queries, TCP/IP, OSI model.

**Approach**:  
- **Strategy**:  
  1. Answer OS questions first (e.g., deadlock, paging).  
  2. Tackle DBMS (normalization, joins), then Networks (protocols).  
  3. Verify terminology (e.g., starvation vs. deadlock).  
- **Edge Cases**: Ambiguous options, practical scenarios.

**Notes**:  
- Performed decently.  
- Resources: GFG Last Minute Notes (OS, DBMS, CN).  
- Tip: Practice 20-minute MCQ sets, aim for 16/20.

### Section 3: Code Debug

**Problem Statement**:  
- 7 questions, 20 minutes, language choice (C++ chosen).  
- Task: Fix syntax/logic errors to pass all test cases.  
- Topics: Loops, conditionals, pointers, basic algorithms.  
- Solved all 7.

**Approach**:  
- **Strategy**:  
  1. Identify syntax errors (e.g., missing semicolons, wrong operators).  
  2. Fix logical errors (e.g., incorrect loop bounds, conditions).  
  3. Test mentally with sample inputs.  
- **Edge Cases**: Null pointers, uninitialized variables, edge inputs.

**Notes**:  
- Passed all test cases.  
- Resources: GFG Debugging, HackerRank.  
- Tip: Practice 5-minute debug challenges, aim for 7/7.

### Section 4: Coding Section

**Duration**: 60 minutes, 3 questions (1 easy, 1 medium, 1 hard), C++ chosen. All test cases passed.

#### Question 1: Logic-Based (Easy)

**Problem Statement**:  
- Direct logic-based question (unspecified, likely array/string manipulation).  
- **Assumption**: Find elements in an array satisfying a condition (e.g., sum of digits equals a target).  
- **Example**: Input: arr=[12, 23, 11], target=3 → Output: [12, 11] (1+2=3, 1+1=2).

**Approach**:  
- **Brute Force**: Check each element (O(n*k), k=digits).  
- **Optimal Approach**: Linear scan.  
  - Pointwise:  
    1. Iterate array, compute sum of digits for each number.  
    2. If sum equals target, include in result.  
    - Edge cases: Empty array, no valid elements.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int sumOfDigits(int num) {
    int sum = 0;
    while (num) {
        sum += num % 10;
        num /= 10;
    }
    return sum;
}

vector<int> findElements(vector<int>& arr, int target) {
    vector<int> result;
    for (int num : arr) {
        if (sumOfDigits(num) == target) {
            result.push_back(num);
        }
    }
    return result;
}
```

**Time Complexity**: O(n*log(m)), m=max number digits.  
**Space Complexity**: O(n) for output.  
**Notes**:  
- Solved, all test cases passed.  
- GFG “Array Manipulation.” Test empty array, large numbers.

#### Question 2: Merge Intervals (Medium)

**Problem Statement**:  
- Given a list of intervals, merge overlapping intervals.  
- **Link**: [GFG - Merge Intervals](https://www.geeksforgeeks.org/dsa/merging-intervals/).  
- **Example**: Input: [[1,3],[2,6],[8,10],[15,18]] → Output: [[1,6],[8,10],[15,18]].  
- **Constraints**: Intervals non-empty, integers.

**Approach**:  
- **Brute Force**: Compare each interval with others (O(n²)).  
- **Optimal Approach**: Sort and merge.  
  - Pointwise:  
    1. Sort intervals by start time.  
    2. Iterate, merge if current start ≤ previous end.  
    3. Add non-overlapping intervals to result.  
    - Edge cases: Single interval, all overlapping.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<vector<int>> mergeIntervals(vector<vector<int>>& intervals) {
    if (intervals.empty()) return {};
    sort(intervals.begin(), intervals.end());
    vector<vector<int>> result;
    result.push_back(intervals[0]);
    for (int i = 1; i < intervals.size(); i++) {
        if (intervals[i][0] <= result.back()[1]) {
            result.back()[1] = max(result.back()[1], intervals[i][1]);
        } else {
            result.push_back(intervals[i]);
        }
    }
    return result;
}
```

**Time Complexity**: O(n log n) for sorting.  
**Space Complexity**: O(n) for output.  
**Notes**:  
- Solved, all test cases passed.  
- LeetCode #56. Test single interval, overlapping.

#### Question 3: Longest Common Subsequence (Hard)

**Problem Statement**:  
- Find the length of the longest common subsequence between two strings.  
- **Link**: [GFG - Longest Common Subsequence](https://www.geeksforgeeks.org/dsa/longest-common-subsequence-dp-4/).  
- **Example**: Input: s1="ABCDGH", s2="AEDFHR" → Output: 4 (ADGH).  
- **Constraints**: String length ≤ 10^3.

**Approach**:  
- **Brute Force**: Generate all subsequences (O(2^n)).  
- **Optimal Approach**: Dynamic Programming.  
  - Pointwise:  
    1. Use DP table dp[i][j] = LCS length for s1[0..i-1], s2[0..j-1].  
    2. If chars match, dp[i][j] = dp[i-1][j-1] + 1.  
    3. Else, dp[i][j] = max(dp[i-1][j], dp[i][j-1]).  
    - Edge cases: Empty strings, single char.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int longestCommonSubsequence(string s1, string s2) {
    int n = s1.size(), m = s2.size();
    vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (s1[i-1] == s2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    return dp[n][m];
}
```

**Time Complexity**: O(n*m).  
**Space Complexity**: O(n*m).  
**Notes**:  
- Solved, all test cases passed.  
- LeetCode #1143. Test empty strings, identical strings.

**OA Performance**:  
- Decent Aptitude/Technical MCQ, passed all test cases in Debug/Coding.  
- 48/350 shortlisted (26 for App Development).

## Technical Interview 1

**Duration**: ~60 minutes, via Zoom.  
**Interviewer**: Focused on resume, OOPS, coding, system design, SQL, data structures.

### Question 4: Introduction and Resume

**Problem Statement**:  
- Introduce yourself, discuss resume.

**Sample Answer**:  
- **Introduction**: “I’m a final-year CSE student, passionate about system design and DSA. I’ve built projects in Java and C++, including a booking app.”  
- **Resume**: “My projects focus on scalable web apps, using React and NodeJS, with internships in full-stack development.”

**Notes**:  
- Kept concise, tied to role.  
- Tip: Prepare a 1-minute intro, highlight relevant projects.

### Question 5: OOPS Principles

**Problem Statement**:  
- Explain OOPS principles, inheritance, method overriding, with examples.

**Approach**:  
- **OOPS Principles**:  
  - **Encapsulation**: Bundle data/methods, e.g., private fields in a class.  
  - **Inheritance**: Child class inherits parent (extends in Java).  
  - **Polymorphism**: Method overriding (runtime), overloading (compile-time).  
  - **Abstraction**: Hide details via abstract classes/interfaces.  
- **Inheritance Example**: Class `Vehicle` with `Car` subclass.  
- **Method Overriding**: Child class redefines parent method.  
- **Code Example (Java)**:  
  ```java
  class Vehicle {
      void move() { System.out.println("Vehicle moves"); }
  }
  class Car extends Vehicle {
      void move() { System.out.println("Car drives"); } // Overriding
  }
  class Main {
      public static void main(String[] args) {
          Vehicle v = new Car();
          v.move(); // Car drives
      }
  }
  ```

**Notes**:  
- Explained with examples.  
- Tip: Study OOPS (GFG Java, JavaTpoint).

### Question 6: Maximum Root-to-Leaf Path

**Problem Statement**:  
- Find the maximum sum path from root to leaf in a binary tree (function only).  
- **Example**: Input: [10,5,15,null,null,12,8] → Output: 33 (10→15→8).

**Approach**:  
- **Brute Force**: Explore all paths, track max sum (O(n)).  
- **Optimal Approach**: Recursive DFS.  
  - Pointwise:  
    1. Recurse left/right, return max sum path from node to leaf.  
    2. At each node, choose max of left/right sum + node value.  
    - Edge cases: Single node, negative values.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

int maxPathSum(TreeNode* root) {
    if (!root) return 0;
    if (!root->left && !root->right) return root->val;
    return root->val + max(maxPathSum(root->left), maxPathSum(root->right));
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(h) for recursion stack (h = tree height).  
**Notes**:  
- Solved correctly.  
- GFG “Max Root to Leaf Path.” Test negative values, single node.

### Question 7: Minimum Number of Platforms

**Problem Statement**:  
- Given arrival and departure times of trains, find the minimum number of platforms required.  
- **Example**: Input: arr=[900,940,950], dep=[910,1200,1120] → Output: 3.  
- **Link**: [GFG - Minimum Platforms](https://www.geeksforgeeks.org/dsa/minimum-number-platforms-required-railwaybus-station/).

**Approach**:  
- **Brute Force**: Check overlaps for each train (O(n²)).  
- **Optimal Approach**: Sort and two-pointer.  
  - Pointwise:  
    1. Sort arrival and departure arrays.  
    2. Use two pointers to track active trains (increment on arrival, decrement on departure).  
    3. Track max platforms needed.  
    - Edge cases: Same arrival/departure, single train.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int minPlatforms(vector<int>& arr, vector<int>& dep) {
    int n = arr.size();
    sort(arr.begin(), arr.end());
    sort(dep.begin(), dep.end());
    int platforms = 0, maxPlatforms = 0, i = 0, j = 0;
    while (i < n && j < n) {
        if (arr[i] <= dep[j]) {
            platforms++;
            maxPlatforms = max(maxPlatforms, platforms);
            i++;
        } else {
            platforms--;
            j++;
        }
    }
    return maxPlatforms;
}
```

**Time Complexity**: O(n log n) for sorting.  
**Space Complexity**: O(1).  
**Notes**:  
- Solved with syntax errors, debugged.  
- GFG “Minimum Platforms.” Test same times, single train.

### Question 8: Parking Lot System Design

**Problem Statement**:  
- Design a parking lot for Bike, Car, Bus with Bike, Compact, Large slots. Constraints: Bike fits any slot, Car fits Compact/Large, Bus needs 5 Large slots. Optimize slot usage and find empty slots efficiently.  
- **Link**: [GFG - Parking Lot Design](https://www.geeksforgeeks.org/dsa/design-parking-system/).

**Approach**:  
- **Requirements**:  
  - Park vehicles, find slots, optimize Large slot usage (avoid bikes/cars blocking Bus slots).  
- **Class Design (Java)**:  
  - `Vehicle`: Enum (Bike, Car, Bus).  
  - `ParkingSlot`: Type (Bike, Compact, Large), status (occupied/free).  
  - `ParkingLot`: Manage slots, assign vehicles.  
- **Efficient Slot Finding**:  
  - Use priority queue or array of free slots per type.  
  - For Bus, check 5 consecutive Large slots.  
- **Optimization**:  
  - Prioritize Bike slots for Bikes, Compact for Cars, reserve Large for Buses.  
- **Concurrency**: Use locks for slot allocation.  
- **Edge Cases**: No free slots, Bus requiring fragmented Large slots.

**Code Snippet (Java)**:  
```java
enum VehicleType { BIKE, CAR, BUS }
enum SlotType { BIKE, COMPACT, LARGE }

class ParkingSlot {
    SlotType type;
    boolean occupied;
    public ParkingSlot(SlotType type) { this.type = type; this.occupied = false; }
}

class ParkingLot {
    vector<ParkingSlot> slots;
    public ParkingLot(int bikeSlots, int compactSlots, int largeSlots) {
        for (int i = 0; i < bikeSlots; i++) slots.push_back(new ParkingSlot(SlotType.BIKE));
        for (int i = 0; i < compactSlots; i++) slots.push_back(new ParkingSlot(SlotType.COMPACT));
        for (int i = 0; i < largeSlots; i++) slots.push_back(new ParkingSlot(SlotType.LARGE));
    }
    bool parkVehicle(VehicleType vehicle) {
        if (vehicle == VehicleType.BIKE) {
            for (auto& slot : slots) {
                if (!slot.occupied) {
                    slot.occupied = true;
                    return true;
                }
            }
        } else if (vehicle == VehicleType.CAR) {
            for (auto& slot : slots) {
                if (!slot.occupied && (slot.type == SlotType.COMPACT || slot.type == SlotType.LARGE)) {
                    slot.occupied = true;
                    return true;
                }
            }
        } else if (vehicle == VehicleType.BUS) {
            int count = 0;
            for (int i = 0; i < slots.size(); i++) {
                if (slots[i].type == SlotType.LARGE && !slots[i].occupied) {
                    count++;
                    if (count == 5) {
                        for (int j = i-4; j <= i; j++) slots[j].occupied = true;
                        return true;
                    }
                } else {
                    count = 0;
                }
            }
        }
        return false;
    }
}
```

**Notes**:  
- Discussed for 20-25 minutes, covered scenarios.  
- Tip: Practice LLD (GFG System Design, System Design Primer).

### Question 9: SQL - Max Salary per Department

**Problem Statement**:  
- Find employees with maximum salary in each department.  
- Tables: Employee(empID, name, salary, deptID), Department(deptID, deptName).  
- **Example**: Output: Employees with highest salary per deptID.

**Approach**:  
- **Using Subquery**: Group by deptID, find max salary, join with Employee.  
- **Query**:  
  ```sql
  SELECT e.name, e.salary, e.deptID
  FROM Employee e
  INNER JOIN (
      SELECT deptID, MAX(salary) as maxSalary
      FROM Employee
      GROUP BY deptID
  ) m ON e.deptID = m.deptID AND e.salary = m.maxSalary;
  ```
- **Edge Cases**: Multiple max salaries, empty departments.

**Notes**:  
- Couldn’t solve, interviewer moved on.  
- Tip: Practice SQL joins, group by (GFG SQL).

### Question 10: Vectors and HashMap in C++

**Problem Statement**:  
- Explain how data is stored in vectors, how HashMap works, collision handling, memory allocation for vectors.

**Approach**:  
- **Vectors**:  
  - Dynamic array, contiguous memory, doubles capacity on resize.  
  - Memory Allocation: O(1) amortized push_back, reallocation O(n).  
- **HashMap (unordered_map)**:  
  - Uses hash table, key hashed to index, stores key-value pairs.  
  - Collision Handling: Separate chaining (linked lists) or open addressing (probing).  
- **Edge Cases**: Vector resizing, hash collisions, load factor.

**Notes**:  
- Answered well.  
- Tip: Study STL (GFG C++ STL).

**Technical Interview 1 Performance**:  
- Handled OOPS, coding (with debug issues), system design; struggled with SQL.  
- Advanced to Technical Interview 2.

## Technical Interview 2

**Duration**: ~50 minutes, via Zoom, two interviewers.  
**Focus**: Coding, projects, system design.

### Question 11: Power Function (x^y)

**Problem Statement**:  
- Write a function to compute x^y.  
- **Example**: Input: x=2, y=3 → Output: 8 (2^3).

**Approach**:  
- **Brute Force**: Multiply x y times (O(y)).  
- **Optimal Approach**: Binary exponentiation.  
  - Pointwise:  
    1. If y is even, compute x^(y/2) * x^(y/2).  
    2. If y is odd, compute x * x^((y-1)/2) * x^((y-1)/2).  
    3. Use recursion or iteration.  
    - Edge cases: y=0, negative y, x=0.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

double myPow(double x, int y) {
    if (y == 0) return 1.0;
    double half = myPow(x, y/2);
    if (y % 2 == 0) return half * half;
    return y > 0 ? half * half * x : half * half / x;
}
```

**Time Complexity**: O(log y).  
**Space Complexity**: O(log y) for recursion.  
**Notes**:  
- Solved efficiently.  
- LeetCode #50. Test negative y, x=0.

### Question 12: Project Discussion

**Problem Statement**:  
- Discuss projects, tech stack, protocols, and development process.

**Sample Answer**:  
- **Situation**: “Built a real-time booking app.”  
- **Task**: “Create scalable, user-friendly system.”  
- **Action**: “Used React for frontend, NodeJS with Express for backend, MySQL for DB, and REST APIs.”  
- **Result**: “Reduced latency by 30% with caching, deployed successfully.”

**Notes**:  
- Detailed discussion on stack, protocols (e.g., HTTP).  
- Tip: Prepare 2-3 projects, explain scalability.

### Question 13: CoWIN-like Vaccination Booking System

**Problem Statement**:  
- Design an application similar to CoWIN for booking vaccination slots, viewing availability, handling concurrency.  
- Include functions, data structures, system flow.

**Approach**:  
- **Requirements**:  
  - Book slots, check availability, user authentication, concurrency handling.  
- **Architecture**:  
  - **Frontend**: React for UI, real-time updates.  
  - **Backend**: NodeJS with Express, REST APIs.  
  - **Database**: MySQL for users/centers/slots, Redis for caching availability.  
- **Class Design (Java)**:  
  - `User`: ID, name, bookings.  
  - `VaccinationCenter`: ID, location, slots.  
  - `Booking`: UserID, CenterID, slotTime, status.  
- **Concurrency Handling**:  
  - Use database transactions, locks (e.g., row-level locking).  
  - Optimistic locking: Check slot availability before booking.  
- **System Flow**:  
  1. User searches centers → Cache availability in Redis.  
  2. Select slot → Lock slot, verify availability.  
  3. Confirm booking → Update DB, notify user.  
- **Data Structures**:  
  - HashMap for center-to-slots mapping.  
  - Priority Queue for slot allocation.  
- **Edge Cases**: Concurrent bookings, no slots, network failures.

**Code Snippet (Java - Booking Service)**:  
```java
class VaccinationCenter {
    String id, location;
    int slots;
    public VaccinationCenter(String id, String location, int slots) {
        this.id = id; this.location = location; this.slots = slots;
    }
}

class BookingService {
    Map<String, VaccinationCenter> centers;
    Map<String, String> bookings; // UserID -> CenterID
    public BookingService() {
        centers = new HashMap<>();
        bookings = new HashMap<>();
    }
    synchronized boolean bookSlot(String userID, String centerID) {
        if (centers.containsKey(centerID) && centers.get(centerID).slots > 0) {
            centers.get(centerID).slots--;
            bookings.put(userID, centerID);
            return true;
        }
        return false;
    }
}
```

**Notes**:  
- Discussed for 30 minutes, covered concurrency.  
- Tip: Practice LLD for booking systems (GFG System Design).

**Technical Interview 2 Performance**:  
- Handled coding, projects, system design well.  
- Advanced to Pro-Fit Round.

## Pro-Fit Round

**Duration**: ~60 minutes, via Zoom, with Executive Director.  
**Focus**: Role discussion, behavioral, basic technical questions.

### Question 14: Introduction and Role Discussion

**Problem Statement**:  
- Introduce yourself, discuss Morgan Stanley’s tech domains and role.

**Sample Answer**:  
- **Introduction**: “I’m a CSE student with expertise in DSA and system design, passionate about scalable systems.”  
- **Role Discussion**: “Excited about App Development track, building robust financial systems using Java and microservices.”

**Notes**:  
- Discussed for 30 minutes, aligned with role.  
- Tip: Research Morgan Stanley’s tech stack.

### Question 15: Teamwork Skills

**Problem Statement**:  
- How do you demonstrate teamwork skills?

**Sample Answer**:  
- **Situation**: “Led a team in a hackathon to build a web app.”  
- **Task**: “Coordinate development under tight deadlines.”  
- **Action**: “Assigned roles, used Agile, resolved conflicts via communication.”  
- **Result**: “Delivered app, won second place.”

**Notes**:  
- Highlighted collaboration.  
- Tip: Use STAR, emphasize leadership.

### Question 16: Handling Project Problems

**Problem Statement**:  
- How do you handle problems during a project?

**Sample Answer**:  
- **Situation**: “Faced API downtime in a freelance project.”  
- **Task**: “Ensure app functionality.”  
- **Action**: “Implemented fallback logic, cached responses, communicated with client.”  
- **Result**: “Maintained uptime, client extended contract.”

**Notes**:  
- Showed problem-solving.  
- Tip: Prepare 1-2 challenge stories.

### Question 17: Binary Search

**Problem Statement**:  
- Explain Binary Search, implement it.  
- **Example**: Input: arr=[1,2,3,4,5], target=3 → Output: 2.

**Approach**:  
- **Explanation**: Divide sorted array, compare mid element, recurse on half.  
- **Optimal Approach**: Iterative binary search.  
  - Pointwise:  
    1. Initialize low=0, high=n-1.  
    2. Compute mid, compare with target.  
    3. Adjust low/high based on comparison.  
    - Edge cases: Target not found, empty array.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int binarySearch(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) return mid;
        if (arr[mid] < target) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}
```

**Time Complexity**: O(log n).  
**Space Complexity**: O(1).  
**Notes**:  
- Answered correctly.  
- LeetCode #704. Test unsorted array, duplicates.

### Question 18: Heap

**Problem Statement**:  
- Explain Heap, its properties, and usage.

**Approach**:  
- **Explanation**:  
  - Heap: Binary tree with heap property (max/min).  
  - Max-Heap: Parent ≥ children.  
  - Usage: Priority queues, heap sort, Dijkstra’s algorithm.  
- **Properties**:  
  - Complete binary tree, stored as array.  
  - Heapify: O(log n), build heap: O(n).  
- **Edge Cases**: Empty heap, single element.

**Notes**:  
- Answered well.  
- Tip: Study heap operations (GFG Heap).

**Outcome**:  
- Selected for 6-month internship (9 total hires: 6 FTE, 3 internships).

## Key Takeaways and Preparation Tips

- **Academics**: Maintain CGPA > 8.5, strong 10th/12th scores.  
- **DSA**: Solve easy-hard problems on LeetCode, GFG (trees, intervals, DP, greedy).  
- **OOPS**: Master Java (inheritance, overriding), C++ (vectors, HashMap).  
- **System Design**: Practice LLD (parking lot, booking systems), focus on concurrency.  
- **SQL/OS**: Study joins, group by (GFG SQL), scheduling, memory (GFG OS).  
- **Projects**: Prepare 2-3 projects, emphasize tech stack, challenges.  
- **Pro-Fit Prep**: Use STAR for behavioral, research Morgan Stanley’s domains.  
- **Resources**:  
  - **Coding**: LeetCode, GFG, HackerRank.  
  - **OOPS/OS/SQL**: GFG Last Minute Notes, JavaTpoint.  
  - **System Design**: GFG System Design, System Design Primer.  
  - **Aptitude**: RS Aggarwal.  
- **Interview Day**: Review resume, debug code carefully, stay calm during tough questions.

**Final Note**: Solve all test cases in coding, bruh—Morgan Stanley doesn’t mess around with partial solutions!