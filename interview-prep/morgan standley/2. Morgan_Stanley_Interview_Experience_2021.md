# Morgan Stanley Interview Experience for 6-Months Internship + FTE (On-Campus) 2021

This document details the **Morgan Stanley Interview Experience for a 6-Months Internship + FTE (On-Campus) 2021**, conducted for the Enterprise Engineer Track. Around 388 students with a CGPA ≥ 9 were shortlisted for the Online Assessment (OA). The process included an OA with three sections (Debugging, Reasoning Ability, Coding) and virtual interviews (Technical Round 1, with an HR round for others). Only 22 candidates advanced to interviews for the Enterprise Engineer Track, and 10 (Enterprise + App Dev) were selected overall. The candidate was rejected post-Technical Round 1 but shares valuable insights. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: Inferred questions with STAR-method sample answers.

Let’s dive in, bruh—this is your guide to mastering Morgan Stanley’s process!

## Online Assessment (OA)

The OA lasted **2 hours** on the **Aspiring Minds (SHL) platform**, with three sections: Debugging (20 min), Reasoning Ability (20 min), and Coding (80 min). You could revisit questions within a section but not switch between sections.

### Section 1: Debugging Round

**Problem Statement**:  
- 7 questions, 20 minutes, easy difficulty.
- Goal: Fix code snippets to pass all test cases by correcting syntax, logic, or reversing signs.
- Example: Adjust loop bounds (e.g., `i <= n` to `i < n`), fix operators, or correct output formatting.
- Language: Choose preferred language (C++ used here).

**Approach**:  
- **Strategy**:  
  1. Read problem and expected output.  
  2. Identify syntax errors (e.g., missing semicolons, wrong types).  
  3. Fix logical errors (e.g., off-by-one, incorrect operators).  
  4. Mentally test edge cases (e.g., empty input, boundary values).  
- **Edge Cases**: Null inputs, zero, negative numbers, incorrect output formats.

**Code Snippet (C++ Example)**:  
```cpp
// Example: Fix code to print reverse array (incorrect logic)
#include <bits/stdc++.h>
using namespace std;

// Incorrect code (given)
void reverseArray(int arr[], int n) {
    for (int i = 0; i <= n; i++) {  // Error: <= causes out-of-bounds
        cout << arr[n-i] << " ";
    }
}

// Corrected code
void reverseArray(int arr[], int n) {
    for (int i = 0; i < n; i++) {  // Fix: Use < n
        cout << arr[n-1-i] << " ";  // Fix: Adjust index
    }
}
```

**Time Complexity**: O(n) for most debugging tasks.  
**Space Complexity**: O(1) or O(n) depending on problem.  
**Notes**:  
- Solved all questions, finished early.  
- Tip: Practice debugging on HackerRank/LeetCode. Focus on common errors: off-by-one, uninitialized variables, wrong operators. Test edge cases mentally.

### Section 2: Reasoning Ability Section

**Problem Statement**:  
- 10 questions, 20 minutes, medium difficulty.
- Topics: Quantitative Aptitude (Quants), Logical Reasoning, Data Interpretation.
- Example: Solve permutation problems, analyze bar graphs, or compute time-and-work scenarios.
- Challenge: Minimal calculations, but time management critical.

**Approach**:  
- **Preparation**: Practice quants (ratios, probability), permutations, data interpretation.  
- **Strategy**:  
  1. Prioritize easy questions (e.g., basic quants).  
  2. Use elimination for MCQs.  
  3. For data interpretation, read question first, then analyze graphs.  
  4. Avoid lengthy calculations; estimate where possible.  
- **Edge Cases**: Tricky wording, misleading graph scales.

**Notes**:  
- Solved most questions, but time was tight.  
- Resources: GeeksforGeeks Quantitative Aptitude, SHL mock tests.  
- Tip: Practice 20-minute mock tests to build speed. Aim for 8/10 correct in 15 minutes to leave buffer time.

### Section 3: Coding Round

Three coding questions (easy, easy, medium), 80 minutes. Candidates who recognized patterns solved them efficiently. All were solved by the candidate ~20 minutes early.

#### Question 1: Toys

**Problem Statement**:  
Given N children, each with toy type-0 initially, and Q queries of format [L, R, M], replace toys of children from index L to R (inclusive) with toy type M. After each query, print the most common toy type and its count in format `<toy>-<count>`.  
- **Input**: N = 4, Q = 3, Queries = [[1,1,1], [2,4,2], [1,4,3]]  
- **Output**: 0-3, 2-3, 3-4  
- **Explanation**:  
  1. Initially, all 4 children have toy 0.  
  2. Query 1: Child 1 gets toy 1; toy 0 has count 3 (most common).  
  3. Query 2: Children 2-4 get toy 2; toy 2 has count 3.  
  4. Query 3: All children (1-4) get toy 3; toy 3 has count 4.

**Approach**:  
- **Brute Force**: For each query, update array and scan for max count (O(QN)).  
- **Optimal Approach**: Use array + hashmap for efficient updates.  
  - Pointwise:  
    1. Store toys in array (index = child, value = toy).  
    2. Use hashmap to track toy counts.  
    3. For each query [L,R,M]: Update array, adjust counts in hashmap, find max count.  
    4. Output max toy and count.  
    - Edge cases: N=1, Q=0, same toy in multiple queries.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

void processQueries(int N, vector<vector<int>>& queries) {
    vector<int> toys(N + 1, 0);  // 1-based indexing
    unordered_map<int, int> count;  // toy -> count
    count[0] = N;  // Initially all have toy 0
    
    for (const auto& q : queries) {
        int L = q[0], R = q[1], M = q[2];
        // Update toys and counts
        for (int i = L; i <= R; i++) {
            int oldToy = toys[i];
            count[oldToy]--;
            if (count[oldToy] == 0) count.erase(oldToy);
            toys[i] = M;
            count[M]++;
        }
        // Find most common toy
        int maxCount = 0, maxToy = 0;
        for (const auto& p : count) {
            if (p.second > maxCount || (p.second == maxCount && p.first < maxToy)) {
                maxCount = p.second;
                maxToy = p.first;
            }
        }
        cout << maxToy << "-" << maxCount << endl;
    }
}
```

**Time Complexity**:  
- Brute: O(QN) per query.  
- Optimal: O(QR + QK) where R = max range length, K = unique toys.  
**Space Complexity**: O(N + K) for array and hashmap.  
**Notes**:  
- Classified as easy; solved using hashing.  
- Practice similar problems on LeetCode (e.g., array updates, frequency counting). Test cases like single child or no queries.

#### Question 2: Maximum Continuous Pickups

**Problem Statement**:  
Given Q queries, each with a range [L, R] representing boxes to pick up, find the maximum number of continuous pickups by merging overlapping ranges. Increment R by 1 for continuity (e.g., [1,5] and [6,9] merge to [1,9]).  
- **Input**: Q = 3, Queries = [[1,5], [6,9], [11,17]]  
- **Output**: 9  
- **Explanation**: Merge [1,5] and [6,9] to [1,9] (since 6 follows 5); [11,17] is separate. Max length = 9.

**Approach**:  
- **Brute Force**: Check all range combinations (O(Q²)).  
- **Optimal Approach**: Merge intervals with sorting.  
  - Pointwise:  
    1. Increment each R by 1 for continuity.  
    2. Sort ranges by start time.  
    3. Merge overlapping ranges, track max length.  
    - Edge cases: Non-overlapping ranges, single query, empty input.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int maxContinuousPickups(vector<vector<int>>& queries) {
    for (auto& q : queries) q[1]++;  // Increment R for continuity
    sort(queries.begin(), queries.end());
    int maxLen = 0, currStart = queries[0][0], currEnd = queries[0][1];
    for (int i = 1; i < queries.size(); i++) {
        if (queries[i][0] <= currEnd) {
            currEnd = max(currEnd, queries[i][1]);
        } else {
            maxLen = max(maxLen, currEnd - currStart);
            currStart = queries[i][0];
            currEnd = queries[i][1];
        }
    }
    maxLen = max(maxLen, currEnd - currStart);
    return maxLen;
}
```

**Time Complexity**:  
- Brute: O(Q²).  
- Optimal: O(Q log Q) for sort + O(Q) for merge.  
**Space Complexity**: O(1) excluding input.  
**Notes**:  
- Classified as easy; solved using interval merging.  
- LeetCode #56 (Merge Intervals). Test cases like [[1,2], [2,3]] (continuity edge case).

#### Question 3: Advertisement for OTT Platform

**Problem Statement**:  
Given two advertisement schedules AD1 and AD2 (strings) with costs C1 and C2 per slot, find the minimum loss by selecting the longest common subsequence (LCS) of slots, as order cannot change. Loss = (len(AD1) - len(LCS)) * C1 + (len(AD2) - len(LCS)) * C2.  
- **Input**: AD1 = "abcdedgh", C1 = 10, AD2 = "abcdgbksmn", C2 = 20  
- **Output**: 130  
- **Explanation**: LCS = "abcdg" (length 5). Loss = (8-5)*10 + (10-5)*20 = 30 + 100 = 130.

**Approach**:  
- **Brute Force**: Try all subsequences (O(2^n)).  
- **Optimal Approach**: Dynamic Programming (LCS).  
  - Pointwise:  
    1. Build DP table for LCS length.  
    2. Compute loss: (len(AD1) - LCS) * C1 + (len(AD2) - LCS) * C2.  
    - Edge cases: Empty strings, no common subsequence, equal strings.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int minLoss(string AD1, int C1, string AD2, int C2) {
    int m = AD1.size(), n = AD2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    // LCS length
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (AD1[i-1] == AD2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    int lcs = dp[m][n];
    return (m - lcs) * C1 + (n - lcs) * C2;
}
```

**Time Complexity**:  
- Brute: O(2^n).  
- Optimal: O(m*n) for DP table.  
**Space Complexity**: O(m*n) for DP table.  
**Notes**:  
- Medium difficulty; tricky wording caused issues for many.  
- LeetCode #1143 (Longest Common Subsequence). Practice LCS variations and string DP.

**OA Performance**:  
- Solved all questions ~20 minutes early.  
- 22/388 candidates shortlisted for Enterprise Engineer Track interviews.  
- Note: Many stumbled on the LCS question due to wording; temperament is key.

## Technical Interview Round 1

**Duration**: ~1 hour, conducted virtually (Zoom).  
**Interviewer**: Asked a mix of theoretical, coding, and project questions.  
**Outcome**: Candidate answered all but one question but was rejected. HR round followed for others.

### Question 4: Introduction

**Problem Statement**:  
- Provide a brief introduction (1-2 minutes) covering background, skills, and interests.

**Sample Answer**:  
- "Hi, I’m [Your Name], a B.Tech student in [Branch] with a 9.2 CGPA. I’m passionate about solving complex problems using data structures and algorithms, with strong skills in C++, Java, and system design. I’ve worked on projects like [Project Name], where I optimized [specific task]. I’m excited about Morgan Stanley’s innovative financial systems and eager to contribute to the Enterprise Engineer role."

**Notes**:  
- Keep it concise, relevant to the role. Highlight technical skills and enthusiasm for Morgan Stanley.  
- Tip: Practice a confident, tailored intro. Mention projects listed on resume.

### Question 5: Hashing

**Problem Statement**:  
- **Part 1**: Explain any hashing technique (candidate discussed quadratic and forward hashing).  
- **Part 2**: Given a set of numbers, check if it contains duplicates with the least time complexity.

**Approach**:  
- **Part 1: Hashing Techniques**:  
  - Quadratic Probing: Resolve collisions by probing slots with quadratic increments (e.g., i²).  
  - Forward Hashing (assumed Linear Probing): Probe next slot linearly.  
  - Explain: Hash function, collision resolution, load factor.  
- **Part 2: Detect Duplicates**:  
  - **Brute Force**: Compare each pair (O(n²)).  
  - **Optimal Approach**: Use hash set.  
    - Pointwise:  
      1. Insert elements into hash set.  
      2. If element already exists, return true.  
      3. Else, return false.  
      - Edge cases: Empty array, single element, all duplicates.

**Code Snippet (C++ for Part 2)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

bool containsDuplicates(vector<int>& nums) {
    unordered_set<int> seen;
    for (int num : nums) {
        if (seen.count(num)) return true;
        seen.insert(num);
    }
    return false;
}
```

**Time Complexity**:  
- Part 1: N/A (theoretical).  
- Part 2:  
  - Brute: O(n²).  
  - Optimal: O(n) average case for hash set.  
**Space Complexity**: O(n) for hash set.  
**Notes**:  
- Answered well; discussed quadratic and linear probing clearly.  
- LeetCode #217 (Contains Duplicate). Practice hash table problems and collision techniques.

### Question 6: Java

**Problem Statement**:  
- **Part 1**: Explain the Java Garbage Collector in detail.  
- **Part 2**: Explain Collections class and interface.

**Approach**:  
- **Part 1: Garbage Collector**:  
  - **Overview**: Automatically reclaims memory from unreachable objects.  
  - **Process**:  
    1. Mark: Identify live objects.  
    2. Sweep: Reclaim memory from unmarked objects.  
    3. Compact (optional): Reduce fragmentation.  
  - **Types**: Serial, Parallel, CMS, G1 (heap regions, low pauses).  
  - **Key Concepts**: Young/Old generations, minor/major GC, references (weak, soft).  
- **Part 2: Collections**:  
  - **Collections Interface**: Base for List, Set, Queue (e.g., ArrayList, HashSet). Defines methods like add, remove, size.  
  - **Collections Class**: Static utility class with methods like sort, reverse, binarySearch. Operates on collections.  
  - **Example**: `Collections.sort(list)` for sorting, `Collections.shuffle(list)` for randomization.

**Notes**:  
- Answered both parts; be thorough with GC algorithms (e.g., G1) and Collections hierarchy.  
- Tip: Study Java Memory Model and practice coding with ArrayList, HashMap. Resources: Oracle Java Docs, GeeksforGeeks.

### Question 7: Linked List

**Problem Statement**:  
- **Part 1**: Detect a loop in a linked list.  
- **Part 2**: Remove the loop if detected.

**Approach**:  
- **Part 1: Detect Loop (Floyd’s Cycle Detection)**:  
  - Use slow (1 step) and fast (2 steps) pointers.  
  - If they meet, loop exists; else, no loop.  
- **Part 2: Remove Loop**:  
  1. Find meeting point using Floyd’s algorithm.  
  2. Move slow to head, advance both at 1 step until they meet at loop start.  
  3. Set next of loop start to null.  
  - Edge cases: No loop, single node, entire list looped.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

bool detectLoop(ListNode* head) {
    ListNode *slow = head, *fast = head;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) return true;
    }
    return false;
}

void removeLoop(ListNode* head) {
    if (!head || !head->next) return;
    ListNode *slow = head, *fast = head;
    bool loop = false;
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            loop = true;
            break;
        }
    }
    if (!loop) return;
    slow = head;
    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }
    while (fast->next != slow) fast = fast->next;
    fast->next = nullptr;
}
```

**Time Complexity**: O(n) for both detection and removal.  
**Space Complexity**: O(1).  
**Notes**:  
- Answered both parts.  
- LeetCode #141 (Detect Cycle), #142 (Cycle II). Practice edge cases like loop at head or tail.

### Question 8: In-Depth Project Discussion

**Problem Statement**:  
- Discuss a project in detail, focusing on your contribution and technical challenges.

**Sample Answer**:  
- **Project**: [e.g., Inventory Management System]  
- **Overview**: "I built a DBMS-based inventory system using MySQL and Java. It tracked products, orders, and suppliers, with features like stock alerts and sales reports."  
- **Contribution**:  
  - Designed schema with normalized tables.  
  - Optimized queries using indexes, reducing retrieval time by 40%.  
  - Built a Java GUI for user interaction.  
- **Challenges**:  
  - Faced slow query performance; resolved by adding indexes and caching frequent queries.  
  - Coordinated with team to align UI and backend.  
- **Outcome**: Deployed for local store, improved stock tracking efficiency.

**Notes**:  
- Choose a project you know deeply (not the “fancy” one). Be ready for follow-ups on tech stack, challenges, and optimizations.  
- Tip: Prepare 2-3 projects with clear contributions. Use STAR method for challenges.

### Question 9: Sorting

**Problem Statement**:  
- **Part 1**: Explain different in-place sorting techniques.  
- **Part 2**: Analyze time complexity of sorting techniques.  
- **Part 3**: Implement QuickSort.

**Approach**:  
- **Part 1: In-Place Sorting**:  
  - QuickSort: Partition-based, pivoting.  
  - HeapSort: Heapify, extract max.  
  - Insertion Sort: Incremental insertion.  
  - Selection Sort: Repeatedly select minimum.  
- **Part 2: Time Complexity**:  
  - QuickSort: O(n log n) average, O(n²) worst.  
  - HeapSort: O(n log n).  
  - Insertion Sort: O(n²).  
  - Selection Sort: O(n²).  
- **Part 3: QuickSort Implementation**:  
  - Choose pivot (e.g., last element).  
  - Partition array, recurse on subarrays.  
  - Edge cases: Already sorted, all same elements.

**Code Snippet (C++ for QuickSort)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}
```

**Time Complexity**:  
- QuickSort: O(n log n) average, O(n²) worst.  
- Others: As listed above.  
**Space Complexity**: O(log n) for QuickSort recursion, O(1) for others.  
**Notes**:  
- Answered all parts.  
- Practice QuickSort edge cases (e.g., duplicates). Study MergeSort vs. QuickSort trade-offs.

### Question 10: Operating Systems

**Problem Statement**:  
- Explain:  
  1. Process vs Thread  
  2. Virtual Memory  
  3. RAID  
  4. Thrashing  
  5. Preemptive vs Non-Preemptive Scheduling, Starvation  
  6. Page Replacement and Page Faults

**Approach**:  
- **Process vs Thread**:  
  - Process: Independent program with own memory, resources.  
  - Thread: Lightweight unit within process, shares memory.  
- **Virtual Memory**: Maps virtual addresses to physical, uses paging/swapping.  
- **RAID**: Redundant Array of Independent Disks; levels (e.g., RAID 0, 1) for performance/redundancy.  
- **Thrashing**: Excessive paging due to low physical memory, high page faults.  
- **Scheduling**:  
  - Preemptive: OS interrupts tasks (e.g., Round Robin).  
  - Non-Preemptive: Task runs to completion (e.g., FCFS).  
  - Starvation: Low-priority tasks indefinitely delayed.  
- **Page Replacement and Page Faults**:  
  - Page Fault: Requested page not in memory, triggers swap.  
  - Replacement: Algorithms like LRU, FIFO to swap pages.

**Notes**:  
- Answered all but one (unspecified). Likely a minor miss in depth (e.g., RAID levels).  
- Resources: GeeksforGeeks OS Last Minute Notes. Study scheduling algorithms, memory management.

## Inferred HR Round Questions

The candidate was rejected post-Technical Round 1, but an HR round followed for others. Based on common Morgan Stanley HR questions and the experience’s context, here are inferred questions with STAR-method sample answers.

### Question 11: Why Morgan Stanley?

**Problem Statement**:  
- Why do you want to work at Morgan Stanley?

**Sample Answer**:  
- **Situation**: "I’m passionate about leveraging technology in finance, and Morgan Stanley’s leadership in this space inspires me."  
- **Task**: "I want to contribute to innovative financial systems and grow as an engineer."  
- **Action**: "I’ve researched Morgan Stanley’s work on trading platforms and data analytics, which aligns with my skills in DSA and system design. I’ve also prepared by practicing relevant coding problems."  
- **Result**: "I’m excited to bring my problem-solving skills to your team and learn from industry leaders during the internship."

**Notes**:  
- Align with Morgan Stanley’s values (integrity, excellence). Research their tech stack (e.g., Java, C++).  
- Tip: Show enthusiasm and specific knowledge about the firm.

### Question 12: Teamwork and Challenges

**Problem Statement**:  
- Describe a time you worked in a team and overcame a challenge.

**Sample Answer**:  
- **Situation**: "In a hackathon, my team struggled to integrate a real-time chat feature due to API issues."  
- **Task**: "As the backend lead, I needed to ensure seamless integration to meet the deadline."  
- **Action**: "I debugged the API calls, identified a rate-limiting issue, and implemented caching. I coordinated with the frontend team to adjust the UI and held daily sync-ups to track progress."  
- **Result**: "We delivered the feature on time, and our project won first place for functionality."

**Notes**:  
- Use STAR method. Highlight collaboration, problem-solving, and impact.  
- Tip: Prepare 2-3 stories about teamwork or leadership.

### Question 13: Strengths and Weaknesses

**Problem Statement**:  
- What are your strengths and weaknesses?

**Sample Answer**:  
- **Strengths**: "My strength is problem-solving under pressure. For example, in a coding competition, I optimized a graph algorithm to pass all test cases in 30 minutes, improving from O(n²) to O(n log n)."  
- **Weaknesses**: "I sometimes overanalyze details, which can slow decision-making. I’m addressing this by setting time limits and prioritizing key tasks, as seen in a recent project where I delivered ahead of schedule."

**Notes**:  
- Be honest about weaknesses, show improvement steps. Tie strengths to technical skills.  
- Tip: Avoid generic answers; use specific examples.

## Key Takeaways and Preparation Tips

- **Learn from Rejections**: Move on quickly; use feedback to improve. Candidate was shortlisted by Amazon 2 days later.  
- **Stay Calm and Communicate**: Verbalize thought process, avoid long pauses. If stuck, mention it and keep talking (e.g., “Let me think about this…”).  
- **Choose Known Projects**: Discuss projects you understand deeply, not the “fancy” ones. Be ready for detailed follow-ups.  
- **Consistency in DSA**: Practice daily on LeetCode, GeeksforGeeks, InterviewBit, HackerRank. Focus on arrays, strings, graphs, DP.  
- **Write Clean Code**: Avoid logical/syntactical errors on first attempt. Practice writing bug-free code under time constraints.  
- **Typing Speed**: Improve to ~90 WPM (candidate went from 30 to 95 WPM in 8 months). Use 10fastfingers, Keybr, TypingClub.  
- **Research Company**: Study Morgan Stanley’s principles (e.g., integrity), work culture, and tech stack before interviews.  
- **Interview Strategy**:  
  - Discuss brute force first, then optimize.  
  - Ask clarifying questions, even for familiar problems.  
  - Act like solving for the first time to show thought process.  
  - Be confident, keep speaking plausible solutions, even if unsure.  
- **Resources**:  
  - GeeksforGeeks for DSA, OS, Java, DBMS.  
  - LeetCode for coding practice (medium-hard).  
  - SHL/Aspiring Minds for aptitude/debugging mocks.