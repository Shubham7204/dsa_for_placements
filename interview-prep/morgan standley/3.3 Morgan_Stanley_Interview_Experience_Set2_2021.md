# Morgan Stanley Interview Experience | Set 2 (On-Campus) 2021

This document details the **Morgan Stanley Interview Experience for FTE (On-Campus)**, shared on July 23, 2025. The process, conducted in 2020, included a Written Test with MCQs, a Coding Round, and four interview rounds: Technical Interview 1, Group Activity, Technical Interview 2, and HR Round. The candidate solved 2-3/10 aptitude questions, most C/Computer Skills questions, all coding questions, and advanced through rounds, with 21/256 shortlisted after the Written Test and 9/21 after Technical Interview 1. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers for behavioral questions.

Let’s get into it, bruh—this is your cheat sheet to dominate Morgan Stanley’s intense interview grind!

## Written Test

The Written Test consisted of MCQs in three sections: Aptitude/Data Interpretation (10 questions), C/Computer Skills (remaining questions, likely 20-30), with a choice of C/C++/Java for language-specific questions.

### Section 1: Aptitude and Data Interpretation

**Problem Statement**:  
- 10 questions, moderate difficulty.  
- Topics: Probability, combinatorics, data interpretation, puzzles.  
- Solved 2-3/10 due to time constraints.

**Questions**:  
1. **Lightest Ball**: Weigh 5 balls (weight < 30kg) using a machine that only measures > 30kg by weighing pairs. Given pair weights, find the lightest ball.  
2. **Probability of Balls**: Boxes A (2 white, 3 blue), B (1 white, 4 blue), C (4 white, 1 blue). Pick one ball from each, find P(2 white, 1 blue).  
3. **Distribute Balls**: Distribute 4 balls (2 identical) into 3 distinct boxes, each can have any number.  
4. **Einstein Puzzle**: Simplified logic puzzle.  
5. **Data Interpretation**: Interpret data from two graphs.

**Approach**:  
- **Lightest Ball**:  
  - Pair weights > 30kg imply summing two balls’ weights.  
  - Subtract smallest pair weight from others to deduce individual weights.  
  - Identify lightest (O(1) with 5 balls).  
- **Probability**:  
  - P(white from A) = 2/5, B = 1/5, C = 4/5.  
  - Cases: (W,W,B), (W,B,W), (B,W,W).  
  - Total P = (2/5 * 1/5 * 1/5) + (2/5 * 4/5 * 4/5) + (3/5 * 1/5 * 4/5).  
- **Distribute Balls**:  
  - Stars and bars for 4 balls (2 identical) into 3 boxes.  
  - Formula: C(n+k-1, k-1) adjusted for identical balls.  
- **Einstein Puzzle**: Logical deduction, elimination.  
- **Data Interpretation**: Analyze graphs, compute ratios/percentages.  
- **Edge Cases**: Edge weights, zero probability, empty boxes.

**Notes**:  
- Solved 2-3/10; time management critical.  
- Resources: GFG Probability, RS Aggarwal, HackerRank Puzzles.  
- Tip: Practice combinatorics, probability under 10-minute timers.

### Section 2: C/Computer Skills

**Problem Statement**:  
- ~20-30 questions, easy difficulty, C/C++/Java choice.  
- Topics: Output prediction, hashing, binary trees, arrays, binary search, memory layout.  
- Solved almost all.

**Questions**:  
1. **Output of sizeof("")**: Predict output of `printf("%d", sizeof(""));`.  
2. **Hashing and Quadratic Probing**: Explain quadratic probing in hash tables.  
3. **Binary Tree**: Likely traversal or property question.  
4. **Array Address**: Find address of `array[5][6]` given base address.  
5. **Binary Search Comparisons**: Number of comparisons in binary search.  
6. **Union/Structure Size**: Memory layout and size of union/structure.

**Approach**:  
- **sizeof("")**: Empty string has null terminator, size = 1 byte in C.  
- **Quadratic Probing**: Resolve collisions with f(i) = i^2, calculate probe sequence.  
- **Binary Tree**: Standard traversal (e.g., inorder).  
- **Array Address**: Address = base + (i*cols + j)*size (e.g., 5*cols + 6).  
- **Binary Search**: Max comparisons = log2(n) + 1.  
- **Union/Structure**: Union size = max member size, structure size = sum with padding.  
- **Edge Cases**: Null strings, hash collisions, unaligned memory.

**Code Snippet (C Example for sizeof)**:  
```c
#include <stdio.h>
int main() {
    printf("%d", sizeof("")); // Output: 1
    return 0;
}
```

**Notes**:  
- Easy section, solved most.  
- Resources: GFG C Programming, HackerRank MCQs.  
- Tip: Practice output prediction, memory layout questions.

**Written Test Performance**:  
- Solved 2-3/10 aptitude, most C/Computer Skills.  
- 21/256 shortlisted for Coding Round.

## Coding Round

**Duration**: 45 minutes, 4 questions, write code on paper.  
**Note**: Questions were easy but time-constrained.

### Question 1: Find Anagrams in Dictionary

**Problem Statement**:  
Given a dictionary of words, group all words that are anagrams of each other.  
- **Example**: Input: ["cat", "act", "dog", "god"] → Output: [["cat", "act"], ["dog", "god"]].

**Approach**:  
- **Brute Force**: Compare each pair (O(n^2)).  
- **Optimal Approach**: Use hash map with sorted characters as key.  
  - Pointwise:  
    1. For each word, sort its characters to create key.  
    2. Map key to list of anagram words.  
    3. Output grouped lists.  
    - Edge cases: Empty dictionary, single word, same characters.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<vector<string>> groupAnagrams(vector<string>& dict) {
    unordered_map<string, vector<string>> groups;
    for (string& s : dict) {
        string key = s;
        sort(key.begin(), key.end());
        groups[key].push_back(s);
    }
    vector<vector<string>> result;
    for (auto& g : groups) {
        result.push_back(g.second);
    }
    return result;
}
```

**Time Complexity**: O(n*k*log k) (k = max word length).  
**Space Complexity**: O(n*k) for hash map.  
**Notes**:  
- Solved; LeetCode #49.  
- Test with empty strings, duplicates.

### Question 2: Pair Sum in Sorted Array

**Problem Statement**:  
Given a sorted array and number c, find a pair (a, b) such that a + b = c.  
- **Example**: Input: [1, 2, 3, 4], c=7 → Output: (3, 4).

**Approach**:  
- **Brute Force**: Check all pairs (O(n^2)).  
- **Optimal Approach**: Two-pointer technique.  
  - Pointwise:  
    1. Initialize left=0, right=n-1.  
    2. If arr[left] + arr[right] = c, return pair.  
    3. If sum < c, move left++; if sum > c, move right--.  
    - Edge cases: No pair, duplicates, empty array.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

pair<int, int> findPair(vector<int>& arr, int c) {
    int left = 0, right = arr.size() - 1;
    while (left < right) {
        int sum = arr[left] + arr[right];
        if (sum == c) return {arr[left], arr[right]};
        if (sum < c) left++;
        else right--;
    }
    return {-1, -1};
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved; LeetCode #167.  
- Test with no solution, duplicates.

### Question 3: Remove Duplicates from Sorted Array

**Problem Statement**:  
Remove duplicates from a sorted array in-place.  
- **Example**: Input: [1, 1, 2, 2, 3] → Output: [1, 2, 3].

**Approach**:  
- **Brute Force**: Use set (O(n)).  
- **Optimal Approach**: Two-pointer in-place.  
  - Pointwise:  
    1. Use pointer i for unique elements, j for scanning.  
    2. If arr[j] != arr[i-1], place at i and increment i.  
    - Edge cases: Empty array, all duplicates, single element.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int removeDuplicates(vector<int>& arr) {
    if (arr.empty()) return 0;
    int i = 1;
    for (int j = 1; j < arr.size(); j++) {
        if (arr[j] != arr[i-1]) {
            arr[i] = arr[j];
            i++;
        }
    }
    return i;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved; LeetCode #26.  
- Test with all duplicates, single element.

### Question 4: Check if T2 is Subtree of T1

**Problem Statement**:  
Given a large binary tree T1 (millions of nodes) and a smaller tree T2 (hundreds of nodes), check if T2 is a subtree of T1.  
- **Example**: T1 = [1,2,3], T2 = [2] → Output: True.

**Approach**:  
- **Brute Force**: Check each T1 node as root for T2 match (O(n*m)).  
- **Optimal Approach**: Use tree serialization or recursive matching.  
  - Pointwise:  
    1. For each T1 node, check if subtree rooted at it matches T2.  
    2. Use recursive isSameTree to compare trees.  
    - Edge cases: Empty trees, T2 larger than T1, identical subtrees.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

bool isSameTree(TreeNode* t1, TreeNode* t2) {
    if (!t1 && !t2) return true;
    if (!t1 || !t2) return false;
    return t1->val == t2->val && isSameTree(t1->left, t2->left) && isSameTree(t1->right, t2->right);
}

bool isSubtree(TreeNode* t1, TreeNode* t2) {
    if (!t2) return true;
    if (!t1) return false;
    return isSameTree(t1, t2) || isSubtree(t1->left, t2) || isSubtree(t1->right, t2);
}
```

**Time Complexity**: O(n*m) (n = T1 nodes, m = T2 nodes).  
**Space Complexity**: O(h) for recursion (h = height).  
**Notes**:  
- Solved; LeetCode #572.  
- Test with large T1, small T2.

**Coding Round Performance**:  
- Solved all 4 questions despite time constraints.  
- Advanced to Technical Interview 1.

## Technical Interview 1

**Duration**: Not specified, likely 45-60 minutes.  
**Interviewer**: Focused on platforms, Linux, memory, OOPS, system design.

### Question 5: Platforms Used

**Problem Statement**:  
- Which platforms do you use?

**Sample Answer**:  
- "I’ve worked on Linux for development, Android for mobile apps, and cloud platforms like AWS for deploying web apps. I’m comfortable with command-line tools and IDEs like VS Code."

**Notes**:  
- Highlighted Linux, Android experience.  
- Tip: Mention relevant platforms (e.g., Linux for Morgan Stanley’s systems).

### Questions 6-11: Linux Commands and Memory Management

**Problem Statement**:  
- 6. Linux commands.  
- 7. Kill a process.  
- 8. Send specific signal with kill.  
- 9. See processes by specific user.  
- 10. Check memory utilization of processes.  
- 11. Check CPU utilization of processes (highest consumer).

**Approach**:  
- **Linux Commands**: `ls`, `cd`, `grep`, `ps`, `top`.  
- **Kill Process**: `kill <pid>` or `killall <name>`.  
- **Specific Signal**: `kill -<signal> <pid>` (e.g., `kill -SIGTERM <pid>`).  
- **Processes by User**: `ps -u <username>`.  
- **Memory Utilization**: `top` or `ps aux --sort=-%mem`.  
- **CPU Utilization**: `top` or `ps aux --sort=-%cpu`.  
- **Edge Cases**: Invalid PID, permission issues, multiple users.

**Notes**:  
- Answered all Linux questions.  
- Resources: GFG Linux Commands, Linux man pages.  
- Tip: Practice common commands, sorting options.

### Question 12: Internship Project

**Problem Statement**:  
- Explain your internship project.

**Sample Answer**:  
- "During my internship, I built a real-time analytics dashboard using NodeJS and MongoDB. Optimized data retrieval with indexing, reduced latency by 30% using caching."

**Notes**:  
- Discussed technical details.  
- Tip: Highlight impact, challenges overcome.

### Question 13: Android Experience

**Problem Statement**:  
- What have you done in Android?

**Sample Answer**:  
- "Developed an Android app for task management using Java, integrated SQLite for local storage, and implemented push notifications with Firebase."

**Notes**:  
- Tied to mobile development.  
- Tip: Focus on relevant features (e.g., UI, APIs).

### Question 14: Memory Allocation Loop

**Problem Statement**:  
- How many times does `while(1) { void* a = malloc(1024*1024); }` run on 2GB and 8GB RAM? How can a 4GB process run on 2GB RAM? Why use 8GB if 2GB suffices?

**Approach**:  
- **Loop Iterations**:  
  - 2GB RAM = 2*1024 MB = 2048 iterations (1MB per malloc).  
  - 8GB RAM = 8*1024 MB = 8192 iterations.  
  - Assumes no overhead, OS limits, or swapping.  
- **4GB on 2GB RAM**:  
  - Virtual memory: Process uses virtual address space, OS maps to physical RAM + swap.  
  - Paging and swapping allow larger processes.  
- **Why 8GB**:  
  - Faster performance, less swapping.  
  - Supports more processes, larger datasets.  
- **Edge Cases**: Memory fragmentation, OS overhead.

**Notes**:  
- Answered with virtual memory explanation.  
- Tip: Study OS memory management (GFG).

### Question 15: Load Balancing Algorithm

**Problem Statement**:  
- Given n servers and percentage distribution for messages, design an algorithm to assign a new message to a server.

**Approach**:  
- **Weighted Round-Robin**:  
  - Assign weights based on percentages (e.g., 50%, 30%, 20%).  
  - Use cumulative weights to select server.  
- **Algorithm**:  
  1. Store percentages as weights.  
  2. Generate random number or use round-robin counter.  
  3. Map to server based on weight range.  
- **Edge Cases**: Uneven percentages, single server.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int selectServer(vector<double>& weights) {
    double total = accumulate(weights.begin(), weights.end(), 0.0);
    double r = (double)rand() / RAND_MAX * total;
    double sum = 0;
    for (int i = 0; i < weights.size(); i++) {
        sum += weights[i];
        if (r <= sum) return i;
    }
    return weights.size() - 1;
}
```

**Time Complexity**: O(n) per selection.  
**Space Complexity**: O(1).  
**Notes**:  
- Proposed weighted random selection.  
- Tip: Study load balancing algorithms (GFG).

### Question 16: Copy Constructor and Reference

**Problem Statement**:  
- What functions are automatically provided in a class? Write copy constructor signature. Why use reference?

**Approach**:  
- **Default Functions**: Constructor, destructor, copy constructor, copy assignment, move (C++11).  
- **Copy Constructor**: `ClassName(const ClassName& other)`.  
- **Why Reference**: Avoids copying object, prevents infinite recursion in copy constructor.  
- **Example**: Copy constructor for deep copy.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

class MyClass {
    int* data;
public:
    MyClass(int x) { data = new int(x); }
    MyClass(const MyClass& other) { data = new int(*other.data); } // Copy constructor
    ~MyClass() { delete data; }
};
```

**Notes**:  
- Answered with signature, explained reference.  
- Tip: Study C++ default functions (GFG).

### Question 17: Glass-Steagall Act

**Problem Statement**:  
- Asked about Glass-Steagall Act, led to 10-15 minute discussion.

**Approach**:  
- **Glass-Steagall**: 1933 US law separating commercial and investment banking, led to Morgan Stanley’s formation.  
- **Discussion**: Explained historical context, its repeal, and Morgan Stanley’s origin as investment bank.

**Notes**:  
- Candidate-initiated discussion, showed interest.  
- Tip: Research Morgan Stanley’s history.

**Technical Interview 1 Performance**:  
- Answered most questions, strong Linux and project discussion.  
- 9/21 shortlisted for Group Activity.

## Group Activity

**Duration**: Not specified, likely 20-30 minutes.  
**Task**: Two groups, create a business ethics story using initial and additional images. Each member explains their picture’s role.

**Approach**:  
- **Initial Story**:  
  - **Theme**: Business ethics (e.g., integrity in a fintech startup).  
  - **Images**: Represent product, team, ethical issue (e.g., data misuse).  
  - **Plot**: Startup resists unethical shortcut, builds trust.  
- **Additional Images**:  
  - Adapted story to include new elements (e.g., regulators, competitors).  
  - New Plot: Startup navigates scrutiny, upholds ethics.  
- **Contributions**:  
  - Used personal image to depict ethical decision, contributed to plot, presented.  
- **Strategy**:  
  1. Assign roles (e.g., storyteller, visualizer).  
  2. Integrate all images into cohesive narrative.  
  3. Communicate clearly, adapt to new images.

**Notes**:  
- Tested teamwork, communication, adaptability.  
- Tip: Practice group storytelling, quick thinking.

## Technical Interview 2

**Duration**: Not specified, likely 45-60 minutes.  
**Interviewer**: Focused on system design, algorithms, SQL, design patterns.

### Question 18: Reservation System Design

**Problem Statement**:  
- Design a reservation system, handle concurrent seat bookings (e.g., two users see same seat). Discuss transactions, locking, observer pattern.

**Approach**:  
- **Database Design**:  
  - Tables: `Seats(id, status)`, `Bookings(id, user_id, seat_id, timestamp)`.  
  - Status: Available, Reserved, Booked.  
- **Concurrency Handling**:  
  - **Locking**: Lock seat row during booking (e.g., `SELECT FOR UPDATE`).  
  - **Transactions**: Ensure atomicity (e.g., reserve → payment → confirm).  
  - **ATM Analogy**: Lock account during withdrawal, similar to seat locking.  
- **Observer Pattern**: Notify users of seat status changes (e.g., unavailable).  
- **Issues**:  
  - Deadlocks, long lock waits.  
  - Solution: Timeout locks, optimistic locking.  
- **Edge Cases**: Concurrent bookings, network delays, partial bookings.

**Code Snippet (Java - Transaction Example)**:  
```java
class ReservationSystem {
    void bookSeat(int seatId, int userId) {
        // Begin transaction
        try {
            // Lock seat (SELECT FOR UPDATE)
            Seat seat = db.query("SELECT * FROM Seats WHERE id = ? AND status = 'Available' FOR UPDATE", seatId);
            if (seat == null) throw new Exception("Seat unavailable");
            // Update status
            db.execute("UPDATE Seats SET status = 'Reserved' WHERE id = ?", seatId);
            // Insert booking
            db.execute("INSERT INTO Bookings (user_id, seat_id) VALUES (?, ?)", userId, seatId);
            // Commit transaction
        } catch (Exception e) {
            // Rollback transaction
            throw e;
        }
    }
}
```

**Notes**:  
- Iteratively improved design, discussed locking.  
- Tip: Study database transactions, concurrency (GFG System Design).

### Questions 19-20: Design Patterns and Observer Pattern

**Problem Statement**:  
- Explain design patterns and observer pattern.

**Approach**:  
- **Design Patterns**: Reusable solutions (e.g., Singleton, Factory, Observer).  
- **Observer Pattern**:  
  - One-to-many dependency, subjects notify observers of state changes.  
  - Example: Seat status updates notify users.  
- **Use Case**: Real-time systems (e.g., stock price updates).

**Notes**:  
- Explained with reservation system context.  
- Tip: Study GOF patterns (GFG, Refactoring Guru).

### Question 21: 12 Balls Puzzle

**Problem Statement**:  
- Given 12 balls, one is defective (lighter/heavier), find defective ball and defect type in 3 weighings using a balance scale.

**Approach**:  
- Divide into 3 groups of 4 balls.  
- **Weighing 1**: Compare 4 vs. 4.  
  - If equal: Defective in remaining 4.  
  - If unequal: Defective in 8 (note heavier/lighter side).  
- **Weighing 2/3**: Narrow down using subsets, track lighter/heavier.  
- **Edge Cases**: Identify ball and defect type (lighter/heavier).

**Notes**:  
- Solved with standard approach.  
- Tip: Practice logic puzzles (GFG).

### Question 22: Queue Using Two Stacks (O(1) Enqueue/Dequeue)

**Problem Statement**:  
- Implement a queue using two stacks with O(1) best-case enqueue and dequeue.

**Approach**:  
- **Stacks**: One for enqueue (s1), one for dequeue (s2).  
- **Enqueue**: Push to s1 (O(1)).  
- **Dequeue**: If s2 empty, pop all from s1 to s2 (O(n)), then pop s2 (O(1)).  
- **Best Case**: Enqueue always O(1), dequeue O(1) if s2 non-empty.  
- **Edge Cases**: Empty queue, single element.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

class Queue {
    stack<int> s1, s2;
public:
    void enqueue(int x) {
        s1.push(x);
    }
    int dequeue() {
        if (s2.empty()) {
            while (!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
        if (s2.empty()) throw runtime_error("Queue empty");
        int x = s2.top();
        s2.pop();
        return x;
    }
};
```

**Time Complexity**: Enqueue O(1), Dequeue O(1) amortized.  
**Space Complexity**: O(n).  
**Notes**:  
- Achieved O(1) best case.  
- LeetCode #232. Test empty queue.

### Question 23: SQL Queries

**Problem Statement**:  
- Given tables `Student(sid,…)`, `Class(cid,…)`, `Student_class(sid,cid)`:  
  1. Find student names taking no class (no subqueries).  
  2. Find students taking more than one class.

**Approach**:  
- **No Class**:  
  - Use LEFT JOIN with NULL check (no subqueries).  
  - Query: `SELECT s.name FROM Student s LEFT JOIN Student_class sc ON s.sid = sc.sid WHERE sc.cid IS NULL`.  
- **More Than One Class**:  
  - Group by sid, count classes.  
  - Query: `SELECT s.name FROM Student s JOIN Student_class sc ON s.sid = sc.sid GROUP BY s.sid, s.name HAVING COUNT(sc.cid) > 1`.  
- **Edge Cases**: Empty tables, no enrollments.

**Notes**:  
- Avoided subqueries, used joins.  
- Tip: Practice SQL joins (GFG, LeetCode SQL).

**Technical Interview 2 Performance**:  
- Struggled with reservation system, strong on others.  
- Advanced to HR Round.

## HR Round

**Duration**: Not specified, likely 15-30 minutes.  
**Interviewer**: Focused on personal background, projects, threading.

### Question 24: Tell Me About Yourself

**Problem Statement**:  
- Introduce yourself.

**Sample Answer**:  
- **Situation**: "I’m a CS student passionate about system design and coding."  
- **Task**: "I’ve worked on scalable systems during my internship."  
- **Action**: "Built a NodeJS analytics dashboard, optimized with Redis, and developed Android apps."  
- **Result**: "Ready to contribute to Morgan Stanley’s tech solutions."

**Notes**:  
- Kept concise, technical focus.  
- Tip: Tailor to role, highlight projects.

### Question 25: Internship Project

**Problem Statement**:  
- Explain your internship project.

**Sample Answer**:  
- Same as Technical Interview 1 (Q12). Focused on impact, scalability.

**Notes**:  
- Reinforced earlier answer.  
- Tip: Be consistent across rounds.

### Question 26: Other Project

**Problem Statement**:  
- Explain a project other than internship.

**Sample Answer**:  
- "Built a Java-based booking system with classes for User, Booking, and Payment. Used inheritance and polymorphism to handle different user types and payment methods."

**Notes**:  
- Highlighted OOP concepts.  
- Tip: Choose projects with technical depth.

### Question 27: Extracurricular Activities and Awards

**Problem Statement**:  
- Explain extracurriculars and awards on resume.

**Sample Answer**:  
- **Situation**: "Participated in hackathons and college tech clubs."  
- **Task**: "Led a team to win a national coding competition."  
- **Action**: "Developed a real-time chat app, coordinated team tasks."  
- **Result**: "Won 1st place, earned leadership award."

**Notes**:  
- Clarified awards’ significance.  
- Tip: Quantify achievements, link to skills.

### Question 28: Distinct Product Names with Threading

**Problem Statement**:  
- Given an array of Product objects (name, attributes), find distinct product names. How to use threading to improve performance? Handle multiple arrays.

**Approach**:  
- **Distinct Names**:  
  - Use `set` to store unique names (O(n)).  
  - Java: `HashSet` with `hashCode` for Product names.  
- **Threading**:  
  - Single Array: Split array, use two threads (forward/backward) to populate global set with mutex.  
  - Multiple Arrays: Assign each array to a thread, merge sets.  
- **HashSet**: Uses `hashCode()` for strings, custom if Product overrides.  
- **Edge Cases**: Empty array, duplicate names, thread conflicts.

**Code Snippet (Java - Threading Example)**:  
```java
import java.util.*;

class Product {
    String name;
    Product(String name) { this.name = name; }
    public int hashCode() { return name.hashCode(); }
    public boolean equals(Object o) {
        if (!(o instanceof Product)) return false;
        return name.equals(((Product)o).name);
    }
}

class ProductProcessor {
    Set<String> uniqueNames = Collections.synchronizedSet(new HashSet<>());
    
    void processArray(List<Product> products, int start, int end) {
        for (int i = start; i < end; i++) {
            uniqueNames.add(products.get(i).name);
        }
    }

    Set<String> getUniqueNames(List<Product> products) {
        int mid = products.size() / 2;
        Thread t1 = new Thread(() -> processArray(products, 0, mid));
        Thread t2 = new Thread(() -> processArray(products, mid, products.size()));
        t1.start(); t2.start();
        try {
            t1.join(); t2.join();
        } catch (InterruptedException e) {}
        return uniqueNames;
    }
}
```

**Time Complexity**: O(n) for single array, O(n/k) with k threads ideally.  
**Space Complexity**: O(n) for set.  
**Notes**:  
- Discussed threading, HashSet; didn’t know `hashCode`.  
- Tip: Study Java collections, threading (GFG).

### Question 29: Questions for Interviewer

**Problem Statement**:  
- Questions for the interviewer about frameworks, PPT engagement.

**Sample Answer**:  
- "What frameworks does Morgan Stanley use for real-time systems? Why wasn’t I more engaged in the PPT?" (Interviewer explained frameworks for 15 minutes, encouraged PPT questions.)

**Notes**:  
- Showed interest, sparked discussion.  
- Tip: Ask about tech stack, team culture.

**HR Round Performance**:  
- Strong answers, engaging discussion.  
- Selection not specified, but candidate advanced.

## Key Takeaways and Preparation Tips

- **Practice DSA**: Solve medium problems on LeetCode, GFG (anagrams, trees, two-pointer).  
- **System Design**: Master LLD (e.g., reservation system), concurrency (locking, transactions).  
- **OS/Linux**: Study Linux commands (`ps`, `top`, `kill`), memory management (GFG OS Notes).  
- **OOPS**: Understand copy constructors, design patterns (observer).  
- **SQL**: Practice joins, avoid subqueries (LeetCode SQL, GFG).  
- **Aptitude**: Focus on probability, combinatorics, puzzles (RS Aggarwal).  
- **Group Activity**: Practice teamwork, storytelling under pressure.  
- **HR Prep**: Use STAR method, highlight projects, extracurriculars.  
- **Resources**:  
  - **Coding**: LeetCode, GFG, InterviewBit.  
  - **System Design**: Gaurav Sen, GFG.  
  - **OS/Linux**: G