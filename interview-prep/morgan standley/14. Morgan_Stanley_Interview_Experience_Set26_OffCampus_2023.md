# Morgan Stanley Interview Experience | Set 26 (Off-Campus) 2023

This document details the **Morgan Stanley Interview Experience (Off-Campus) Set 26**, shared on July 26, 2025, for a Technology Analyst role. The candidate applied off-campus, participated in a 24-hour HackerRank coding contest, and progressed through five interview rounds (Skype, two Technical, Professional Fitment, HR). The candidate ranked under 150 in the contest, was among the top 150 selected, and excelled in interviews by combining technical skills with confident communication. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers for behavioral questions.

Let’s get into it, bruh—this is your ultimate guide to acing Morgan Stanley’s off-campus gauntlet!

## Round 1: Online Coding Contest

**Platform**: HackerRank, 24-hour window.  
**Details**: 6 questions of increasing difficulty, top 150 candidates selected (candidate ranked <150).  
**Topics**: Likely array, string, graph, and dynamic programming (based on typical HackerRank contests).

**Approach**:  
- **Strategy**:  
  1. Solve easy questions first to secure points.  
  2. Tackle medium questions with standard DSA (e.g., two-pointer, BFS).  
  3. Optimize hard questions using DP or greedy approaches.  
- **Edge Cases**: Large inputs, edge constraints, time limits.

**Notes**:  
- Specific questions not provided; assumed standard DSA problems.  
- Resources: HackerRank, LeetCode, GFG.  
- Tip: Practice 6-question contests under 3 hours, aim for 4–5 solves.

## Round 2: Skype Round

**Duration**: ~45+ minutes, via Skype.  
**Focus**: Introduction, projects, OOPS, system design, DSA, multithreading.

### Question 1: Introduction and Projects

**Problem Statement**:  
- Tell me about yourself, briefly describe projects.

**Sample Answer**:  
- **Introduction**: “I’m a CSE graduate passionate about scalable systems and DSA, with experience in Java and C++.”  
- **Projects**: “Built a real-time chat app using React and NodeJS, optimized for low latency with WebSocket.”

**Notes**:  
- Kept concise, tied to role.  
- Tip: Prepare a 1-minute intro, highlight 1–2 impactful projects (GFG resume tips).

### Question 2: Polymorphism and Virtual Functions

**Problem Statement**:  
- Describe polymorphism, its types, virtual functions, virtual table (vtable), vptr, and vtable in inheritance hierarchy (static/dynamic, single/multiple).

**Approach**:  
- **Polymorphism**:  
  - **Compile-time**: Function/operator overloading.  
  - **Runtime**: Virtual functions via inheritance.  
- **Virtual Functions**:  
  - Allow runtime polymorphism using base class pointers/references.  
  - Implemented via **vtable** (virtual table), a static table per class storing function pointers.  
  - **vptr**: Pointer in each object to its class’s vtable, added by compiler.  
- **Vtable in Inheritance**:  
  - Single vtable per class, not per hierarchy.  
  - Static at compile-time, not dynamic.  
  - Derived class vtable overrides base class virtual functions.  
- **Code Example (Java)**:  
```java
class Animal {
    void sound() { System.out.println("Generic sound"); }
}
class Dog extends Animal {
    void sound() { System.out.println("Bark"); } // Overrides
}
class Main {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.sound(); // Bark (runtime polymorphism)
    }
}
```

**Notes**:  
- Explained with clarity.  
- Tip: Study OOPS, vtable internals (GFG C++, Java).

### Question 3: Design Facebook

**Problem Statement**:  
- Design Facebook, focusing on data structures and implementation approach.

**Approach**:  
- **Requirements**: User profiles, posts, friendships, news feed, messaging.  
- **Data Structures**:  
  - **User**: Graph node (ID, name, friends list).  
  - **Friendship**: Undirected graph (adjacency list).  
  - **Post**: List per user, stored in DB (e.g., MySQL).  
  - **News Feed**: Priority queue for recent posts from friends.  
  - **Messaging**: Queue for messages, indexed by userID.  
- **Implementation**:  
  - **Backend**: REST API with Java Spring, MySQL for storage, Redis for caching.  
  - **News Feed**: Fetch recent posts, merge using heap.  
  - **Scalability**: Sharding DB, caching frequent queries.  
- **Edge Cases**: High user load, privacy settings, deleted posts.

**Notes**:  
- Open-ended, focused on data structures.  
- Tip: Practice HLD (GFG System Design, System Design Primer).

### Question 4: Browser Tab Navigation

**Problem Statement**:  
- Design a system to track browser tabs, returning to the last visited tab when one is closed. Support new tabs.  
- **Example**: Tabs: [youtube.com, google.com, yahoo.com], current: google.com, close google.com → return to yahoo.com.

**Approach**:  
- **Data Structure**: Stack to track tab history, list for active tabs.  
- **Implementation**:  
  - **Open Tab**: Add to tab list, push to history stack.  
  - **Switch Tab**: Push new tab to history stack.  
  - **Close Tab**: Remove from tab list, pop history stack, return top tab.  
- **Edge Cases**: Single tab, empty history, new tab.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

class Browser {
    list<string> tabs; // Active tabs
    stack<string> history; // Last visited tabs
public:
    void openTab(string url) {
        tabs.push_back(url);
        history.push(url);
    }
    void switchTab(string url) {
        if (find(tabs.begin(), tabs.end(), url) != tabs.end()) {
            history.push(url);
        }
    }
    string closeTab(string url) {
        tabs.remove(url);
        while (!history.empty() && find(tabs.begin(), tabs.end(), history.top()) == tabs.end()) {
            history.pop();
        }
        return history.empty() ? "" : history.top();
    }
};
```

**Time Complexity**: O(n) for list operations.  
**Space Complexity**: O(n) for tabs/history.  
**Notes**:  
- Designed efficiently.  
- Tip: Practice stack-based problems (GFG Stack).

### Question 5: LRU Cache Implementation

**Problem Statement**:  
- Implement a Least Recently Used (LRU) cache.  
- **Example**: Capacity=2, Operations: put(1,1), put(2,2), get(1), put(3,3) → Evict 2, return 1.  
- **Link**: [LeetCode #146](https://leetcode.com/problems/lru-cache/).

**Approach**:  
- **Data Structures**: HashMap (key-value), Doubly Linked List (order).  
- **Implementation**:  
  - **Get**: Return value, move key to front (recent).  
  - **Put**: Add/update key-value, move to front, evict least recent if capacity exceeded.  
- **Edge Cases**: Empty cache, capacity=1.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

class LRUCache {
    int capacity;
    unordered_map<int, list<pair<int, int>>::iterator> map;
    list<pair<int, int>> dll; // key, value
public:
    LRUCache(int cap) : capacity(cap) {}
    int get(int key) {
        if (map.find(key) == map.end()) return -1;
        dll.splice(dll.begin(), dll, map[key]);
        return map[key]->second;
    }
    void put(int key, int value) {
        if (map.find(key) != map.end()) {
            dll.erase(map[key]);
        } else if (dll.size() >= capacity) {
            map.erase(dll.back().first);
            dll.pop_back();
        }
        dll.push_front({key, value});
        map[key] = dll.begin();
    }
};
```

**Time Complexity**: O(1) for get/put.  
**Space Complexity**: O(capacity).  
**Notes**:  
- Implemented correctly.  
- LeetCode #146. Test capacity=1, frequent updates.

### Question 6: Multithreading Scenarios

**Problem Statement**:  
- Explain scenarios where multithreading is beneficial.

**Approach**:  
- **Scenarios**:  
  - **Parallel Tasks**: E.g., web server handling multiple requests.  
  - **I/O Bound**: E.g., file downloads with concurrent threads.  
  - **CPU Bound**: E.g., matrix multiplication with parallel processing.  
- **Benefits**: Improved performance, responsiveness.  
- **Edge Cases**: Thread contention, deadlocks.

**Notes**:  
- Discussed practical scenarios.  
- Tip: Study threading basics (GFG OS).

**Skype Round Performance**:  
- Handled all questions well, advanced after 7 days.

## Round 3: Technical Round 1

**Duration**: ~45 minutes, face-to-face.  
**Focus**: Coding, algorithmic thinking.

### Question 7: Form Palindrome from String

**Problem Statement**:  
- Form a palindrome by rearranging characters of a given string.  
- **Example**: Input: "aabb" → Output: "abba".  
- **Constraints**: Return any valid palindrome or empty string if impossible.

**Approach**:  
- **Brute Force**: Generate permutations, check palindrome (O(n!)).  
- **Optimal Approach**: Frequency counting.  
  - Pointwise:  
    1. Count character frequencies.  
    2. Check if at most one char has odd frequency.  
    3. Construct palindrome: half of even counts + odd char (if any) + reverse.  
    - Edge cases: Empty string, no palindrome possible.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

string formPalindrome(string s) {
    vector<int> freq(26, 0);
    for (char c : s) freq[c - 'a']++;
    int oddCount = 0;
    char oddChar = 0;
    for (int i = 0; i < 26; i++) {
        if (freq[i] % 2) {
            oddCount++;
            oddChar = i + 'a';
        }
    }
    if (oddCount > 1) return "";
    string firstHalf;
    for (int i = 0; i < 26; i++) {
        firstHalf += string(freq[i] / 2, i + 'a');
    }
    string result = firstHalf;
    if (oddCount) result += oddChar;
    reverse(firstHalf.begin(), firstHalf.end());
    result += firstHalf;
    return result;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1) (fixed alphabet).  
**Notes**:  
- Solved correctly.  
- GFG “Form Palindrome.” Test odd-length, impossible cases.

### Question 8: Factorial (Recursive vs. Iterative)

**Problem Statement**:  
- Write recursive and iterative code for factorial, compare which is better.

**Approach**:  
- **Recursive**: Simple but stack overflow for large n.  
- **Iterative**: Loop-based, better space complexity.  
- **Comparison**: Iterative better for large inputs (O(1) space vs. O(n) stack).  
- **Edge Cases**: n=0, negative n.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

long long factorialRecursive(int n) {
    if (n <= 1) return 1;
    return n * factorialRecursive(n - 1);
}

long long factorialIterative(int n) {
    long long result = 1;
    for (int i = 2; i <= n; i++) result *= i;
    return result;
}
```

**Time Complexity**: O(n) for both.  
**Space Complexity**: O(n) (recursive), O(1) (iterative).  
**Notes**:  
- Explained iterative as better for scalability.  
- GFG “Factorial.” Test n=0, large n.

### Question 9: Next Higher Number

**Problem Statement**:  
- Given a number as an array of digits, find the next higher number.  
- **Example**: Input: [4,9,5,5] → Output: [5,4,5,9].  
- **Link**: [LeetCode #556](https://leetcode.com/problems/next-greater-element-iii/).

**Approach**:  
- **Brute Force**: Generate permutations, find next (O(n!)).  
- **Optimal Approach**: Next permutation algorithm.  
  - Pointwise:  
    1. Find first digit from right that is smaller than next (i).  
    2. Find smallest digit after i greater than arr[i].  
    3. Swap them, reverse digits after i.  
    - Edge cases: Largest number, single digit.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> nextHigherNumber(vector<int>& arr) {
    int n = arr.size(), i = n - 2;
    while (i >= 0 && arr[i] >= arr[i + 1]) i--;
    if (i < 0) return {};
    int j = n - 1;
    while (j > i && arr[j] <= arr[i]) j--;
    swap(arr[i], arr[j]);
    reverse(arr.begin() + i + 1, arr.end());
    return arr;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved correctly.  
- LeetCode #31 variant. Test [9,9], [1].

## Round 4: Technical Round 2

**Duration**: ~45 minutes, face-to-face.  
**Focus**: Projects, data structures.

### Question 10: Project Discussion

**Problem Statement**:  
- Briefly describe projects.

**Sample Answer**:  
- “Developed a scalable e-commerce platform using Java Spring and MySQL, optimized checkout with caching, reducing latency by 20%.”

**Notes**:  
- Highlighted technical impact.  
- Tip: Prepare 1–2 projects, focus on scalability.

### Question 11: Data Structures (Map)

**Problem Statement**:  
- Explain Map, what happens when inserting a value for an existing key.

**Approach**:  
- **Map**:  
  - Ordered (`std::map`): Red-black tree, O(log n) operations.  
  - Unordered (`std::unordered_map`): Hash table, O(1) average.  
- **Inserting Existing Key**:  
  - `map`: Updates value, no duplicate keys.  
  - `unordered_map`: Same behavior, updates value.  
- **Code Example (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

unordered_map<int, string> mp;
mp[1] = "first"; // Insert
mp[1] = "second"; // Update
```

**Notes**:  
- Explained clearly.  
- Tip: Study STL Map (GFG C++).

### Question 12: OOP vs. Procedural

**Problem Statement**:  
- Difference between Object-Oriented and Procedural programming.

**Approach**:  
- **OOP**:  
  - Focuses on objects, encapsulation, inheritance, polymorphism.  
  - Example: Java, C++ (classes).  
- **Procedural**:  
  - Focuses on procedures/functions, sequential execution.  
  - Example: C, Fortran.  
- **Key Differences**:  
  - OOP: Data-driven, reusable code.  
  - Procedural: Function-driven, less modular.  

**Notes**:  
- Answered well.  
- Tip: Study OOP concepts (GFG Java).

### Question 13: Stack vs. Heap

**Problem Statement**:  
- Explain stack and heap, their memory layout.

**Approach**:  
- **Stack**:  
  - LIFO, fixed-size, stores local variables, function calls.  
  - Fast, managed automatically.  
- **Heap**:  
  - Dynamic memory, allocated via `new`/`malloc`.  
  - Slower, manual management (C++).  
- **Memory Layout**:  
  - Stack: Grows downward, per thread.  
  - Heap: Grows upward, shared across program.  

**Notes**:  
- Explained memory layout.  
- Tip: Study memory management (GFG OS).

### Question 14: Linked List vs. Array

**Problem Statement**:  
- Difference between linked list and array, when to use each.

**Approach**:  
- **Linked List**:  
  - Dynamic size, O(1) insertion/deletion, non-contiguous.  
  - Use: Frequent insertions/deletions (e.g., queue).  
- **Array**:  
  - Fixed size, O(1) access, contiguous.  
  - Use: Random access, static size (e.g., lookup table).  
- **Edge Cases**: Memory fragmentation, large datasets.

**Notes**:  
- Answered with scenarios.  
- Tip: Study data structures (GFG DSA).

## Round 5: Professional Fitment

**Duration**: ~45 minutes, face-to-face.  
**Focus**: Coding, HR questions.

### Question 15: Introduction

**Problem Statement**:  
- Introduce yourself.

**Sample Answer**:  
- **Situation**: “I’m a CSE professional with a passion for coding.”  
- **Task**: “Contribute to scalable systems.”  
- **Action**: “Built projects like a booking app, solved 200+ DSA problems.”  
- **Result**: “Gained expertise in C++, system design.”

**Notes**:  
- Aligned with role.  
- Tip: Tailor to Morgan Stanley’s tech focus.

### Question 16: Sorting and Max Increasing Subsequence

**Problem Statement**:  
- Find the maximum increasing subsequence (length or sum unspecified; assumed sum).  
- **Example**: Input: [10,9,2,5,3,7,101,18] → Output: 4 (2,3,7,18).

**Approach**:  
- **Sorting**: Sort array for preprocessing (O(n log n)).  
- **Optimal Approach**: Dynamic Programming for LIS.  
  - Pointwise:  
    1. Use DP array to store max sum of increasing subsequence ending at i.  
    2. For each i, check previous j where arr[j] < arr[i].  
    3. Update max sum.  
    - Edge cases: Single element, no increasing subsequence.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int maxIncreasingSubsequence(vector<int>& arr) {
    int n = arr.size();
    vector<int> dp(n, 0);
    dp[0] = arr[0];
    int maxSum = dp[0];
    for (int i = 1; i < n; i++) {
        dp[i] = arr[i];
        for (int j = 0; j < i; j++) {
            if (arr[j] < arr[i]) {
                dp[i] = max(dp[i], dp[j] + arr[i]);
            }
        }
        maxSum = max(maxSum, dp[i]);
    }
    return maxSum;
}
```

**Time Complexity**: O(n²).  
**Space Complexity**: O(n).  
**Notes**:  
- Solved on paper.  
- LeetCode #300 variant. Test single element, decreasing array.

### Question 17: National Problem to Solve

**Problem Statement**:  
- What one problem would you solve in the country?

**Sample Answer**:  
- **Situation**: “Digital divide in rural areas.”  
- **Task**: “Improve tech access.”  
- **Action**: “Develop low-cost learning platforms, leverage open-source tools.”  
- **Result**: “Empower education, bridge gap.”

**Notes**:  
- Showed social awareness.  
- Tip: Choose impactful, relevant problem.

### Question 18: Weakness and Improvement

**Problem Statement**:  
- What is your weakness, and how are you overcoming it?

**Sample Answer**:  
- **Situation**: “Struggled with time management.”  
- **Task**: “Improve efficiency.”  
- **Action**: “Adopted Pomodoro technique, prioritized tasks.”  
- **Result**: “Increased productivity by 30%.”

**Notes**:  
- Showed self-improvement.  
- Tip: Pick fixable weakness, show progress.

### Question 19: Leadership Experience

**Problem Statement**:  
- Describe leadership experience, hurdles, and solutions.

**Sample Answer**:  
- **Situation**: “Led a team in a hackathon.”  
- **Task**: “Deliver a web app under deadline.”  
- **Action**: “Assigned roles, resolved conflicts via meetings, mentored on DSA.”  
- **Result**: “Won second place, team bonded.”

**Notes**:  
- Highlighted leadership, teamwork.  
- Tip: Use STAR, emphasize impact.

### Question 20: Other Offers and Why Morgan Stanley

**Problem Statement**:  
- Do you have other offers? Why leave for Morgan Stanley?

**Sample Answer**:  
- **Situation**: “Have an offer from another tech firm.”  
- **Task**: “Justify joining Morgan Stanley.”  
- **Action**: “Morgan Stanley’s finance-tech innovation aligns with my skills in C++ and system design.”  
- **Result**: “Excited to contribute to cutting-edge platforms.”

**Notes**:  
- Showed alignment with company.  
- Tip: Research Morgan Stanley’s tech stack.

### Question 21: About Morgan Stanley

**Problem Statement**:  
- What do you know about Morgan Stanley? Any questions?

**Sample Answer**:  
- **Knowledge**: “Global leader in investment banking, leverages Java, C++ for trading systems, focuses on AI-driven analytics.”  
- **Question**: “What’s the most exciting tech project your team is working on?”

**Notes**:  
- Demonstrated research, engagement.  
- Tip: Read Morgan Stanley’s tech blogs.

## Round 6: HR Round

**Duration**: ~45 minutes.  
**Focus**: Behavioral, career goals.

### Question 22: Why Morgan Stanley?

**Problem Statement**:  
- Why Morgan Stanley? Is it for money or interest in finance?

**Sample Answer**:  
- **Situation**: “Passionate about tech in finance.”  
- **Task**: “Contribute to innovative systems.”  
- **Action**: “My C++ and system design skills match Morgan Stanley’s trading platforms.”  
- **Result**: “Excited to impact global finance, not just for money.”

**Notes**:  
- Emphasized passion over money.  
- Tip: Align with company’s mission.

### Question 23: Your Dream

**Problem Statement**:  
- What is your dream?

**Sample Answer**:  
- **Situation**: “Aspire to innovate in tech.”  
- **Task**: “Build impactful systems.”  
- **Action**: “Develop scalable, user-focused solutions like Morgan Stanley’s platforms.”  
- **Result**: “Create tech that transforms industries.”

**Notes**:  
- Showed ambition.  
- Tip: Tie dream to role.

### Question 24: Biggest Problem Faced

**Problem Statement**:  
- Describe the biggest problem you faced and how you tackled it.

**Sample Answer**:  
- **Situation**: “Faced server crashes in a live project.”  
- **Task**: “Ensure system stability.”  
- **Action**: “Debugged logs, implemented failover, optimized DB queries.”  
- **Result**: “Restored uptime, improved reliability by 25%.”

**Notes**:  
- Highlighted problem-solving.  
- Tip: Choose technical or teamwork challenge.

### Question 25: Five-Year Plan

**Problem Statement**:  
- Where do you see yourself in five years? Plan to switch to management?

**Sample Answer**:  
- **Situation**: “Aim to grow as a tech expert.”  
- **Task**: “Contribute to innovative systems.”  
- **Action**: “Deepen expertise in C++, explore AI, lead tech projects.”  
- **Result**: “Stay technical, no management switch planned.”

**Notes**:  
- Showed focus on tech.  
- Tip: Align with career goals.

### Question 26: Communication Skills

**Problem Statement**:  
- How do you rate your communication skills?

**Sample Answer**:  
- **Situation**: “Collaborated in team projects.”  
- **Task**: “Ensure clear communication.”  
- **Action**: “Led presentations, explained complex DSA to peers.”  
- **Result**: “Rated 8/10, improved via public speaking.”

**Notes**:  
- Showed self-awareness.  
- Tip: Quantify with examples.

### Question 27: Job Requirements

**Problem Statement**:  
- What are the requirements to succeed in this job?

**Sample Answer**:  
- **Situation**: “Tech Analyst role demands technical and soft skills.”  
- **Task**: “Identify key traits.”  
- **Action**: “Strong DSA, system design, teamwork, and adaptability.”  
- **Result**: “Prepared to excel with my C++ and project experience.”

**Notes**:  
- Aligned with role.  
- Tip: Research job description.

### Question 28: Project Discussion

**Problem Statement**:  
- Discuss one project briefly.

**Sample Answer**:  
- “Built a booking system with Java Spring, optimized DB queries, reduced latency by 20%.”

**Notes**:  
- Kept concise, impactful.  
- Tip: Focus on measurable outcomes.

### Question 29: Questions for Interviewer

**Problem Statement**:  
- Any questions for the interviewer?

**Sample Answer**:  
- “What’s the team culture like at Morgan Stanley?”

**Notes**:  
- Engaged interviewer.  
- Tip: Ask about team or tech stack.

**Outcome**:  
- Strong performance across rounds, offer received.

## Key Takeaways and Preparation Tips

- **Coding Contest**: Solve 4–5 questions in HackerRank contests (LeetCode, GFG).  
- **Technical Prep**:  
  - **DSA**: Master arrays, strings, trees, graphs, DP (LeetCode #146, #300).  
  - **OOPS**: Study polymorphism, virtual functions in C++/Java (GFG).  
  - **System Design**: Practice HLD (Facebook) and LLD (browser tabs) (System Design Primer).  
- **HR Prep**: Use STAR for leadership, challenges, career goals; research Morgan Stanley’s tech and culture.  
- **Resources**:  
  - **Coding**: LeetCode, GFG, HackerRank.  
  - **OOPS**: GFG C++, Java.  
  - **System Design**: GFG, System Design Primer.  
  - **HR**: Glassdoor behavioral questions.  
- **Interview Day**: Stay confident, explain thought process, tell stories (J.K. Rowling vibe!), manage energy across multiple rounds.  
- **General**: Morgan Stanley values communication, confidence, and teamwork as much as technical skills.

**Final Note**: Bring your A-game, tell epic stories, and stay chill, bruh—Morgan Stanley loves confident coders who vibe!