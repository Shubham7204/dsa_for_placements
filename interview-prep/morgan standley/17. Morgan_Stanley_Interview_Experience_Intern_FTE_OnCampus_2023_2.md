# Morgan Stanley Interview Experience | Internship & FTE (On-Campus) 2023

This document details the **Morgan Stanley Interview Experience for Internship and Full-Time Positions (On-Campus)**, shared on August 21, 2023, likely for students from CS/IT/EXTC branches. The process included three rounds: Online Coding (180 minutes, 3 problems), Technical Interview (90 minutes, 3 problems), and HR Round (60 minutes, 3 questions). The candidate performed well, solving all coding problems and excelling in technical/HR rounds, leading to selection. All coding questions are implemented in **C++**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers for behavioral questions.

Yo, bruh—this is your ultimate playbook to dominate Morgan Stanley’s on-campus gauntlet! Let’s dive in and crush it!

## Round 1: Online Coding Round

**Platform**: Likely HackerRank, 180 minutes.  
**Details**: 3 problems, medium difficulty, multiple test cases.  
**Outcome**: Top performers shortlisted (exact number not specified).

### Problem 1: Non-Decreasing Array

**Problem Statement**:  
- Given an integer array `ARR` of size `N`, check if it can become non-decreasing by modifying at most 1 element.  
- **Example**: Input: ARR=[4,2,3] → Output: true (modify 2 to 4); ARR=[4,2,1] → Output: false.  
- **Constraints**:  
  - 1 ≤ T ≤ 50  
  - 1 ≤ N ≤ 10^4  
  - -10^9 ≤ ARR[i] ≤ 10^9  
- **Link**: [LeetCode #665](https://leetcode.com/problems/non-decreasing-array/).

**Approach**:  
- **Brute Force**: Try modifying each element and check if array becomes non-decreasing (O(n^2)).  
- **Optimal Approach**: Single pass with one modification.  
  - Pointwise:  
    1. Count violations where ARR[i] > ARR[i+1].  
    2. If violations > 1, return false.  
    3. For one violation at i, try modifying ARR[i] to ARR[i+1] or ARR[i+1] to ARR[i].  
    4. Check if resulting array is non-decreasing.  
  - Edge cases: N=1, N=2, large numbers.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

bool checkPossibility(vector<int>& arr) {
    int n = arr.size(), violations = 0;
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            violations++;
            if (violations > 1) return false;
            if (i > 0 && i < n - 2) {
                if (arr[i - 1] > arr[i + 1] && arr[i] > arr[i + 2]) return false;
            }
        }
    }
    return true;
}

void solve() {
    int T;
    cin >> T;
    while (T--) {
        int N;
        cin >> N;
        vector<int> arr(N);
        for (int i = 0; i < N; i++) cin >> arr[i];
        cout << (checkPossibility(arr) ? "true" : "false") << endl;
    }
}
```

**Time Complexity**: O(n) per test case.  
**Space Complexity**: O(1) (excluding input storage).  
**Notes**:  
- Solved correctly, handles edge cases.  
- Test [3,4,2,3], [1], [4,2,1].  
- Tip: Practice LeetCode #665, focus on violation logic.

### Problem 2: Minimum Stops Required to Reach Destination

**Problem Statement**:  
- Given an array `AIRPORTS` of size `N` (0s and 1s, 1 indicates an airport), find the minimum stops to reach position `X` on x-axis, with max jump `K` units per flight.  
- **Example**: Input: N=5, K=2, X=4, AIRPORTS=[1,0,1,0,1] → Output: 2 (stop at 2, then 4).  
- **Constraints**:  
  - 1 ≤ T ≤ 10  
  - 1 ≤ N ≤ 5000  
  - 1 ≤ K < N  
  - 1 ≤ X < N  
  - 0 ≤ AIRPORTS[i] ≤ 1  
- **Approach**: Dynamic Programming.

**Approach**:  
- **Brute Force**: Try all possible jumps recursively (O(2^n)).  
- **Optimal Approach**: DP with greedy.  
  - Pointwise:  
    1. Use DP array where dp[i] = min stops to reach i.  
    2. For each airport i, try jumps to airports j where i+1 ≤ j ≤ i+K.  
    3. Update dp[j] = min(dp[j], dp[i] + 1).  
    4. Return dp[X] or -1 if unreachable.  
  - Edge cases: No airport at X, no valid path.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int minStops(vector<int>& airports, int K, int X) {
    int N = airports.size();
    vector<int> dp(N, INT_MAX);
    dp[0] = 0; // Start at 0
    for (int i = 0; i < N; i++) {
        if (airports[i] == 0 || dp[i] == INT_MAX) continue;
        for (int j = i + 1; j <= min(N - 1, i + K); j++) {
            if (airports[j] == 1) {
                dp[j] = min(dp[j], dp[i] + 1);
            }
        }
    }
    return dp[X] == INT_MAX ? -1 : dp[X];
}

void solve() {
    int T;
    cin >> T;
    while (T--) {
        int N, K, X;
        cin >> N >> K >> X;
        vector<int> airports(N);
        for (int i = 0; i < N; i++) cin >> airports[i];
        cout << minStops(airports, K, X) << endl;
    }
}
```

**Time Complexity**: O(N*K) per test case.  
**Space Complexity**: O(N).  
**Notes**:  
- Solved using DP, efficient for constraints.  
- Test AIRPORTS=[1,0,0,1], K=2, X=3.  
- Tip: Practice DP problems like LeetCode #45 (Jump Game II).

### Problem 3: Longest Balanced Substring

**Problem Statement**:  
- Given a string `STR` of ‘(‘ and ‘)’, find the length of the longest balanced substring.  
- **Example**: Input: STR="(()())" → Output: 6.  
- **Constraints**:  
  - 1 ≤ T ≤ 10  
  - 1 ≤ |STR| ≤ 5*10^4  
- **Link**: [LeetCode #32](https://leetcode.com/problems/longest-valid-parentheses/).

**Approach**:  
- **Brute Force**: Check all substrings for balance (O(n^3)).  
- **Optimal Approach**: Stack-based.  
  - Pointwise:  
    1. Use stack to track indices of ‘(‘.  
    2. For ‘)’, pop stack and compute length or mark start.  
    3. Track max length of valid substring.  
  - Edge cases: No valid substring, all ‘(‘ or ‘)’.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int longestBalancedSubstring(string s) {
    stack<int> st;
    st.push(-1);
    int maxLen = 0;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] == '(') {
            st.push(i);
        } else {
            st.pop();
            if (st.empty()) {
                st.push(i);
            } else {
                maxLen = max(maxLen, i - st.top());
            }
        }
    }
    return maxLen;
}

void solve() {
    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        cout << longestBalancedSubstring(s) << endl;
    }
}
```

**Time Complexity**: O(n) per test case.  
**Space Complexity**: O(n).  
**Notes**:  
- Solved using stack, efficient.  
- Test "((()", ")()".  
- Tip: Practice LeetCode #32, focus on stack logic.

## Round 2: Technical Interview

**Duration**: 90 minutes, Microsoft Teams.  
**Details**: 3 problems, medium difficulty.  
**Outcome**: Top performers shortlisted.

### Problem 4: Largest Tree Value

**Problem Statement**:  
- Given a binary tree with `N` nodes, find the largest value in each level.  
- **Example**: Input: [1,3,2,5,3,null,9] → Output: [1,3,9].  
- **Constraints**:  
  - 1 ≤ T ≤ 50  
  - 0 ≤ N ≤ 10^3  
  - 1 ≤ DATA ≤ 10^4  
- **Approach**: Pre-order traversal with level tracking.

**Approach**:  
- **Brute Force**: DFS with level map (O(n)).  
- **Optimal Approach**: BFS (level-order).  
  - Pointwise:  
    1. Use queue to process nodes level by level.  
    2. Track max value per level.  
    3. Output max values in order.  
  - Edge cases: Empty tree, single node.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

vector<int> largestValues(TreeNode* root) {
    if (!root) return {};
    vector<int> result;
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        int size = q.size(), maxVal = INT_MIN;
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front();
            q.pop();
            maxVal = max(maxVal, node->val);
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        result.push_back(maxVal);
    }
    return result;
}

void solve() {
    int T;
    cin >> T;
    while (T--) {
        // Input tree in level order (simplified for example)
        // Process and print result
        // Example assumes tree input handling
        vector<int> result = largestValues(/* root from input */);
        for (int val : result) cout << val << " ";
        cout << endl;
    }
}
```

**Time Complexity**: O(n) per test case.  
**Space Complexity**: O(w) (max width of tree).  
**Notes**:  
- Used BFS for efficiency.  
- Test [1], [1,2,3].  
- Tip: Practice LeetCode #515, focus on level-order traversal.

### Problem 5: Jump Game

**Problem Statement**:  
- Given an array `JUMP` of size `N`, determine if you can reach index `N` from index 1, with max jump length at each index.  
- **Example**: Input: JUMP=[2,3,1,1,4] → Output: "YES".  
- **Approach**: Backtracking (corrected to greedy).

**Approach**:  
- **Brute Force**: DFS/backtracking from index 1 (O(2^n)).  
- **Optimal Approach**: Greedy.  
  - Pointwise:  
    1. Track max reachable index starting from 1.  
    2. For each index i, update max reach as i + JUMP[i].  
    3. If max reach ≥ N, return "YES".  
  - Edge cases: N=1, unreachable end.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

string canReachEnd(vector<int>& jump) {
    int n = jump.size(), maxReach = 1;
    for (int i = 1; i <= min(maxReach, n); i++) {
        maxReach = max(maxReach, i + jump[i - 1]);
        if (maxReach >= n) return "YES";
    }
    return "NO";
}

void solve() {
    int N;
    cin >> N;
    vector<int> jump(N);
    for (int i = 0; i < N; i++) cin >> jump[i];
    cout << canReachEnd(jump) << endl;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Greedy approach faster than backtracking.  
- Test [1], [3,0,0].  
- Tip: Practice LeetCode #55, use greedy.

### Problem 6: Flip Game II

**Problem Statement**:  
- Given a string `STR` of ‘$’ and ‘*’, determine if Ninja can win by flipping two consecutive ‘*’ to ‘$’.  
- **Example**: Input: STR="**$" → Output: true (flip ** to $$).  
- **Constraints**:  
  - 1 ≤ T ≤ 100  
  - 1 ≤ |STR| ≤ 20  
- **Approach**: Game theory with backtracking.

**Approach**:  
- **Brute Force**: Try all possible flips recursively (O(2^n)).  
- **Optimal Approach**: Analyze winning condition.  
  - Pointwise:  
    1. If two consecutive ‘*’ exist, first player can flip and force win.  
    2. Use game theory: Check if any move leads to opponent’s loss.  
  - Edge cases: No ‘**’, single char.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

bool canWin(string s) {
    for (int i = 0; i < s.size() - 1; i++) {
        if (s[i] == '*' && s[i + 1] == '*') {
            string next = s.substr(0, i) + "$$" + s.substr(i + 2);
            if (!canWin(next)) return true;
        }
    }
    return false;
}

void solve() {
    int T;
    cin >> T;
    while (T--) {
        string s;
        cin >> s;
        cout << (canWin(s) ? "true" : "false") << endl;
    }
}
```

**Time Complexity**: O(2^n) (backtracking).  
**Space Complexity**: O(n) (recursion stack).  
**Notes**:  
- Solved using backtracking, small constraints allow it.  
- Test "*", "**$$".  
- Tip: Practice LeetCode #294, study game theory.

## Round 3: HR Round

**Duration**: 60 minutes, Microsoft Teams.  
**Details**: 3 basic HR questions, easy difficulty.  
**Outcome**: 6 students selected (4 internship + FTE, 2 internship).

### Problem 7: Introduce Yourself

**Problem Statement**:  
- Introduce yourself.

**Sample Answer**:  
- **Situation**: “I’m a final-year EXTC student passionate about coding.”  
- **Task**: “Showcase fit for Morgan Stanley.”  
- **Action**: “Built real-time analytics tools, solved 200+ LeetCode problems.”  
- **Result**: “Ready to contribute to Morgan Stanley’s tech stack.”

**Notes**:  
- Aligned with role.  
- Tip: Prepare 1-minute intro, tie to finance-tech (GFG HR).

### Problem 8: Strengths and Weaknesses

**Problem Statement**:  
- Discuss your strengths and weaknesses.

**Sample Answer**:  
- **Strengths**:  
  - **Situation**: “Worked on complex DSA problems.”  
  - **Task**: “Solve efficiently.”  
  - **Action**: “Mastered C++, optimized algorithms.”  
  - **Result**: “Solved 3/3 coding questions in Round 1.”  
- **Weaknesses**:  
  - **Situation**: “Struggled with time management.”  
  - **Task**: “Improve efficiency.”  
  - **Action**: “Adopted Pomodoro, prioritized tasks.”  
  - **Result**: “Increased productivity by 30%.”

**Notes**:  
- Showed self-awareness, improvement.  
- Tip: Use STAR, pick fixable weakness (JavaTpoint HR).

### Problem 9: Approach to Overcoming Weaknesses

**Problem Statement**:  
- Describe your approach to overcoming weaknesses.

**Sample Answer**:  
- **Situation**: “Faced challenges in public speaking.”  
- **Task**: “Improve communication for interviews.”  
- **Action**: “Joined Toastmasters, practiced mock interviews.”  
- **Result**: “Confidently presented projects in Round 2.”

**Notes**:  
- Reinforced improvement.  
- Tip: Link to professional growth (GFG HR).

## Key Takeaways and Preparation Tips

- **Online Coding**:  
  - Master medium-level problems (arrays, DP, stack).  
  - Practice LeetCode #665, #55, #32 for Round 1.  
  - Handle multiple test cases efficiently.  
- **Technical Interview**:  
  - Focus on tree traversal (LeetCode #515), greedy (LeetCode #55), game theory (LeetCode #294).  
  - Explain thought process clearly, optimize after brute force.  
- **HR Prep**:  
  - Use STAR for intro, strengths/weaknesses.  
  - Research Morgan Stanley’s finance-tech focus (careers.morganstanley.com).  
- **Resources**:  
  - **Coding**: LeetCode, GFG, InterviewBit.  
  - **Trees/Graphs**: GFG DSA, LeetCode Tree problems.  
  - **HR**: JavaTpoint, Glassdoor HR questions.  
- **Interview Day**: Stay calm, explain logic, ask questions (e.g., team projects).  
- **General**: Morgan Stanley values problem-solving and communication; show confidence and clarity.

**Final Note**: Code hard, vibe smart, and own the interview, bruh—Morgan Stanley digs coders who bring the heat!