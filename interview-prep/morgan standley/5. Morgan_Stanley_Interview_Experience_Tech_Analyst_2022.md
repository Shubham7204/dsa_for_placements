# Morgan Stanley Interview Experience for Technology Analyst (Off-Campus) 2022

This document details the **Morgan Stanley Interview Experience for Technology Analyst (Off-Campus) 2022**, applied in September 2021, with assessment in May 2022. The process included an SHL Online Assessment (Debugging, Coding, Aptitude) and three interview rounds (Technical DSA, System Design, HR). The candidate solved 2/3 coding questions completely (1 partially), most debugging and aptitude, and was selected. All coding questions are implemented in **C++**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers for behavioral/situational questions.

Let’s break it down, bruh—this is your blueprint to nail Morgan Stanley’s off-campus process!

## Online Assessment (OA)

The OA lasted ~80 minutes on the **SHL platform**, with Debugging, Coding (3 questions), and Aptitude sections. Language for coding could be changed between problems; for debugging, initial choice was fixed.

### Section 1: Debugging

**Problem Statement**:  
- Several snippets to fix by correcting logic, syntax, or implementing functions to pass test cases.
- Difficulty: Easy; candidate solved all except one.
- Note: Last problem easier in Java than C++.

**Approach**:  
- **Strategy**:  
  1. Read problem and test cases.  
  2. Fix syntax (e.g., missing semicolons).  
  3. Correct logic (e.g., off-by-one, wrong operators).  
  4. Implement function if missing.  
  5. Consider language-specific issues (e.g., C++ vs. Java).  
- **Edge Cases**: Null inputs, boundary values, output formats.

**Code Snippet (C++ Example)**:  
```cpp
// Example: Fix function to compute factorial (incorrect logic)
#include <bits/stdc++.h>
using namespace std;

// Incorrect code (given)
int factorial(int n) {
    int res = 0;  // Error: Initialized to 0
    for (int i = 1; i <= n; i++) {
        res *= i;  // Error: Multiplies 0
    }
    return res;
}

// Corrected code
int factorial(int n) {
    if (n <= 1) return 1;
    int res = 1;  // Fix: Initialize to 1
    for (int i = 2; i <= n; i++) {
        res *= i;
    }
    return res;
}
```

**Time Complexity**: O(n) for typical fixes.  
**Space Complexity**: O(1).  
**Notes**:  
- Solved all except one.  
- Tip: Choose language wisely (e.g., Java for strings). Practice on HackerRank debugging challenges. Test edge cases like n=0.

### Section 2: Coding Round

3 questions (2 easy-medium, 1 medium-hard), candidate solved 2 completely, 1 partially. Specifics not given, so reconstructed based on common Morgan Stanley questions (e.g., from similar experiences: Chemical Formula, Serialization, Graph DSU).

#### Question 1: Chemical Elements to Formula (Easy-Medium)

**Problem Statement**:  
Given unsorted array of element symbols, return sorted chemical formula with counts (e.g., ["Cl", "Mg", "Cl"] -> "Cl2Mg").

**Approach**:  
- **Brute Force**: Count with unordered_map, sort keys.  
- **Optimal Approach**: Use ordered map.  
  - Pointwise:  
    1. Count frequencies in map.  
    2. Iterate map, append symbol + count if >1.  
    - Edge cases: Empty array, single element.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

string getFormula(vector<string>& elements) {
    map<string, int> freq;
    for (const string& el : elements) freq[el]++;
    string res;
    for (const auto& p : freq) {
        res += p.first;
        if (p.second > 1) res += to_string(p.second);
    }
    return res;
}
```

**Time Complexity**: O(n log k), k = unique elements.  
**Space Complexity**: O(k).  
**Notes**:  
- Assumed as easy-medium; solved completely.  
- Practice string/maps. Test ["H", "O", "H"] -> "H2O".

#### Question 2: Binary Tree Serialization/Deserialization (Easy-Medium)

**Problem Statement**:  
Serialize/deserialize binary tree to/from string (pre-order, "N" for null).

**Approach**:  
- **Optimal Approach**: Recursive serialize/deserialize.  
  - Pointwise:  
    1. Serialize: value + "," + left + right, "N," for null.  
    2. Deserialize: Split string, recurse with index.  
    - Edge cases: Empty tree, single node.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

string serialize(TreeNode* root) {
    if (!root) return "N,";
    return to_string(root->val) + "," + serialize(root->left) + serialize(root->right);
}

TreeNode* deserialize(string data) {
    vector<string> tokens;
    stringstream ss(data);
    string token;
    while (getline(ss, token, ',')) tokens.push_back(token);
    int idx = 0;
    return helper(tokens, idx);
}

TreeNode* helper(vector<string>& tokens, int& idx) {
    if (tokens[idx] == "N") {
        idx++;
        return nullptr;
    }
    TreeNode* node = new TreeNode(stoi(tokens[idx++]));
    node->left = helper(tokens, idx);
    node->right = helper(tokens, idx);
    return node;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(n).  
**Notes**:  
- Assumed as easy-medium; solved completely.  
- LeetCode #297. Practice N-ary variations.

#### Question 3: Graph with Greedy + DSU (Medium-Hard)

**Problem Statement**:  
Given graph with edges/weights, find min cost to connect all nodes (MST, Kruskal with DSU).

**Approach**:  
- **Optimal Approach**: Kruskal's.  
  - Pointwise:  
    1. Sort edges by weight.  
    2. Use DSU to union non-cycle edges.  
    3. Sum weights if connected.  
    - Edge cases: Disconnected graph.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Edge {
    int u, v, w;
    bool operator<(const Edge& other) const { return w < other.w; }
};

class DSU {
    vector<int> parent, rank;
public:
    DSU(int n) : parent(n), rank(n, 0) { iota(parent.begin(), parent.end(), 0); }
    int find(int x) { return parent[x] == x ? x : parent[x] = find(parent[x]); }
    bool unite(int x, int y) {
        int px = find(x), py = find(y);
        if (px == py) return false;
        if (rank[px] < rank[py]) swap(px, py);
        parent[py] = px;
        if (rank[px] == rank[py]) rank[px]++;
        return true;
    }
};

int minCost(vector<Edge>& edges, int n) {
    sort(edges.begin(), edges.end());
    DSU dsu(n);
    int cost = 0, edgesUsed = 0;
    for (const auto& e : edges) {
        if (dsu.unite(e.u, e.v)) {
            cost += e.w;
            edgesUsed++;
            if (edgesUsed == n - 1) return cost;
        }
    }
    return -1;  // Not connected
}
```

**Time Complexity**: O(e log e).  
**Space Complexity**: O(n).  
**Notes**:  
- Assumed as medium-hard; solved partially.  
- LeetCode #1584. Practice DSU.

### Section 3: Aptitude

**Problem Statement**:  
- Medium-level aptitude questions (quants, reasoning).

**Approach**:  
- Practice quants, data interpretation.  
- Strategy: Prioritize easy questions, use elimination.

**Notes**:  
- Solved >70%.  
- Tip: SHL mocks for practice.

**OA Performance**:  
- Shortlisted after 1 month for interviews.

## Technical Interview Round 1 (DSA and Coding)

**Duration**: ~1 hour.  
**Interviewer**: Helpful, made candidate comfortable. Focused on coding, DSA, internship project.

### Question 4: Queue and Stack in O(1) Data Structure

**Problem Statement**:  
Design a data structure that supports Stack (push/pop) and Queue (enqueue/dequeue) operations in O(1) time.

**Approach**:  
- Use Doubly Linked List (DLL).  
  - Pointwise:  
    1. Head for queue dequeue/stack pop.  
    2. Tail for queue enqueue/stack push.  
    3. DLL nodes with prev/next for O(1) operations.  
  - Edge cases: Empty structure, single element.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int val;
    Node *prev, *next;
    Node(int v) : val(v), prev(nullptr), next(nullptr) {}
};

class StackQueue {
    Node *head, *tail;
public:
    StackQueue() : head(nullptr), tail(nullptr) {}
    void push(int val) {  // Stack push / Queue enqueue
        Node* newNode = new Node(val);
        if (!tail) head = tail = newNode;
        else {
            tail->next = newNode;
            newNode->prev = tail;
            tail = newNode;
        }
    }
    int pop() {  // Stack pop
        if (!tail) return -1;
        int val = tail->val;
        Node* temp = tail;
        tail = tail->prev;
        if (tail) tail->next = nullptr;
        else head = nullptr;
        delete temp;
        return val;
    }
    int dequeue() {  // Queue dequeue
        if (!head) return -1;
        int val = head->val;
        Node* temp = head;
        head = head->next;
        if (head) head->prev = nullptr;
        else tail = nullptr;
        delete temp;
        return val;
    }
};
```

**Time Complexity**: O(1) for all operations.  
**Space Complexity**: O(n) for nodes.  
**Notes**:  
- Used DLL; explained reasons (bidirectional links).  
- Tip: Discuss trade-offs (vs. array). Practice deque implementations.

### Question 5: Count Ways to Reach Nth Stair

**Problem Statement**:  
Count ways to reach nth stair with 1 or 2 steps at a time.  
- Input: n = 4  
- Output: 5 ({1,1,1,1}, {1,1,2}, {1,2,1}, {2,1,1}, {2,2}).

**Approach**:  
- **Brute Force**: Recursion (O(2^n)).  
- **Optimal Approach**: DP (Fibonacci-like).  
  - Pointwise:  
    1. dp[0] = 1, dp[1] = 1.  
    2. dp[i] = dp[i-1] + dp[i-2].  
    - Edge cases: n=0/1, large n (use modulo if needed).

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int countWays(int n) {
    if (n <= 1) return 1;
    vector<int> dp(n + 1);
    dp[0] = dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[i];
}
```

**Time Complexity**:  
- Brute: O(2^n).  
- Optimal: O(n).  
**Space Complexity**: O(n) (optimizable to O(1)).  
**Notes**:  
- Solved; GFG problem.  
- LeetCode #70 variant. Practice with k steps.

### Question 6: Jump Game

**Problem Statement**:  
Given array nums where nums[i] is max jump from i, check if can reach last index.  
- Input: [2,3,1,1,4] -> true  
- Input: [3,2,1,0,4] -> false  
- Constraints: 1 <= nums.length <= 10^4, 0 <= nums[i] <= 10^5.

**Approach**:  
- **Brute Force**: Recursion with memo (O(n^2)).  
- **Optimal Approach**: Greedy max reach.  
  - Pointwise:  
    1. Track max reach from current position.  
    2. Iterate: Update max reach.  
    3. If i > reach, return false.  
    - Edge cases: length=1, zeros blocking.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

bool canJump(vector<int>& nums) {
    int n = nums.size(), reach = 0;
    for (int i = 0; i < n && i <= reach; i++) {
        reach = max(reach, i + nums[i]);
        if (reach >= n - 1) return true;
    }
    return false;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved; LeetCode #55.  
- Practice Jump Game II (min jumps).

### Question 7: Internship Project Discussion

**Problem Statement**:  
- Discuss internship project, tech stack, reasons.

**Sample Answer**:  
- "My internship project was [e.g., trading dashboard] using Java for backend, React for frontend, and MongoDB for data. I chose Java for robustness in handling financial data, React for responsive UI, and MongoDB for flexible schema in dynamic markets. Challenges included real-time updates, solved with WebSockets."

**Notes**:  
- Explained tech with reasons, pros/cons.  
- Tip: Prepare for cross-questions on optimizations, alternatives.

## System Design Round 2

**Duration**: ~1 hour, discussion-style.  
**Focus**: Low-level design for BookMyShow (movie booking).

### Question 8: BookMyShow System Design

**Problem Statement**:  
Design LLD for BookMyShow with APIs: Search by City/Theatre/Movie, concurrency for seat booking.

**Approach**:  
- **Entities**: User, Movie, Theatre, Show, Seat, Booking.  
- **APIs**:  
  1. GET /search/city/{city}  
  2. GET /search/theatre/{theatre}  
  3. GET /search/movie/{movie}  
  4. POST /book/seat/{showId} (with concurrency).  
- **Database**: SQL (tables for entities, relationships).  
- **Concurrency**: Optimistic locking (check seat status before book), or DB transactions.  
- **Flow**: User searches shows, selects seat, books (lock seat, pay, confirm).  
- **Edge Cases**: Concurrent bookings, sold-out shows.

**Notes**:  
- Incorporated interviewer views. Discussed entities step-by-step.  
- Tip: Draw diagrams, discuss trade-offs (SQL vs. NoSQL). Resources: GFG System Design.

## HR Round 3

**Duration**: ~30 minutes, challenging with teamwork focus.

### Question 9: Teamwork Perspective

**Problem Statement**:  
- Questions on teamwork: Role in team, college projects, "what will you do" hypotheticals.

**Sample Answers**:  
- **Role in Team**:  
  - **Situation**: "In college projects, I often take the tech lead role."  
  - **Task**: "Coordinate tasks and ensure technical quality."  
  - **Action**: "I assign based on strengths, hold sync-ups, and help with debugging."  
  - **Result**: "Projects delivered on time with high grades."  
- **Hypothetical**: "If a teammate slacks, I'd discuss privately, understand issues, and reassign if needed."

**Notes**:  
- Avoid differing views in counters; be consistent.  
- Tip: Prepare STAR stories for teamwork, conflicts.

### Question 10: What If 2 Offers?

**Problem Statement**:  
- If you have 2 offers (Morgan Stanley and another), what would you do?

**Sample Answer**:  
- "I'd evaluate based on role, growth, tech stack, and culture. Morgan Stanley's innovation in finance aligns with my goals, but I'd weigh factors like location and compensation honestly."

**Notes**:  
- Gave frank answer; satisfied interviewer.  
- Tip: Be genuine, highlight positives about Morgan Stanley.

**Outcome**: Selected after 1 week.

## Final Tips

- **Think Out Loud**: Share process in coding/design.  
- **Clarify Questions**: Ask repeatedly if unclear.  
- **Be Yourself in HR**: Avoid faking; genuine answers work.  
- **Practice DSA**: LeetCode, GFG for coding.  
- **System Design**: Focus on LLD, concurrency.  
- **Resources**: SHL mocks for OA, GFG for interviews.