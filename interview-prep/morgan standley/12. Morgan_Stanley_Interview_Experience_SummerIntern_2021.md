# Morgan Stanley Interview Experience for Summer Internship 2021

This document details the **Morgan Stanley Interview Experience for Summer Internship 2021**, shared on October 13, 2020. Morgan Stanley visited the candidate’s college, offering a summer internship for the Analyst role (CGPA ≥ 7.5). From 150 shortlisted students, the process included an Online Round on the Aspiring Minds platform, followed by two Zoom-based interviews (Technical and HR + Technical). The candidate performed well in Aptitude, solved 2–3 debugging questions, 1 coding question, and was among 20 shortlisted for interviews, 6 for Round 3, and 4 final selects (including the candidate). All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers for behavioral questions.

Let’s dive in, bruh—this is your roadmap to crushing Morgan Stanley’s internship game!

## Online Round

The Online Round lasted 100 minutes on the Aspiring Minds platform, with three timed sections: Aptitude, Debugging, and Coding.

### Section 1: Aptitude

**Problem Statement**:  
- 10 questions, 20 minutes, easy to moderate difficulty.  
- Topics: Quantitative aptitude (e.g., percentages, probability), logical reasoning (e.g., puzzles).

**Approach**:  
- **Strategy**:  
  1. Solve numerical questions first (e.g., ratios, time-speed).  
  2. Use elimination for logical puzzles.  
  3. Verify units and conditions.  
- **Edge Cases**: Tricky wording, decimal precision.

**Notes**:  
- Performed well, solved most questions.  
- Resources: RS Aggarwal, GFG Aptitude.  
- Tip: Practice 15-minute aptitude sets, aim for 8/10.

### Section 2: Debugging

**Problem Statement**:  
- 7 questions, 20 minutes, language choice (C++ chosen).  
- Task: Fix syntax/logic errors in code snippets to pass test cases.  
- Topics: Loops, conditionals, basic algorithms.  
- Solved 2–3 questions.

**Approach**:  
- **Strategy**:  
  1. Identify syntax errors (e.g., missing semicolons, wrong operators).  
  2. Correct logical errors (e.g., incorrect bounds, conditionals).  
  3. Test mentally with edge inputs.  
- **Edge Cases**: Null inputs, uninitialized variables.

**Notes**:  
- Partial success, focus on speed needed.  
- Resources: GFG Debugging, HackerRank.  
- Tip: Practice 5-minute debug challenges, aim for 5/7.

### Section 3: Coding

**Duration**: 45 minutes, 3 medium-to-hard questions, C++ chosen, full code including main function required.

#### Question 1: Highest File Upload Rate Period

**Problem Statement**:  
- Given N hours of file upload rates and a target rate R, find the shortest consecutive period where the total upload rate ≥ R.  
- **Example**: Input: rates=[1,2,3,4], R=5 → Output: [2,3] (2+3=5, length=2).  
- **Constraints**: N ≤ 10^5, R ≤ 10^9.

**Approach**:  
- **Brute Force**: Check all subarrays (O(n²)).  
- **Optimal Approach**: Sliding window.  
  - Pointwise:  
    1. Initialize window with sum ≥ R.  
    2. Shrink window from left while sum ≥ R, track min length.  
    3. Slide window, update sum and min length.  
    - Edge cases: No valid period, single hour, R=0.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> findShortestPeriod(vector<int>& rates, long long R) {
    int n = rates.size(), minLen = n + 1, start = 0, end = 0;
    long long currSum = 0;
    for (int i = 0, j = 0; i < n; i++) {
        currSum += rates[i];
        while (currSum >= R && j <= i) {
            if (i - j + 1 < minLen) {
                minLen = i - j + 1;
                start = j;
                end = i;
            }
            currSum -= rates[j++];
        }
    }
    if (minLen > n) return {};
    return {start, end};
}

int main() {
    vector<int> rates = {1, 2, 3, 4};
    long long R = 5;
    auto result = findShortestPeriod(rates, R);
    for (int x : result) cout << x << " ";
    return 0;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved efficiently.  
- GFG “Sliding Window.” Test no valid period, large R.

#### Question 2: Coin Picker Game

**Problem Statement**:  
- Given N coins with values, two players pick same number of consecutive coins in same order. Second player’s order is reversed, and score is sum of products of corresponding coin values. Return max score (0 if negative).  
- **Example**: Input: coins=[1,2,3] → Output: 14 (pick all: 1*3 + 2*2 + 3*1 = 3+4+3).  
- **Constraints**: N ≤ 10^5.

**Approach**:  
- **Brute Force**: Try all subarrays, compute score (O(n²)).  
- **Optimal Approach**: Sliding window for max subarray length.  
  - Pointwise:  
    1. For each subarray length k, compute score by multiplying coins[i] with coins[i+k-1].  
    2. Track max score, return 0 if negative.  
    - Edge cases: Single coin, all negative values.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

long long maxTeamScore(vector<int>& coins) {
    int n = coins.size();
    long long maxScore = 0;
    for (int len = 1; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            long long score = 0;
            for (int j = 0; j < len; j++) {
                score += (long long)coins[i + j] * coins[i + len - 1 - j];
            }
            maxScore = max(maxScore, score);
        }
    }
    return maxScore < 0 ? 0 : maxScore;
}

int main() {
    vector<int> coins = {1, 2, 3};
    cout << maxTeamScore(coins);
    return 0;
}
```

**Time Complexity**: O(n³) (brute force; optimization possible with DP).  
**Space Complexity**: O(1).  
**Notes**:  
- Not solved in OT, included for completeness.  
- GFG “Array Manipulation.” Test negative coins, single coin.

#### Question 3: Maximum Score in Block Game

**Problem Statement**:  
- N blocks (1 to N) form a tree with N-1 edges, each with a point value. Start at block S, move to connected blocks until a leaf, compute product of points. Find max score.  
- **Example**: Input: N=3, edges=[[1,2],[1,3]], points=[2,3,4], S=1 → Output: 8 (1→3: 2*4).  
- **Constraints**: N ≤ 10^5.

**Approach**:  
- **Brute Force**: DFS all paths, compute product (O(2^n)).  
- **Optimal Approach**: DFS with max product tracking.  
  - Pointwise:  
    1. Build adjacency list from edges.  
    2. DFS from S, compute product along each path to leaf.  
    3. Track max product.  
    - Edge cases: Single node, negative points.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

long long maxScore(vector<vector<int>>& edges, vector<int>& points, int S) {
    int n = points.size();
    vector<vector<int>> adj(n + 1);
    for (auto& e : edges) {
        adj[e[0]].push_back(e[1]);
        adj[e[1]].push_back(e[0]);
    }
    long long maxProd = LLONG_MIN;
    function<void(int, int, long long)> dfs = [&](int node, int parent, long long prod) {
        prod *= points[node - 1];
        if (adj[node].size() == 1 && node != S) {
            maxProd = max(maxProd, prod);
            return;
        }
        for (int next : adj[node]) {
            if (next != parent) {
                dfs(next, node, prod);
            }
        }
    };
    dfs(S, 0, 1LL);
    return maxProd;
}

int main() {
    vector<vector<int>> edges = {{1, 2}, {1, 3}};
    vector<int> points = {2, 3, 4};
    int S = 1;
    cout << maxScore(edges, points, S);
    return 0;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(n) for recursion stack.  
**Notes**:  
- Not solved in OT, included for completeness.  
- GFG “Tree Path.” Test negative points, single node.

**Online Round Performance**:  
- Strong in Aptitude, 2–3 debugging, 1 coding question solved.  
- 20/150 shortlisted for interviews.

## Technical Interview (Round 2)

**Duration**: ~70 minutes, via Zoom.  
**Interviewer**: Focused on projects, OOPS, coding, Java features.

### Question 4: Project Discussion with OOPS

**Problem Statement**:  
- Discuss projects, explain how to implement one using OOPS concepts (25–30 minutes).

**Sample Answer**:  
- **Project**: “Built a booking app with Java backend.”  
- **OOPS Implementation (Java)**:  
  - **Encapsulation**: Private fields (e.g., `userID`, `bookingTime`) in `Booking` class.  
  - **Inheritance**: `PremiumUser` extends `User` for extra features.  
  - **Polymorphism**: Overriding `confirmBooking()` for different user types.  
  - **Abstraction**: Abstract `Payment` class for various methods.  
- **Code Example**:  
  ```java
  abstract class Payment {
      abstract void processPayment();
  }
  class Booking {
      private int bookingID;
      private String userID;
      public Booking(int id, String user) { bookingID = id; userID = user; }
      void confirmBooking(Payment payment) { payment.processPayment(); }
  }
  ```

**Notes**:  
- Discussed thoroughly, impressed interviewer.  
- Tip: Prepare 1–2 projects, map to OOPS (GFG Java).

### Question 5: Print Alternate Levels of Tree

**Problem Statement**:  
- Print nodes at alternate levels of a binary tree (e.g., level 0, 2, 4). Optimize using BFS.  
- **Example**: Input: [1,2,3,4,5] → Output: 1, 4, 5 (levels 0, 2).

**Approach**:  
- **Recursive (Initial)**: Print nodes at level k if k%2==0 (O(n)).  
- **BFS (Optimized)**: Use queue, track level, print if even.  
  - Pointwise:  
    1. Perform level-order traversal.  
    2. Track level, print nodes if level%2==0.  
    - Edge cases: Empty tree, single level.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

void printAlternateLevels(TreeNode* root) {
    if (!root) return;
    queue<TreeNode*> q;
    q.push(root);
    int level = 0;
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front(); q.pop();
            if (level % 2 == 0) cout << node->val << " ";
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        level++;
    }
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(w) for queue (w = max width).  
**Notes**:  
- Solved with recursive, optimized with BFS.  
- GFG “Level Order Traversal.” Test single node, unbalanced tree.

### Question 6: Reverse Fibonacci Indexed Words

**Problem Statement**:  
- Given a sentence, reverse words at Fibonacci indices (1-based).  
- **Example**: Input: "I love to code daily" → Output: "I evol to edoc daily" (reverse words at indices 1,2,3,5: "love","to","code").

**Approach**:  
- **Brute Force**: Split sentence, reverse all words, revert non-Fibonacci (O(n*k)).  
- **Optimal Approach**: Precompute Fibonacci indices, reverse only those.  
  - Pointwise:  
    1. Split sentence into words.  
    2. Generate Fibonacci indices up to word count.  
    3. Reverse words at those indices.  
    - Edge cases: Single word, empty sentence.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> getFibIndices(int n) {
    vector<int> fib = {1, 2};
    while (fib.back() <= n) {
        fib.push_back(fib[fib.size()-1] + fib[fib.size()-2]);
    }
    return fib;
}

string reverseFibWords(string s) {
    stringstream ss(s);
    vector<string> words;
    string word;
    while (ss >> word) words.push_back(word);
    int n = words.size();
    vector<int> fib = getFibIndices(n);
    for (int idx : fib) {
        if (idx <= n) {
            reverse(words[idx-1].begin(), words[idx-1].end());
        }
    }
    string result;
    for (int i = 0; i < n; i++) {
        result += words[i];
        if (i < n-1) result += " ";
    }
    return result;
}

int main() {
    string s = "I love to code daily";
    cout << reverseFibWords(s);
    return 0;
}
```

**Time Complexity**: O(n + k*log(k)), k=Fibonacci numbers.  
**Space Complexity**: O(n) for words.  
**Notes**:  
- Solved correctly.  
- GFG “String Manipulation.” Test single word, large sentence.

### Question 7: Sort 500GB File with 10GB RAM

**Problem Statement**:  
- Sort a 500GB file using 10GB RAM. Compute time complexity.

**Approach**:  
- **External Sorting**:  
  - Pointwise:  
    1. Divide file into chunks (e.g., 50 chunks of 10GB).  
    2. Sort each chunk in-memory (e.g., quicksort).  
    3. Write sorted chunks to disk.  
    4. Merge sorted chunks using k-way merge (min-heap).  
  - **Time Complexity**:  
    - Read/write: O(n).  
    - Sort chunks: O((n/k)*log(n/k)) per chunk, k=50.  
    - Merge: O(n*log(k)).  
    - Total: O(n*log(n)).  
  - **Space Complexity**: O(10GB) for RAM, O(n) disk.  
- **Edge Cases**: Single chunk, duplicate values.

**Notes**:  
- Explained external sorting, satisfied interviewer.  
- Tip: Study external sorting (GFG System Design).

### Question 8: Java Features (Java 8)

**Problem Statement**:  
- Discuss latest Java 8 features.

**Approach**:  
- **Key Features**:  
  - Lambda Expressions: Enable functional programming (e.g., `(x) -> x*2`).  
  - Stream API: Process collections (e.g., `list.stream().filter(x -> x > 0)`).  
  - Optional Class: Avoid null pointer exceptions.  
  - Default Methods: Add methods to interfaces.  
- **Example**:  
  ```java
  List<Integer> list = Arrays.asList(1, 2, 3);
  list.stream().map(x -> x * 2).forEach(System.out::println);
  ```

**Notes**:  
- Brief discussion, showed familiarity.  
- Tip: Study Java 8 (GFG Java).

### Question 9: Questions for Interviewer

**Problem Statement**:  
- Ask about interviewer’s experience and role at Morgan Stanley.

**Sample Answer**:  
- “How long have you been with Morgan Stanley, and what’s the most exciting project your team has worked on?”

**Notes**:  
- Asked relevant questions.  
- Tip: Prepare 2–3 thoughtful questions.

**Technical Interview Performance**:  
- Strong in projects, OOPS, coding; all solutions satisfactory.  
- 6/20+ advanced to Round 3.

## HR + Technical Interview (Round 3)

**Duration**: ~45 minutes, via Zoom, with Executive Director.  
**Interviewer**: Mixed HR and technical focus.

### Question 10: Introduction and Projects

**Problem Statement**:  
- Introduce yourself, discuss projects.

**Sample Answer**:  
- **Introduction**: “I’m a CSE student passionate about scalable systems and Java.”  
- **Projects**: “Developed a team-based e-commerce app using Java Spring, optimized DB queries for 20% faster response.”

**Notes**:  
- Highlighted technical skills.  
- Tip: Tie projects to Morgan Stanley’s tech stack.

### Question 11: Project Challenges

**Problem Statement**:  
- What challenges did you face in your project?

**Sample Answer**:  
- **Situation**: “Faced DB performance issues in e-commerce app.”  
- **Task**: “Optimize query response time.”  
- **Action**: “Indexed tables, cached frequent queries using Redis.”  
- **Result**: “Reduced latency by 20%, improved user experience.”

**Notes**:  
- Showed problem-solving.  
- Tip: Use STAR, focus on impact.

### Question 12: Team Management

**Problem Statement**:  
- How did you manage team members in your project?

**Sample Answer**:  
- **Situation**: “Led a 4-member team for e-commerce app.”  
- **Task**: “Ensure timely delivery despite skill gaps.”  
- **Action**: “Assigned roles based on strengths, held daily standups, mentored on React.”  
- **Result**: “Delivered on time, team gained new skills.”

**Notes**:  
- Emphasized leadership.  
- Tip: Highlight collaboration, conflict resolution.

### Question 13: Maximize Stock Profits

**Problem Statement**:  
- Given stock prices for 10 days, maximize profit by buying and selling once.  
- **Example**: Input: prices=[7,1,5,3,6,4] → Output: 5 (buy at 1, sell at 6).  
- **Link**: [LeetCode #121](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/).

**Approach**:  
- **Brute Force**: Check all buy-sell pairs (O(n²)).  
- **Optimal Approach**: Single pass.  
  - Pointwise:  
    1. Track min price and max profit.  
    2. For each price, update min price and max profit.  
    - Edge cases: No profit possible, single price.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int maxProfit(vector<int>& prices) {
    int minPrice = INT_MAX, maxProfit = 0;
    for (int price : prices) {
        minPrice = min(minPrice, price);
        maxProfit = max(maxProfit, price - minPrice);
    }
    return maxProfit;
}

int main() {
    vector<int> prices = {7, 1, 5, 3, 6, 4};
    cout << maxProfit(prices);
    return 0;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Solved, satisfied interviewer.  
- LeetCode #121. Test decreasing prices, single day.

### Question 14: Snake and Ladder Game Design

**Problem Statement**:  
- Design and implement a Snake and Ladder game using OOPS concepts (15-minute discussion).

**Approach**:  
- **Requirements**: Board, players, dice, snakes, ladders, win condition.  
- **Class Design (Java)**:  
  - `Player`: ID, name, position.  
  - `Board`: Size, snakes, ladders (HashMap for jumps).  
  - `Game`: Manage players, dice, turns.  
- **OOPS Concepts**:  
  - **Encapsulation**: Private fields in `Player`, `Board`.  
  - **Abstraction**: Abstract `Dice` for roll behavior.  
  - **Polymorphism**: Different dice types (e.g., 6-sided, 12-sided).  
- **Game Flow**:  
  1. Roll dice, move player.  
  2. Check for snake/ladder, update position.  
  3. Win if position ≥ board size.  
- **Edge Cases**: Multiple players on same cell, no snakes/ladders.

**Code Snippet (Java)**:  
```java
import java.util.*;

class Player {
    String id, name;
    int position;
    Player(String id, String name) { this.id = id; this.name = name; position = 0; }
}

class Board {
    int size;
    Map<Integer, Integer> jumps; // Snakes and ladders
    Board(int size) {
        this.size = size;
        jumps = new HashMap<>();
    }
    void addJump(int start, int end) { jumps.put(start, end); }
}

class Dice {
    Random rand = new Random();
    int roll() { return rand.nextInt(6) + 1; }
}

class Game {
    Board board;
    List<Player> players;
    Dice dice;
    Game(int size, int numPlayers) {
        board = new Board(size);
        players = new ArrayList<>();
        dice = new Dice();
        for (int i = 0; i < numPlayers; i++) {
            players.add(new Player("P" + i, "Player" + i));
        }
    }
    String play() {
        while (true) {
            for (Player p : players) {
                int roll = dice.roll();
                p.position += roll;
                if (board.jumps.containsKey(p.position)) {
                    p.position = board.jumps.get(p.position);
                }
                if (p.position >= board.size) return p.name;
            }
        }
    }
}
```

**Notes**:  
- Discussed for 15 minutes, satisfied interviewer.  
- Tip: Practice LLD for games (GFG System Design).

### Question 15: Questions for Interviewer

**Problem Statement**:  
- Ask about interviewer’s team and feedback on performance.

**Sample Answer**:  
- “What projects does your team work on at Morgan Stanley? Any feedback on my performance today?”

**Notes**:  
- Asked relevant questions, received positive feedback.  
- Tip: Prepare questions on team roles, culture.

**Outcome**:  
- 4/6 selected for internship, including candidate.

## Key Takeaways and Preparation Tips

- **Eligibility**: Maintain CGPA ≥ 7.5.  
- **Online Test**:  
  - Aptitude: Practice quick numerical/logical sets (RS Aggarwal).  
  - Debugging: Focus on speed, accuracy (HackerRank).  
  - Coding: Solve medium-hard problems, ensure full code (LeetCode, GFG).  
- **Interviews**:  
  - Technical: Master DSA (trees, strings, sliding window), OOPS (Java), system design (LLD).  
  - HR: Use STAR for project challenges, teamwork.  
- **Resources**:  
  - **Coding**: LeetCode, GFG, HackerRank.  
  - **OOPS/System Design**: GFG Java, System Design Primer.  
  - **Aptitude**: RS Aggarwal.  
  - **Java**: GFG Java 8 Notes.  
- **Interview Day**: Explain thought process, debug carefully, engage with interviewer.  
- **General**: Optimize solutions, practice verbal explanations.

**Final Note**: Solve all test cases and nail OOPS, bruh—Morgan Stanley digs clarity and depth!