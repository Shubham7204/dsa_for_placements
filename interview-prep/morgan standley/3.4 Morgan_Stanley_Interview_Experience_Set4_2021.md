# Morgan Stanley Interview Experience | Set 4 (On-Campus) 2021

This document details the **Morgan Stanley Interview Experience for FTE (On-Campus)**, shared on July 23, 2025. Conducted in 2020, the process included a Written Test with 50 MCQs, a Programming Round with 4 coding questions, and four interview rounds: Technical Interview 1, Group Activity, Technical Interview 2, and Technical + HR Round. The candidate performed well despite negative marking and sectional cutoffs in the Written Test, solved all coding questions, and was selected after 22/97 were shortlisted post-Programming Round, 10/22 post-Technical Interview 1, with no further eliminations. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers for behavioral questions.

Let’s dive in, bruh—this is your ultimate playbook to slay Morgan Stanley’s tough interview process!

## Written Test

The Written Test consisted of 50 MCQs across three sections with negative marking and sectional cutoffs, requiring careful yet strategic answering.

### Section 1: Aptitude

**Problem Statement**:  
- 10 questions, moderate to hard, covering quantitative aptitude, logical reasoning, data interpretation.  
- Topics: Probability, permutations, puzzles, graph analysis.

**Approach**:  
- **Preparation**: Study quants (time-and-work, probability), logical puzzles, data interpretation.  
- **Strategy**:  
  1. Prioritize high-confidence questions (e.g., arithmetic).  
  2. Use elimination to minimize negative marking.  
  3. Double-check graph-based questions for accuracy.  
- **Edge Cases**: Tricky wording, negative numbers, complex graphs.

**Notes**:  
- Sectional cutoff critical, risky guesses needed.  
- Resources: RS Aggarwal, GeeksforGeeks (GFG) Aptitude.  
- Tip: Practice 10-minute MCQ sets, aim for 7/10 with no negatives.

### Section 2: Programming

**Problem Statement**:  
- 30 questions, moderate difficulty, language-specific (C/C++/Java).  
- Topics: Syntax, output prediction, pointers (C++), OOP concepts (Java).  
- Solved most, cutoff ensured.

**Approach**:  
- **Preparation**: Master C++ (pointers, memory), Java (inheritance, polymorphism).  
- **Strategy**:  
  1. Solve syntax/output questions first.  
  2. Verify pointer arithmetic, exception handling.  
  3. Tackle OOP questions with examples.  
- **Edge Cases**: Null pointers, uninitialized variables, edge cases in loops.

**Notes**:  
- Moderate difficulty, time management key.  
- Resources: GFG C++/Java, HackerRank.  
- Tip: Practice 30-minute language-specific tests, aim for 25/30.

### Section 3: CS Fundamentals

**Problem Statement**:  
- 10 questions, easy to moderate, covering OS, CN, DBMS, DS.  
- Topics: Process scheduling, TCP/IP, SQL queries, tree traversals.

**Approach**:  
- **Preparation**: Study OS (processes, memory), CN (OSI model), DBMS (normalization), DS (trees, graphs).  
- **Strategy**:  
  1. Answer DS/OS questions first.  
  2. Use elimination for network/DBMS questions.  
  3. Verify terminology (e.g., deadlock vs. starvation).  
- **Edge Cases**: Ambiguous options, practical applications.

**Notes**:  
- Solved most, ensured cutoff.  
- Resources: GFG Last Minute Notes, HackerRank MCQs.  
- Tip: Aim for 8/10 in 10 minutes.

**Written Test Performance**:  
- Cleared sectional cutoffs despite negative marking.  
- 22/97 shortlisted for Programming Round.

## Programming Round

**Duration**: 45 minutes, 4 coding questions, written on paper.  
**Note**: Time constraints critical, boundary cases important.

### Question 1: Array Product Except Self

**Problem Statement**:  
Given an array A, create array B where B[i] is the product of all elements of A except A[i].  
- **Example**: Input: [1,2,3,4] → Output: [24,12,8,6].  
- **Constraints**: No division, O(n) time, O(1) extra space (excluding output).

**Approach**:  
- **Brute Force**: Compute product for each i (O(n²)).  
- **Optimal Approach**: Use left and right product arrays.  
  - Pointwise:  
    1. Compute left products (B[i] = product of A[0..i-1]).  
    2. Multiply with right products (A[i+1..n-1]) in one pass.  
    - Edge cases: Single element, zeros in array.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> productExceptSelf(vector<int>& A) {
    int n = A.size();
    vector<int> B(n, 1);
    // Left products
    for (int i = 1; i < n; i++) {
        B[i] = B[i-1] * A[i-1];
    }
    // Multiply with right products
    int right = 1;
    for (int i = n-1; i >= 0; i--) {
        B[i] *= right;
        right *= A[i];
    }
    return B;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1) excluding output.  
**Notes**:  
- Solved using left-right approach.  
- LeetCode #238. Test with zeros, single element.

### Question 2: Spiral Level Order Traversal

**Problem Statement**:  
Print level order traversal of a binary tree in spiral (zig-zag) order.  
- **Example**: Input: [1,2,3,4,5,6,7] → Output: 1,3,2,4,5,6,7 (level 1: L→R, level 2: R→L, etc.).

**Approach**:  
- **Brute Force**: Use level order, reverse alternate levels (O(n)).  
- **Optimal Approach**: Use two stacks or deque with direction flag.  
  - Pointwise:  
    1. Use deque, push nodes level by level.  
    2. Alternate direction (L→R, R→L) using flag.  
    - Edge cases: Empty tree, single level, skewed tree.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

vector<int> spiralOrder(TreeNode* root) {
    vector<int> result;
    if (!root) return result;
    deque<TreeNode*> dq;
    dq.push_back(root);
    bool leftToRight = true;
    while (!dq.empty()) {
        int size = dq.size();
        for (int i = 0; i < size; i++) {
            TreeNode* node = dq.front();
            dq.pop_front();
            result.push_back(node->val);
            if (leftToRight) {
                if (node->left) dq.push_back(node->left);
                if (node->right) dq.push_back(node->right);
            } else {
                if (node->right) dq.push_back(node->right);
                if (node->left) dq.push_back(node->left);
            }
        }
        leftToRight = !leftToRight;
    }
    return result;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(w) (w = max width).  
**Notes**:  
- Solved with deque.  
- GFG “Spiral Level Order.” Test skewed trees.

### Question 3: Longest Common Substring

**Problem Statement**:  
Find the longest common substring between two strings.  
- **Example**: Input: "ABCD", "ABDC" → Output: "AB" (length 2).  
- **Constraints**: Return substring, not just length.

**Approach**:  
- **Brute Force**: Check all substrings (O(n²*m²)).  
- **Optimal Approach**: Dynamic Programming.  
  - Pointwise:  
    1. Use DP table to track lengths of common suffixes.  
    2. Update max length and substring.  
    - Edge cases: Empty strings, no common substring.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

string longestCommonSubstring(string s1, string s2) {
    int n = s1.size(), m = s2.size();
    vector<vector<int>> dp(n+1, vector<int>(m+1, 0));
    int maxLen = 0, endIdx = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (s1[i-1] == s2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
                if (dp[i][j] > maxLen) {
                    maxLen = dp[i][j];
                    endIdx = i;
                }
            }
        }
    }
    return s1.substr(endIdx - maxLen, maxLen);
}
```

**Time Complexity**: O(n*m).  
**Space Complexity**: O(n*m).  
**Notes**:  
- Solved with DP.  
- GFG “Longest Common Substring.” Test empty strings, single chars.

### Question 4: Add Two Linked Lists

**Problem Statement**:  
Add two numbers represented as linked lists (digits in reverse order).  
- **Example**: Input: 2->4->3 (342), 5->6->4 (465) → Output: 7->0->8 (807).  
- **Constraints**: Handle carry, unequal lengths.

**Approach**:  
- **Brute Force**: Convert to numbers, add, convert back (O(n) space).  
- **Optimal Approach**: Add digit by digit.  
  - Pointwise:  
    1. Traverse both lists, add digits with carry.  
    2. Create new list for result.  
    - Edge cases: Carry at end, unequal lengths.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode dummy(0), *curr = &dummy;
    int carry = 0;
    while (l1 || l2 || carry) {
        int sum = carry;
        if (l1) { sum += l1->val; l1 = l1->next; }
        if (l2) { sum += l2->val; l2 = l2->next; }
        carry = sum / 10;
        curr->next = new ListNode(sum % 10);
        curr = curr->next;
    }
    return dummy.next;
}
```

**Time Complexity**: O(max(n,m)).  
**Space Complexity**: O(max(n,m)) for result.  
**Notes**:  
- Solved, handled carry.  
- LeetCode #2. Test unequal lists, carry at end.

**Programming Round Performance**:  
- Solved all 4 questions despite time constraints.  
- 22/97 shortlisted for Technical Interview 1.

## Technical Interview 1

**Duration**: ~45 minutes, elimination round.  
**Interviewer**: Discussed Programming Round codes, asked additional DSA and SQL questions.

### Question 5: Code Discussion

**Problem Statement**:  
- Discuss solutions to Programming Round questions (Q1-Q4).

**Approach**:  
- Explained approaches for Array Product, Spiral Traversal, Longest Common Substring, and Add Linked Lists.  
- Highlighted boundary cases (e.g., zeros in Array Product, empty strings in Substring).  
- Discussed optimizations (e.g., O(1) space for Array Product).

**Notes**:  
- Clarified edge cases, optimizations.  
- Tip: Review written code, prepare to justify choices.

### Question 6: Queue Using Two Stacks

**Problem Statement**:  
- Implement a queue using two stacks with optimal enqueue/dequeue complexity.

**Approach**:  
- **Brute Force**: Enqueue to stack1, dequeue by moving to stack2 (O(n) dequeue).  
- **Optimal Approach**: Amortized O(1) enqueue/dequeue.  
  - Pointwise:  
    1. Stack1 for enqueue, push directly.  
    2. Stack2 for dequeue, pop from stack2 if non-empty.  
    3. If stack2 empty, move all from stack1 to stack2 (O(n) amortized).  
    - Edge cases: Empty queue, single element.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

class MyQueue {
    stack<int> s1, s2;
public:
    void push(int x) {
        s1.push(x); // O(1)
    }
    int pop() {
        if (s2.empty()) {
            while (!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
        int x = s2.top();
        s2.pop();
        return x; // Amortized O(1)
    }
    bool empty() {
        return s1.empty() && s2.empty();
    }
};
```

**Time Complexity**:  
- Enqueue: O(1).  
- Dequeue: Amortized O(1), worst O(n).  
**Space Complexity**: O(n).  
**Notes**:  
- Achieved O(1) amortized.  
- LeetCode #232. Test frequent enqueues/dequeues.

### Question 7: BFS Complexity

**Problem Statement**:  
- What is the complexity of BFS?

**Approach**:  
- **BFS Complexity**:  
  - Time: O(V + E) (V = vertices, E = edges).  
  - Space: O(V) for queue and visited set.  
- **Explanation**:  
  - Visits each vertex and edge once.  
  - Queue stores at most V vertices.  
- **Edge Cases**: Disconnected graph, single vertex.

**Notes**:  
- Answered clearly.  
- Tip: Study BFS/DFS complexities (GFG Graphs).

### Question 8: Quick Sort Worst Case

**Problem Statement**:  
- What is the worst-case complexity of Quick Sort? When does it occur?

**Approach**:  
- **Complexity**:  
  - Average: O(n log n).  
  - Worst: O(n²).  
- **Worst Case**:  
  - Occurs when pivot is always smallest/largest (e.g., sorted array, all equal elements).  
  - Example: Pivot as first element in [1,2,3,4,5].  
- **Mitigation**: Random pivot, three-way partitioning.  
- **Edge Cases**: Small arrays, duplicates.

**Notes**:  
- Explained with examples.  
- Tip: Study sorting algorithms (GFG Sorting).

### Question 9: SQL Query

**Problem Statement**:  
- Write an SQL query (specific details not provided, likely join-based or aggregation).

**Approach**:  
- **Assumption**: Find students not enrolled in any course (based on later SQL question).  
- **Query**: Use LEFT JOIN to find unmatched records.  
- **Example**: Tables: Students(sid, name), Enrollments(sid, cid).  
  - Query: `SELECT s.name FROM Students s LEFT JOIN Enrollments e ON s.sid = e.sid WHERE e.cid IS NULL;`

**Notes**:  
- Answered, likely join-based.  
- Tip: Practice SQL joins, subqueries (GFG SQL).

**Technical Interview 1 Performance**:  
- Discussed codes, answered DSA/SQL questions.  
- 10/22 shortlisted for Group Activity.

## Group Activity

**Duration**: ~30 minutes, non-elimination, 10 candidates in two groups.  
**Task**: Given 10-11 pictures, create a story linking them, themed on business ethics. Adapt to additional pictures mid-way.

**Approach**:  
- **Initial Story**:  
  - **Theme**: Business ethics (e.g., integrity in a startup).  
  - **Example**: Startup faces pressure to falsify data, chooses transparency, builds trust.  
  - **Images**: Represent product, team, ethical dilemma (e.g., contract, whistleblower).  
- **Adapted Story**:  
  - Incorporated new pictures (e.g., regulators, media).  
  - New Plot: Startup navigates scrutiny, upholds ethics, wins loyalty.  
- **Strategy**:  
  1. Assign roles (e.g., storyteller, visualizer).  
  2. Link images to plot points creatively.  
  3. Speak sensibly, avoid dominating.  
- **Edge Cases**: Contradictory images, time constraints.

**Notes**:  
- Creativity and communication key.  
- Tip: Practice group discussions, storytelling under pressure. Stay vocal but balanced.

## Technical Interview 2

**Duration**: ~45 minutes, non-elimination.  
**Interviewer**: Focused on system design and coding.

### Question 10: Design E-commerce Website

**Problem Statement**:  
- Design an online e-commerce website like Amazon/Flipkart, focusing on details.

**Approach**:  
- **Requirements**:  
  - Features: Product catalog, search, cart, checkout, user accounts, order tracking.  
  - Scalability: Handle millions of users, high traffic.  
- **Architecture**:  
  - **Frontend**: React for dynamic UI, Tailwind CSS for styling.  
  - **Backend**: NodeJS with Express, REST APIs.  
  - **Database**: MySQL for products/users, Redis for caching, MongoDB for reviews.  
  - **Services**: Search (Elasticsearch), Payment Gateway, Recommendation Engine.  
- **Key Components**:  
  - **Product Service**: Manage catalog, search.  
  - **Cart Service**: Add/remove items, validate stock.  
  - **Order Service**: Process checkout, track orders.  
- **Scalability**: Load balancers, microservices, caching (Redis).  
- **Edge Cases**: Concurrent checkouts, out-of-stock items, session management.

**Code Snippet (Java - Sample Product Service)**:  
```java
class Product {
    String id, name;
    double price;
    int stock;
    public Product(String id, String name, double price, int stock) {
        this.id = id; this.name = name; this.price = price; this.stock = stock;
    }
}

class ProductService {
    Map<String, Product> products;
    public ProductService() { products = new HashMap<>(); }
    void addProduct(String id, String name, double price, int stock) {
        products.put(id, new Product(id, name, price, stock));
    }
    Product searchProduct(String id) {
        return products.get(id);
    }
}
```

**Notes**:  
- Discussed microservices, scalability.  
- Tip: Practice e-commerce design (GFG System Design, System Design Primer). Focus on concurrency, caching.

### Question 11: Evaluate Expression

**Problem Statement**:  
Given an expression (e.g., "5*3+10/2"), evaluate it using a tree and postorder traversal.  
- **Example**: Input: "5*3+10/2" → Output: 20 (5*3=15, 10/2=5, 15+5=20).

**Approach**:  
- **Brute Force**: Parse manually, evaluate (O(n)).  
- **Optimal Approach**: Build expression tree, evaluate via postorder.  
  - Pointwise:  
    1. Parse expression to build tree (operators as nodes, operands as leaves).  
    2. Use postorder traversal to compute result.  
    - Edge cases: Invalid expression, parentheses, division by zero.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    string val;
    Node *left, *right;
    Node(string v) : val(v), left(nullptr), right(nullptr) {}
};

Node* buildTree(string s) {
    // Simplified: Assume infix expression parsed into tokens
    // Build tree manually for example "5*3+10/2"
    Node* root = new Node("+");
    root->left = new Node("*");
    root->right = new Node("/");
    root->left->left = new Node("5");
    root->left->right = new Node("3");
    root->right->left = new Node("10");
    root->right->right = new Node("2");
    return root;
}

int evaluate(Node* root) {
    if (!root) return 0;
    if (!root->left && !root->right) return stoi(root->val);
    int left = evaluate(root->left);
    int right = evaluate(root->right);
    if (root->val == "+") return left + right;
    if (root->val == "-") return left - right;
    if (root->val == "*") return left * right;
    if (root->val == "/") return left / right;
    return 0;
}

int evaluateExpression(string s) {
    Node* root = buildTree(s);
    return evaluate(root);
}
```

**Time Complexity**: O(n) for parsing and evaluation.  
**Space Complexity**: O(n) for tree.  
**Notes**:  
- Solved with expression tree.  
- GFG “Expression Tree.” Test invalid expressions, division by zero.

**Technical Interview 2 Performance**:  
- Handled design and coding well.  
- Advanced to Technical + HR Round.

## Technical + HR Round

**Duration**: ~45 minutes, non-elimination, senior interviewer.  
**Focus**: Projects, data structure design, HR questions.

### Question 12: Project Discussion

**Problem Statement**:  
- Discuss projects, challenges faced, and potential improvements.

**Sample Answer**:  
- **Project**: "Built a real-time chat app using NodeJS and WebSockets."  
- **Challenges**: "Faced issues with connection drops, resolved using reconnection logic."  
- **Improvements**: "Add end-to-end encryption, scale with Redis pub/sub."  

**Notes**:  
- Discussed thoroughly, showed problem-solving.  
- Tip: Prepare challenges and scalability ideas for projects.

### Question 13: Data Structure for Student-Subject Queries

**Problem Statement**:  
- Design a data structure to query: (1) Number of students in a subject, (2) Number of subjects a student takes, with low complexity.  
- **Example**: Students take multiple subjects, query efficiently.

**Approach**:  
- **Data Structure**:  
  - HashMap<SubjectID, Set<StudentID>> for subject-to-students.  
  - HashMap<StudentID, Set<SubjectID>> for student-to-subjects.  
- **Queries**:  
  - Students in subject: O(1) lookup, return set size.  
  - Subjects per student: O(1) lookup, return set size.  
- **Edge Cases**: Empty mappings, new students/subjects.

**Code Snippet (Java)**:  
```java
class StudentSubjectSystem {
    Map<String, Set<String>> subjectToStudents;
    Map<String, Set<String>> studentToSubjects;
    
    public StudentSubjectSystem() {
        subjectToStudents = new HashMap<>();
        studentToSubjects = new HashMap<>();
    }
    
    void addEnrollment(String studentID, String subjectID) {
        subjectToStudents.computeIfAbsent(subjectID, k -> new HashSet<>()).add(studentID);
        studentToSubjects.computeIfAbsent(studentID, k -> new HashSet<>()).add(subjectID);
    }
    
    int getStudentsInSubject(String subjectID) {
        return subjectToStudents.getOrDefault(subjectID, new HashSet<>()).size();
    }
    
    int getSubjectsForStudent(String studentID) {
        return studentToSubjects.getOrDefault(studentID, new HashSet<>()).size();
    }
}
```

**Time Complexity**: O(1) for queries, O(1) amortized for updates.  
**Space Complexity**: O(n*m) (n = students, m = subjects).  
**Notes**:  
- Designed for O(1) queries.  
- Tip: Practice bi-directional mappings (GFG Hashing).

### Question 14: HR - Why Morgan Stanley?

**Problem Statement**:  
- Why do you want to work at Morgan Stanley?

**Sample Answer**:  
- **Situation**: "I’m passionate about building scalable systems."  
- **Task**: "I want to contribute to Morgan Stanley’s financial platforms."  
- **Action**: "My experience with real-time apps and DSA aligns with your tech stack, like Java and system design."  
- **Result**: "I’m excited to drive innovation at Morgan Stanley."

**Notes**:  
- Tied skills to company needs.  
- Tip: Research Morgan Stanley’s tech focus, be genuine.

### Question 15: HR - Strengths and Weaknesses

**Problem Statement**:  
- What are your strengths and weaknesses?

**Sample Answer**:  
- **Strength**: "My strength is problem-solving under pressure, like optimizing code during hackathons."  
- **Weakness**: "I sometimes overthink solutions. I’m improving by breaking problems into smaller steps and validating early."

**Notes**:  
- Used STAR-like structure.  
- Tip: Choose fixable weaknesses, show growth.

**Outcome**:  
- Selected after 3-hour recruiter discussion.

## Key Takeaways and Preparation Tips

- **Practice DSA**: Solve medium-hard problems on LeetCode, GFG (arrays, trees, linked lists, DP).  
- **System Design**: Master LLD (e-commerce, reservation systems) and HLD (scalability, caching).  
- **OOPS and Fundamentals**: Study Java (OOPS), C++ (DSA), SQL joins, OS/CN basics.  
- **Group Activity**: Practice storytelling, teamwork, adaptability. Be vocal but sensible.  
- **HR Prep**: Use STAR method, research Morgan Stanley’s values (innovation, ethics).  
- **Written Test**: Balance speed and accuracy due to negative marking, practice sectional mocks.  
- **Communication**: Explain thought process, handle guidance positively.  
- **Resources**:  
  - **Coding**: LeetCode, GFG, InterviewBit.  
  - **System Design**: Gaurav Sen, GFG System Design.  
  - **SQL/OS**: GFG Last Minute Notes.  
  - **Aptitude**: RS Aggarwal, HackerRank MCQs.  
- **Interview Day**: Review projects, rest well, stay confident through long rounds.

**Final Note**: As the candidate emphasized, don’t memorize GFG solutions—solve them to build problem-solving skills, bruh!