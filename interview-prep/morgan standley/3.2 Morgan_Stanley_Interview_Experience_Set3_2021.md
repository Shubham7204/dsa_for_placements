# Morgan Stanley Interview Experience | Set 3 (On-Campus) 2021

This document details the **Morgan Stanley Interview Experience for FTE (On-Campus)**, shared on July 23, 2025. The process, conducted in 2020, included an Online Assessment (OA) with 50 MCQs, a Coding Round, and four interview rounds: Technical Round 1, Group Activity, Technical Round 2, and HR Round. The candidate excelled in MCQs, solved coding questions with boundary cases, explained projects thoroughly, and was one of 4 selected from their college after a grueling process ending at 2:30 AM. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR Questions**: STAR-method sample answers for behavioral questions.

Let’s dive in, bruh—this is your ultimate guide to crushing Morgan Stanley’s intense interview process!

## Online Assessment (OA)

The OA consisted of 50 MCQs across three sections, lasting ~90 minutes.

### Section 1: Computer Fundamentals

**Problem Statement**:  
- 10 questions, easy difficulty.  
- Topics: OS (e.g., process management), CN (e.g., TCP/IP), DS (e.g., basic algorithms), DBMS (e.g., queries).  
- Solved most/all.

**Approach**:  
- **Preparation**: Study OS basics, network layers, data structures, SQL.  
- **Strategy**:  
  1. Answer familiar topics first (e.g., OS, DS).  
  2. Use elimination for tricky questions.  
  3. Verify terminology (e.g., interrupt vs. exception).  
- **Edge Cases**: Ambiguous options, application-based questions.

**Notes**:  
- Easy section, solved most.  
- Resources: GeeksforGeeks (OS, CN, DBMS), HackerRank MCQs.  
- Tip: Practice 10-minute MCQ sets, aim for 8/10.

### Section 2: Language-Specific (C/C++/Java)

**Problem Statement**:  
- 30 questions, moderate difficulty, choice of C/C++/Java.  
- Topics: Syntax, output prediction, pointers (C++), OOP concepts (Java).  
- Solved most.

**Approach**:  
- **Preparation**: Master chosen language (e.g., C++ pointers, Java inheritance).  
- **Strategy**:  
  1. Prioritize syntax/output questions.  
  2. Double-check pointer arithmetic, exception handling.  
  3. Solve OOP questions with examples.  
- **Edge Cases**: Null pointers, uninitialized variables, edge cases in loops.

**Notes**:  
- Moderate difficulty, time management key.  
- Resources: GFG C++/Java, HackerRank.  
- Tip: Practice 30-minute language-specific tests.

### Section 3: Logical and Mathematical Aptitude

**Problem Statement**:  
- 10 questions, moderate difficulty.  
- Topics: Quantitative (e.g., probability, algebra), Logical Reasoning (e.g., puzzles).  
- Solved most.

**Approach**:  
- **Preparation**: Practice quants (time-and-work, permutations), logical puzzles.  
- **Strategy**:  
  1. Solve arithmetic questions first.  
  2. Use elimination for reasoning questions.  
  3. Check units in quant problems.  
- **Edge Cases**: Tricky wording, negative numbers.

**Notes**:  
- Solved most; practice critical.  
- Resources: RS Aggarwal, GFG Aptitude.  
- Tip: Aim for 8/10 in 10 minutes.

**OA Performance**:  
- Solved most MCQs, advanced to Coding Round.

## Coding Round

**Duration**: 45 minutes, 4 questions, write code on paper, not elimination but important.  
**Note**: Handle boundary cases, comment code.

### Question 1: Exchange Kth Node from Start and End

**Problem Statement**:  
Swap the kth node from the start with the kth node from the end in a singly linked list.  
- **Example**: Input: 5->10->25->45->31->16->23->51, k=3 → Output: 5->10->16->45->31->25->23->51.  
- **Constraints**: Handle boundary cases (e.g., k=1, k=n/2).

**Approach**:  
- **Brute Force**: Find kth and (n-k+1)th nodes, swap values (O(n)).  
- **Optimal Approach**: Swap nodes by adjusting pointers.  
  - Pointwise:  
    1. Find kth node and its previous.  
    2. Find (n-k+1)th node and its previous.  
    3. Adjust pointers to swap nodes.  
    - Edge cases: k=1, k=n, same node, adjacent nodes.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

ListNode* swapKthNodes(ListNode* head, int k) {
    if (!head || !head->next) return head;
    // Find length
    int n = 0;
    ListNode* curr = head;
    while (curr) { n++; curr = curr->next; }
    if (k > n || k <= 0) return head;
    if (2*k-1 == n) return head; // Same node
    // Find kth node
    ListNode *prev1 = nullptr, *curr1 = head;
    for (int i = 1; i < k; i++) {
        prev1 = curr1;
        curr1 = curr1->next;
    }
    // Find (n-k+1)th node
    ListNode *prev2 = nullptr, *curr2 = head;
    for (int i = 1; i < n-k+1; i++) {
        prev2 = curr2;
        curr2 = curr2->next;
    }
    // Swap nodes
    if (prev1) prev1->next = curr2;
    else head = curr2;
    if (prev2) prev2->next = curr1;
    else head = curr1;
    ListNode* temp = curr1->next;
    curr1->next = curr2->next;
    curr2->next = temp;
    return head;
}
```

**Time Complexity**: O(n) to find nodes.  
**Space Complexity**: O(1).  
**Notes**:  
- Handled boundary cases (k=1, k=n).  
- LeetCode #1721. Test adjacent nodes, single node.

### Question 2: Next Greater Number with Same Digits

**Problem Statement**:  
Find the next greater number using the same digits as the given number.  
- **Example**: Input: 4765 → Output: 5467.  
- **Constraints**: Handle no greater number, single digit.

**Approach**:  
- **Brute Force**: Generate all permutations (O(n!)).  
- **Optimal Approach**: Next permutation algorithm.  
  - Pointwise:  
    1. Find first decreasing digit from right (i).  
    2. Find smallest digit > arr[i] from right (j).  
    3. Swap i and j, reverse suffix after i.  
    - Edge cases: Largest permutation (e.g., 54321), duplicates.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int nextGreaterNumber(int num) {
    string s = to_string(num);
    int n = s.size(), i = n-2;
    while (i >= 0 && s[i] >= s[i+1]) i--;
    if (i < 0) return -1;
    int j = n-1;
    while (j > i && s[j] <= s[i]) j--;
    swap(s[i], s[j]);
    reverse(s.begin() + i + 1, s.end());
    long long result = stoll(s);
    return result > INT_MAX ? -1 : result;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(n) for string.  
**Notes**:  
- Coded in Round 3; explained approach.  
- LeetCode #31. Test cases like 54321, 111.

### Question 3: Level Order Traversal (Line by Line)

**Problem Statement**:  
Print level order traversal of a binary tree, left-to-right, each level on a new line.  
- **Example**: Input: [5,10,15,56,47,12,42] → Output: 5\n10 15\n56 47 12 42.

**Approach**:  
- **Brute Force**: Recursive level tracking (O(n)).  
- **Optimal Approach**: BFS with level separation.  
  - Pointwise:  
    1. Use queue to process nodes level by level.  
    2. Track level size, print newline after each level.  
    - Edge cases: Empty tree, single node, skewed tree.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left, *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

void levelOrder(TreeNode* root) {
    if (!root) return;
    queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front();
            q.pop();
            cout << node->val << " ";
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        cout << endl;
    }
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(w) (w = max width).  
**Notes**:  
- Coded in Round 3; simple BFS.  
- LeetCode #102. Test skewed trees.

### Question 4: Reverse Words in Sentence

**Problem Statement**:  
Reverse words in a sentence word by word.  
- **Example**: Input: "this is morganstanley interview question" → Output: "question interview morganstanley is this".

**Approach**:  
- **Brute Force**: Split, reverse, join (O(n)).  
- **Optimal Approach**: In-place reversal.  
  - Pointwise:  
    1. Reverse entire string.  
    2. Reverse each word.  
    - Edge cases: Single word, empty string, multiple spaces.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

string reverseWords(string s) {
    reverse(s.begin(), s.end());
    int start = 0;
    for (int i = 0; i <= s.size(); i++) {
        if (i == s.size() || s[i] == ' ') {
            reverse(s.begin() + start, s.begin() + i);
            start = i + 1;
        }
    }
    return s;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1) in-place.  
**Notes**:  
- Coded in Round 3; handled spaces.  
- LeetCode #151. Test multiple spaces, single word.

**Coding Round Performance**:  
- Solved all with boundary cases, commented code.  
- Advanced to Technical Round 1.

## Technical Round 1

**Duration**: 45-60 minutes, technical and elimination round.  
**Interviewer**: Focused on projects, OOPS, coding.

### Question 5: Recent Projects

**Problem Statement**:  
- Explain recent projects in detail, including aspects and OOP-based projects.

**Sample Answer**:  
- **Recent Project**: "Built a real-time analytics dashboard using NodeJS and MySQL. Optimized queries for scalability, implemented caching with Redis."  
- **OOP Project**: "Developed a Java-based booking system with classes for User, Booking, Payment. Used inheritance for User types, polymorphism for payment methods."

**Notes**:  
- Explained thoroughly, discussed scalability.  
- Tip: Prepare 2-3 projects, highlight OOP concepts. Resources: GFG Project Ideas.

### Question 6: OOPS Concepts (Virtual Functions, Overloading, Overriding, Inheritance, Abstract Class)

**Problem Statement**:  
- Explain virtual functions, function overloading, overriding, inheritance, abstract class.

**Approach**:  
- **Virtual Functions**: Enable runtime polymorphism via `virtual` keyword, resolved via vtable.  
- **Overloading**: Same function name, different parameters (compile-time).  
- **Overriding**: Derived class redefines base class method (runtime).  
- **Inheritance**: Base class properties inherited by derived class.  
- **Abstract Class**: Contains pure virtual functions, cannot be instantiated.  
- **Example (Java)**:  
  - Abstract class `Animal` with pure virtual `speak()`.  
  - Derived `Dog` overrides `speak()`.

**Code Snippet (Java Example)**:  
```java
abstract class Animal {
    abstract void speak();
}

class Dog extends Animal {
    void speak() { System.out.println("Woof"); }
}

class Main {
    public static void main(String[] args) {
        Animal a = new Dog();
        a.speak(); // Woof
    }
}
```

**Notes**:  
- Answered all concepts.  
- Tip: Study OOPS with examples (GFG, JavaTpoint).

### Question 7: Next Greater Number (Coding)

**Problem Statement**:  
- Re-explain approach and write end-to-end code for Q2 (Next Greater Number).

**Approach**: Same as Q2 (Next Permutation).  
- Explained approach, coded on paper.  
- **Notes**: Emphasized edge cases (e.g., 54321). LeetCode #31.

### Question 8: Reverse Words (Coding)

**Problem Statement**:  
- Re-explain approach and write end-to-end code for Q4 (Reverse Words).

**Approach**: Same as Q4 (In-place reversal).  
- Explained approach, coded on paper.  
- **Notes**: Handled multiple spaces. LeetCode #151.

**Round 1 Performance**:  
- Strong project discussion, answered OOPS, coded Q2/Q4.  
- Advanced to Group Activity.

## Group Activity (Round 4)

**Duration**: 30 minutes, 5-person group, 5 interviewers.  
**Task**: Create a business ethics story using 5 given images, incorporate 5 additional images mid-way, explain contributions.

**Approach**:  
- **Initial Story**:  
  - **Theme**: Business ethics (e.g., transparency in a startup).  
  - **Images**: Used to represent product, team, ethical dilemma (e.g., data privacy).  
  - **Plot**: Startup faces pressure to misuse data, chooses transparency, gains trust.  
- **After Adding Images**:  
  - Adapted story to include new elements (e.g., regulators, competitors).  
  - New Plot: Startup navigates legal scrutiny, upholds ethics.  
- **Contributions**:  
  - Suggested plot, designed visuals with images, presented ethical resolution.  
- **Strategy**:  
  1. Assign roles (e.g., storyteller, visualizer).  
  2. Use images as plot points.  
  3. Adapt quickly to new images.  

**Notes**:  
- Tested communication, teamwork, adaptability.  
- Tip: Practice group discussions, storytelling under pressure.

## Technical Round 2

**Duration**: 1.5 hours, late-night, technical focus.  
**Interviewer**: Deep dive into projects, DSA, system design.

### Question 9: Project Discussion

**Problem Statement**:  
- Explain projects, future scopes, modifications (30 minutes).

**Sample Answer**:  
- **Project**: "Real-time analytics dashboard using NodeJS, MySQL, Redis."  
- **Scope**: "Add AI-driven insights, scale to millions of users."  
- **Modifications**: "Implement sharding, optimize caching with Redis pub/sub."  

**Notes**:  
- Discussed thoroughly, showed scalability.  
- Tip: Prepare project extensions, challenges.

### Question 10: Sort Pairs by Color (Stable Sort)

**Problem Statement**:  
- Given an array of ordered pairs (value, color) sorted by value, sort by color while maintaining relative value order. Then, modify to sort by color first, then value (unsorted values).  
- **Example**: Input: [(1,Red), (2,Blue), (3,Red)] → Output: [(1,Red), (3,Red), (2,Blue)].

**Approach**:  
- **Stable Sort by Color**: Use stable sort (e.g., merge sort) on color (O(n log n)).  
- **Sort by Color, Then Value**:  
  - Group by color using array of linked lists.  
  - Sort each list by value.  
  - Concatenate lists.  
- **Edge Cases**: Single color, empty array, duplicate values.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Pair {
    int value;
    string color;
};

vector<Pair> sortByColorStable(vector<Pair>& pairs) {
    vector<Pair> result = pairs;
    stable_sort(result.begin(), result.end(), 
        [](const Pair& a, const Pair& b) { return a.color < b.color; });
    return result;
}

vector<Pair> sortByColorThenValue(vector<Pair>& pairs) {
    map<string, vector<int>> groups;
    for (auto& p : pairs) groups[p.color].push_back(p.value);
    for (auto& g : groups) sort(g.second.begin(), g.second.end());
    vector<Pair> result;
    for (auto& g : groups) {
        for (int v : g.second) result.push_back({v, g.first});
    }
    return result;
}
```

**Time Complexity**:  
- Stable Sort: O(n log n).  
- Color+Value: O(n log n) for sorting values.  
**Space Complexity**: O(n) for groups.  
**Notes**:  
- Used array of linked lists for modified version.  
- LeetCode #75 variant. Test single color.

### Question 11: Sorting Techniques (Merge Sort vs. Quick Sort)

**Problem Statement**:  
- Why use merge sort over quick sort? How to improve quick sort? Find median of unsorted array.

**Approach**:  
- **Merge Sort vs. Quick Sort**:  
  - Merge Sort: Stable, O(n log n) always, high space (O(n)).  
  - Quick Sort: Unstable, O(n log n) average, O(n^2) worst, in-place.  
  - Use Merge Sort for stability, linked lists.  
- **Improve Quick Sort**:  
  - Random pivot to avoid O(n^2).  
  - Three-way partitioning for duplicates.  
  - Switch to insertion sort for small arrays.  
- **Median**: Use selection algorithm (QuickSelect, O(n) average).  
- **Edge Cases**: Odd/even length, duplicates.

**Code Snippet (C++ QuickSelect)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int partition(vector<int>& arr, int left, int right) {
    int pivot = arr[right], i = left;
    for (int j = left; j < right; j++) {
        if (arr[j] <= pivot) swap(arr[i++], arr[j]);
    }
    swap(arr[i], arr[right]);
    return i;
}

int quickSelect(vector<int>& arr, int left, int right, int k) {
    if (left == right) return arr[left];
    int p = partition(arr, left, right);
    if (k == p) return arr[k];
    if (k < p) return quickSelect(arr, left, p-1, k);
    return quickSelect(arr, p+1, right, k);
}

int findMedian(vector<int>& arr) {
    int n = arr.size();
    return quickSelect(arr, 0, n-1, n/2);
}
```

**Time Complexity**:  
- Merge Sort: O(n log n).  
- QuickSelect: O(n) average.  
**Space Complexity**: O(n) for merge, O(1) for QuickSelect.  
**Notes**:  
- Discussed trade-offs, QuickSelect.  
- GFG Sorting, LeetCode #215.

### Question 12: Process Scheduling with Fixed Memory

**Problem Statement**:  
- Given processes with burst times and fixed memory (e.g., 10), maximize processes accommodated.  
- **Example**: Input: [(1,4), (2,3), (3,2), (4,10), (5,5)] → Output: [2,3,5] (sum=10, no waste).

**Approach**:  
- **Greedy**: Select smallest burst times (incorrect, e.g., [2,3,4] wastes memory).  
- **Optimal**: 0/1 Knapsack.  
  - Pointwise:  
    1. Treat burst times as weights, value=1 for each process.  
    2. Use DP to maximize processes within memory.  
    - Edge cases: No processes fit, all fit.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> maxProcesses(vector<pair<int, int>>& processes, int memory) {
    int n = processes.size();
    vector<vector<int>> dp(n+1, vector<int>(memory+1, 0));
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= memory; j++) {
            dp[i][j] = dp[i-1][j];
            if (j >= processes[i-1].second) {
                dp[i][j] = max(dp[i][j], dp[i-1][j - processes[i-1].second] + 1);
            }
        }
    }
    vector<int> result;
    int j = memory;
    for (int i = n; i > 0 && j > 0; i--) {
        if (dp[i][j] != dp[i-1][j]) {
            result.push_back(processes[i-1].first);
            j -= processes[i-1].second;
        }
    }
    return result;
}
```

**Time Complexity**: O(n*memory).  
**Space Complexity**: O(n*memory).  
**Notes**:  
- Corrected greedy with knapsack.  
- GFG Knapsack. Test tight memory constraints.

### Question 13: Printer Memory Management

**Problem Statement**:  
- Design a system for a printer with 1MB memory to print:  
  1. 100-page file (1MB/page).  
  2. 100 files from network.  
  3. Single 500MB poster.  
- Discuss spooling location (printer vs. system).

**Approach**:  
- **100-Page File**:  
  - Process page by page, buffer 1MB at a time.  
  - Use queue to manage page order.  
- **100 Files (Network)**:  
  - System-side spooling: Queue files on client, send 1MB chunks.  
  - Printer-side: Buffer 1MB, process sequentially.  
- **500MB Poster**:  
  - Stream chunks (e.g., 1MB slices), process incrementally.  
  - Use compression or tiling if feasible.  
- **Spooling**:  
  - System-side: Better for network, handles queue.  
  - Printer-side: Limited by memory, less scalable.  
- **Edge Cases**: Network latency, memory overflow, partial prints.

**Notes**:  
- Discussed streaming, spooling trade-offs.  
- Tip: Study OS I/O systems, buffering. Resources: GFG OS.

**Round 2 Performance**:  
- Handled long round, answered most questions.  
- Advanced to HR.

## HR Round

**Duration**: 15 minutes, shorter for candidate.  
**Interviewer**: Focused on fit, relocation, learning.

### Question 14: Background and Relocation

**Problem Statement**:  
- Where are you from? Any issues with relocation?

**Sample Answer**:  
- **Situation**: "I’m from [City], studied at [College]."  
- **Task**: "I’m open to relocating for Morgan Stanley."  
- **Action**: "I’ve adapted to new environments, like moving for college, and am excited to join your global team."  
- **Result**: "I’m ready to contribute anywhere."

**Notes**:  
- Showed flexibility.  
- Tip: Emphasize adaptability.

### Question 15: Learnings from College and Projects

**Problem Statement**:  
- What did you learn from college and projects?

**Sample Answer**:  
- **Situation**: "College and projects shaped my technical and soft skills."  
- **Task**: "I learned to solve real-world problems."  
- **Action**: "Built a booking system, mastering Java and teamwork through group projects."  
- **Result**: "Gained skills in DSA, system design, and collaboration, preparing me for Morgan Stanley."

**Notes**:  
- Tied to role.  
- Tip: Highlight technical and soft skills.

### Question 16: Questions for Interviewer

**Problem Statement**:  
- Any questions for the interviewer?

**Sample Answer**:  
- "How does Morgan Stanley support new hires in learning financial systems? What’s the team structure for tech projects?"

**Notes**:  
- Asked relevant questions.  
- Tip: Prepare 2-3 thoughtful questions.

**Outcome**:  
- One of 4 selected after results announced next morning.

## Key Takeaways and Preparation Tips

- **Practice DSA**: Solve medium-hard problems on LeetCode, GFG (linked lists, trees, knapsack).  
- **OOPS and Systems**: Master Java (polymorphism, abstract classes), C++ (pointers). Practice LLD (e.g., printer, playlist).  
- **OS and I/O**: Study memory management, spooling, scheduling (GFG OS Notes).  
- **Group Activity**: Practice teamwork, storytelling, adaptability under pressure.  
- **HR Prep**: Use STAR method, research Morgan Stanley’s values (innovation, ethics).  
- **Coding on Paper**: Practice writing clean, commented code with boundary cases.  
- **Communication**: Explain approaches clearly, handle guidance positively.  
- **Resources**:  
  - **Coding**: LeetCode, GFG, InterviewBit.  
  - **OOPS**: GFG, JavaTpoint.  
  - **System Design**: Gaurav Sen, GFG.  
  - **Aptitude/OS**: RS Aggarwal, GFG Last Minute Notes.  
- **Interview Day**: Rest well, review projects, stay confident through long rounds.