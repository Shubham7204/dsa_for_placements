# Morgan Stanley Interview Experience | Spring Analyst (Off-Campus) 2024

This document details the **Morgan Stanley Interview Experience for Spring Analyst (Off-Campus)**, shared on January 5, 2024, for a 6-month internship role. The candidate applied in October 2023 via the Morgan Stanley career portal without a referral and was selected after three rounds: Online Test (Debugging, Aptitude, Coding), First Interview (OOPS, DSA), and Technical + ProFit + HR Round (System Design, Puzzles, Probability, Situational). The candidate solved all debugging and coding questions in the online test, excelled in interviews despite time constraints, and was selected as a Spring Analyst for 2024. All coding questions are implemented in **C++**, OOPS in **Java**, and answers are in a LeetCode-style format with:

- **Problem Statement**: Clear and precise.
- **Approach**: Brute force (if applicable) and optimal, in pointwise format.
- **Code Snippet**: Complete, practicable code.
- **Time Complexity (TC) and Space Complexity (SC)**: For all approaches.
- **Notes**: Edge cases, interview tips, and practical advice.
- **HR/Situational Questions**: STAR-method sample answers.

Yo, bruh—this is your ultimate cheat code to ace Morgan Stanley’s off-campus Spring Analyst hustle! Let’s dive in and own it!

## Round 1: Online Test

**Platform**: Likely AMCAT or HackerRank, conducted in 2023.  
**Details**: 3 sections, total ~180 minutes.  
- **Debugging**: Solve all questions, 20 minutes.  
- **Aptitude**: 10–15 questions, 20 minutes.  
- **Coding**: 3 questions (LeetCode easy-medium), ~140 minutes.  
- **Requirement**: Solve all debugging and coding questions for interview call.  
- **Outcome**: Shortlisted for First Interview.

### Section 1: Debugging

**Problem Statement**:  
- Solve ~7–8 questions in 20 minutes, C++ chosen.  
- Task: Identify and fix syntax/logic errors in code snippets.  
- Solved: All questions.

**Approach**:  
- **Strategy**:  
  1. Check syntax errors (e.g., missing semicolons, incorrect operators).  
  2. Fix logical errors (e.g., wrong loop conditions, off-by-one errors).  
  3. Validate with edge cases mentally.  
- **Edge Cases**: Null inputs, uninitialized variables, boundary conditions.

**Notes**:  
- Fast debugging critical due to time limit.  
- Resources: GFG Debugging, HackerRank practice.  
- Tip: Practice 5-minute debug sprints, aim for 100% accuracy.

### Section 2: Aptitude

**Problem Statement**:  
- 10–15 questions, 20 minutes.  
- Topics: Logical reasoning, quantitative aptitude, data interpretation.  
- Difficulty: Easy with 1–2 tricky questions.

**Approach**:  
- **Strategy**:  
  1. Prioritize easy questions (e.g., basic math, patterns).  
  2. Use elimination for tricky ones.  
  3. Manage time, skip time-consuming questions initially.  
- **Edge Cases**: Tricky wording, time traps.

**Notes**:  
- Partial solves sufficient for shortlisting.  
- Resources: RS Aggarwal, GFG Aptitude.  
- Tip: Practice 10 questions in 15 minutes, aim for 8–10 correct.

### Section 3: Coding

**Details**: 3 questions, LeetCode easy-medium, ~140 minutes, C++ chosen, all solved.  
- Specific problems not provided; assumed typical array/DSA problems based on interview context.

**Approach (General)**:  
- **Strategy**:  
  1. Read constraints to choose optimal approach (e.g., O(n) for N=10^4).  
  2. Write clean, modular code with edge cases handled.  
  3. Test manually with sample inputs.  
- **Edge Cases**: Empty inputs, max constraints, single element.

**Notes**:  
- Solved all questions, key for shortlisting.  
- Practice LeetCode easy-medium (e.g., #121, #560, #76).  
- Tip: Time-box each problem (40–50 minutes), prioritize solving all.

## Round 2: First Interview (Technical)

**Duration**: ~1 hour 10 minutes, Zoom.  
**Details**: OOPS (4 pillars), 4 DSA questions (Waveform of Array, Diagonal Sum of Binary Tree, Best Time to Buy/Sell Stock, Min Deletions for Palindrome).  
**Outcome**: Cleared unexpectedly despite time constraints.

### Question 1: Four Pillars of OOPS

**Problem Statement**:  
- Explain the four pillars of OOPS with real-life examples.

**Approach**:  
- **Answer**:  
  - **Encapsulation**: Bundling data and methods, e.g., a Car class with private speed and public accelerate().  
  - **Inheritance**: Child class inherits parent, e.g., SportsCar extends Car.  
  - **Polymorphism**: Same method, different behavior, e.g., Car::drive() vs. SportsCar::drive().  
  - **Abstraction**: Hide complexity, e.g., Car’s interface hides engine details.  
- **Example (Java)**:  
```java
class Car {
    private int speed;
    public void accelerate() { speed += 10; }
}
class SportsCar extends Car { // Inheritance
    public void accelerate() { speed += 20; } // Polymorphism
}
```

**Notes**:  
- Took ~7 minutes, explained clearly with examples.  
- Tip: Study OOPS (GFG Java, StudyTonight), use relatable analogies.

### Question 2: Waveform of Array

**Problem Statement**:  
- Given an array, print elements in waveform order (e.g., a1 ≥ a2 ≤ a3 ≥ a4 ...).  
- **Example**: Input: [1,2,3,4] → Output: [2,1,4,3].  
- **Link**: [GFG Waveform](https://www.geeksforgeeks.org/sort-array-wave-form-2/).

**Approach**:  
- **Brute Force**: Sort array, swap adjacent pairs (O(n log n)).  
- **Optimal Approach**: Swap adjacent elements if not in wave form (O(n)).  
  - Pointwise:  
    1. Iterate array with step=2.  
    2. Ensure arr[i] ≥ arr[i+1] ≤ arr[i+2].  
    3. Swap if needed.  
  - Edge cases: N=1, empty array.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

void waveForm(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i += 2) {
        if (arr[i] < arr[i + 1]) swap(arr[i], arr[i + 1]);
    }
}

void solve() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];
    waveForm(arr);
    for (int x : arr) cout << x << " ";
    cout << endl;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Provided two solutions, coded optimal.  
- Test [1,2], [1].  
- Tip: Practice GFG waveform problems, explain both approaches.

### Question 3: Diagonal Sum of Binary Tree

**Problem Statement**:  
- Given a binary tree, compute sum of nodes in each diagonal (nodes connected from top-right to bottom-left).  
- **Example**: Input: [1,2,3,4,5] → Output: [4,2,3] (diagonal sums).  
- **Link**: [GFG Diagonal Sum](https://www.geeksforgeeks.org/diagonal-sum-binary-tree/).

**Approach**:  
- **Brute Force**: DFS with level tracking (O(n)).  
- **Optimal Approach**: Use map to store diagonal sums.  
  - Pointwise:  
    1. Traverse tree, assign diagonal number (0 for root, +1 for right child).  
    2. Store sum in map[diagonal].  
    3. Output sums.  
  - Edge cases: Empty tree, single node.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int data;
    Node *left, *right;
    Node(int x) : data(x), left(NULL), right(NULL) {}
};

void diagonalSumUtil(Node* root, int diag, map<int, int>& mp) {
    if (!root) return;
    mp[diag] += root->data;
    diagonalSumUtil(root->left, diag + 1, mp);
    diagonalSumUtil(root->right, diag, mp);
}

vector<int> diagonalSum(Node* root) {
    map<int, int> mp;
    diagonalSumUtil(root, 0, mp);
    vector<int> result;
    for (auto x : mp) result.push_back(x.second);
    return result;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(h) (recursion stack).  
**Notes**:  
- Explained approach, interrupted before coding.  
- Test [1,2,3], [].  
- Tip: Practice GFG tree problems, clarify diagonal logic.

### Question 4: Best Time to Buy and Sell Stock

**Problem Statement**:  
- Given an array of stock prices, find max profit with one buy/sell.  
- **Example**: Input: [7,1,5,3,6,4] → Output: 5 (buy at 1, sell at 6).  
- **Link**: [LeetCode #121](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/).

**Approach**:  
- **DP Approach**: Track min price and max profit (O(n)).  
- **Greedy Approach**: Same, but simpler logic.  
  - Pointwise:  
    1. Track min price seen so far.  
    2. Update max profit if current price - min price is larger.  
  - Edge cases: No profit possible, single price.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int maxProfit(vector<int>& prices) {
    int minPrice = INT_MAX, maxProfit = 0;
    for (int price : prices) {
        minPrice = min(minPrice, price);
        maxProfit = max(maxProfit, price - minPrice);
    }
    return maxProfit;
}

void solve() {
    int n;
    cin >> n;
    vector<int> prices(n);
    for (int i = 0; i < n; i++) cin >> prices[i];
    cout << maxProfit(prices) << endl;
}
```

**Time Complexity**: O(n).  
**Space Complexity**: O(1).  
**Notes**:  
- Initially proposed DP, coded greedy per interviewer’s request.  
- Test [7,6,4], [1].  
- Tip: Practice LeetCode #121, be ready to switch approaches.

### Question 5: Minimum Deletions to Make String Palindrome

**Problem Statement**:  
- Given a string, find min deletions to make it a palindrome.  
- **Example**: Input: "aebcbda" → Output: 2 (delete ‘e’, ‘d’).  
- **Link**: [GFG Min Deletions](https://www.geeksforgeeks.org/minimum-number-deletions-make-string-palindrome/).

**Approach**:  
- **Brute Force**: Try all subsets (O(2^n)).  
- **Optimal Approach**: Use LCS with string and its reverse.  
  - Pointwise:  
    1. Compute LCS of string and its reverse.  
    2. Min deletions = string length - LCS length.  
  - Edge cases: Already palindrome, single char.

**Code Snippet (C++)**:  
```cpp
#include <bits/stdc++.h>
using namespace std;

int lcs(string s1, string s2) {
    int m = s1.size(), n = s2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i - 1] == s2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
            else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }
    return dp[m][n];
}

int minDeletions(string s) {
    string rev = s;
    reverse(rev.begin(), rev.end());
    return s.size() - lcs(s, rev);
}

void solve() {
    string s;
    cin >> s;
    cout << minDeletions(s) << endl;
}
```

**Time Complexity**: O(n^2).  
**Space Complexity**: O(n^2).  
**Notes**:  
- Only explained approach due to time.  
- Test "aba", "a".  
- Tip: Practice LeetCode #1143 (LCS), relate to palindrome.

## Round 3: Technical + ProFit + HR Round

**Duration**: ~1 hour, Zoom, conducted by senior interviewer (warned about being rude).  
**Details**: System Design (Dining Philosophers), Puzzles (4-Litre, Dice Probability), Situational (team retention).  
**Outcome**: Selected as Spring Analyst 2024.

### Question 6: Dining Philosophers Problem

**Problem Statement**:  
- Explain the Dining Philosophers problem and propose multiple solutions, identify the most optimal.  
- **Description**: 5 philosophers share 5 forks, need 2 forks to eat, avoid deadlock/starvation.

**Approach**:  
- **Solution 1: Resource Hierarchy**  
  - Assign unique IDs to forks, pick lower ID first.  
  - Prevents deadlock by avoiding circular wait.  
- **Solution 2: Waiter/Arbitrator**  
  - Central waiter grants forks, ensures no deadlock.  
- **Solution 3: Asymmetric Access**  
  - Even philosophers pick left fork first, odd pick right.  
- **Optimal**: Resource Hierarchy (simplest, no extra thread).  
- **Edge Cases**: Starvation, concurrent access.

**Code Snippet (C++ - Resource Hierarchy)**:  
```cpp
#include <bits/stdc++.h>
#include <mutex>
using namespace std;

class DiningPhilosophers {
    vector<mutex> forks;
public:
    DiningPhilosophers() : forks(5) {}
    void wantsToEat(int philosopher) {
        int left = philosopher, right = (philosopher + 1) % 5;
        if (left > right) swap(left, right); // Resource hierarchy
        lock_guard<mutex> l1(forks[left]);
        lock_guard<mutex> l2(forks[right]);
        // Eat
    }
};
```

**Notes**:  
- Proposed 3 solutions, discussed optimality.  
- Tip: Study Dining Philosophers (GFG OS), focus on deadlock prevention.

### Question 7: Measure 4-Litre Using 3-Litre and 5-Litre Cans

**Problem Statement**:  
- Measure exactly 4 litres using 3-litre and 5-litre cans, minimizing water waste.  
- **Link**: [GFG Puzzle](https://www.geeksforgeeks.org/measuring-4-litre-with-3-and-5-litre-jugs/).

**Approach**:  
- **Standard Solution**: Fill 5-litre, pour to 3-litre, empty 3-litre, pour remaining 2 litres to 3-litre, fill 5-litre, pour to 3-litre until full, 5-litre has 4 litres.  
- **Minimal Waste**: Same, as no water is discarded.  
  - Steps:  
    1. Fill 5-litre (5,0).  
    2. Pour to 3-litre (2,3).  
    3. Empty 3-litre (2,0).  
    4. Pour 2 litres to 3-litre (0,2).  
    5. Fill 5-litre (5,2).  
    6. Pour to 3-litre until full (4,3).  
- **Edge Cases**: None, always possible.

**Notes**:  
- Solved with minimal waste focus.  
- Tip: Practice GFG puzzles, verbalize steps clearly.

### Question 8: Dice Probability Problem

**Problem Statement**:  
- Given a standard 6-faced die and a blank die, number the blank die’s faces so the sum of two dice has equal probability for all sums (2 to 12).  
- **Example**: Standard die: [1,2,3,4,5,6], blank die: [1,1,2,2,3,3] → Equal probability.

**Approach**:  
- **Logic**: Standard die has 6 faces, each with probability 1/6. To make sums 2–12 equally likely (1/11 each), blank die must balance probabilities.  
- **Solution**: Assign [1,1,2,2,3,3] to blank die.  
  - Pointwise:  
    1. Standard die sums: 1 to 6.  
    2. For sums 2–12, each needs 6/66 = 1/11 probability.  
    3. Blank die [1,1,2,2,3,3] gives 2 ones, 2 twos, 2 threes, balancing sums.  
- **Edge Cases**: Invalid numbering, negative numbers.

**Notes**:  
- Struggled but showed thought process.  
- Tip: Practice probability puzzles (GFG Math), explain reasoning.

### Question 9: Situational - Retaining a Star Performer

**Problem Statement**:  
- As a manager, a star performer wants to leave your team. What will you do?

**Sample Answer**:  
- **Situation**: “Star developer planned to join another team.”  
- **Task**: “Retain talent to meet project goals.”  
- **Action**: “Held a 1:1, understood their career aspirations, offered mentorship and new challenges.”  
- **Result**: “Convinced them to stay, boosted team morale.”  

**Notes**:  
- Handled interviewer’s manipulation, stayed calm.  
- Tip: Use STAR, show empathy and leadership (JavaTpoint HR).

## Key Takeaways and Preparation Tips

- **Online Test**:  
  - **Debugging**: Solve all questions, practice quick fixes (GFG Debugging).  
  - **Aptitude**: Focus on speed (RS Aggarwal).  
  - **Coding**: Solve all 3 problems, practice LeetCode easy-medium (#121, #1143).  
- **First Interview**:  
  - Master OOPS (GFG Java), DSA (LeetCode #121, GFG Tree, Palindrome).  
  - Be flexible with approaches (e.g., DP to greedy).  
- **Technical + ProFit + HR**:  
  - Study system design (Dining Philosophers, GFG OS).  
  - Practice puzzles (GFG Puzzles, 4-litre problem).  
  - Prepare probability (GFG Math).  
  - Use STAR for situational questions, stay calm under pressure.  
- **Resources**:  
  - **Coding**: LeetCode, GFG, InterviewBit.  
  - **OOPS**: StudyTonight, GFG Java.  
  - **OS/Puzzles**: GFG OS, GFG Puzzles.  
  - **HR**: JavaTpoint, Glassdoor.  
- **Interview Day**: Explain thought process, handle tough interviewers, ask about team culture.  
- **General**: Morgan Stanley values technical depth, problem-solving, and resilience; show confidence even if stuck.

**Final Note**: Code like a beast, vibe like a boss, and conquer that Spring Analyst role, bruh—Morgan Stanley’s waiting for your fire!