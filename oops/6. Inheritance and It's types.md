> Inheritance is a cornerstone of Object-Oriented Programming (OOP) that facilitates code reuse and establishes a hierarchical relationship between classes. By inheriting properties and methods from a parent class, a subclass can extend or override functionalities, enabling efficient and scalable application development. âš™ï¸ğŸ”„

This promotes code reuse, reduces redundancy, and supports polymorphism, making applications easier to develop and maintain. ğŸ’»âœ¨
## Types of Inheritance:

### 1.Â Single Inheritance:

> In single inheritance, a subclass inherits from a single parent class. This is the simplest form of inheritance and is widely used in Java.

Example :
```java
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();  // Inherited from Animal
        dog.bark();
    }
}
```
![](../pics/Pasted%20image%2020250619132935.png)
**ğŸ”‘Key Features:**

â€¢ A single subclass derives from one superclass.
â€¢ Promotes simplicity and clarity in the inheritance hierarchy.
### 2.Â Multilevel Inheritance :Â 

> In multilevel inheritance, a class inherits from a parent class, and another class further inherits from this child class, forming a chain.

Example :
```java
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Mammal extends Animal {
    void walk() {
        System.out.println("This mammal walks.");
    }
}

class Dog extends Mammal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();   // From Animal
        dog.walk();  // From Mammal
        dog.bark();  // From Dog
    }
}
```

![](../pics/Pasted%20image%2020250619133024.png)
**ğŸ”‘ Key Features:**
â€¢ Establishes a chain of inheritance.
â€¢ Enables deeper specialization of classes.
### 3.Â Hierarchical Inheritance :

> In hierarchical inheritance, multiple subclasses inherit from a single parent class. This allows different classes to share common properties and behaviors defined in the superclass.

Example :
```java
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

class Cat extends Animal {
    void meow() {
        System.out.println("The cat meows.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();
        dog.bark();

        Cat cat = new Cat();
        cat.eat();
        cat.meow();
    }
}
```
![](../pics/Pasted%20image%2020250619133059.png)
**ğŸ”‘ Key Features:**
â€¢ Multiple subclasses share common properties from a single superclass.
â€¢ Promotes code reuse and modularity.

### 4.Â Multiple Inheritance :Â 

> Java does not support Multiple inheritance directly due to the diamond problem, but it can be achieved using interfaces. In Multiple inheritance, A single class can inherit properties from multiple interfaces.

### ğŸ’Â What is the Diamond Problem?

The diamond problem arises in languages that allow multiple inheritance with classes. Imagine a scenario where a class inherits from two parent classes that both have a method with the same name. If the child class does not override the method, it creates ambiguity as to which implementation the child class should inherit. This leads to confusion and potential conflicts in the program.

**Problem Example :**
```java
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Cat meows");
    }
}

// âŒ This is NOT allowed in Java; causes compilation error
// Java does not support multiple class inheritance due to ambiguity

// public class HybridAnimal extends Dog, Cat {
//     public static void main(String[] args) {
//         HybridAnimal hybrid = new HybridAnimal();
//         hybrid.sound(); // Ambiguity: Dog or Cat?
//     }
// }
```

![](../pics/Pasted%20image%2020250619133159.png)

**ğŸ§  How Java Resolves This?**
Java avoids this problem by not allowing multiple inheritance with classes. Instead, Java provides interfaces as a way to achieve multiple inheritance.

When a class implements multiple interfaces, it must provide implementations for the methods defined in the interfaces. This eliminates ambiguity since the child class explicitly defines the behavior of inherited methods.

Solution Example :
```java
interface Dog {
    default void sound() {
        System.out.println("Dog barks");
    }
}

interface Cat {
    default void sound() {
        System.out.println("Cat meows");
    }
}

public class HybridAnimal implements Dog, Cat {
    @Override
    public void sound() {
        // Custom resolution logic
        Dog.super.sound(); // Choose to call Dog's sound
        // Cat.super.sound(); // Or call Cat's sound
    }

    public static void main(String[] args) {
        HybridAnimal hybrid = new HybridAnimal();
        hybrid.sound(); // Output: Dog barks
    }
}
```

![](../pics/Pasted%20image%2020250619133318.png)
**ğŸ”‘Key Features:**
â€¢ Achieved using interfaces to avoid ambiguity caused by multiple inheritance.
â€¢ Combines the benefits of various inheritance types.
### 5.Â Hybrid Inheritance :Â 

> Hybrid inheritance is a combination of more than one type of inheritance. It can involve both single inheritance and multiple inheritance.

In Java, hybrid inheritance is achieved by combining classes and interfaces. Since Java doesn't support multiple inheritance with classes (to avoid the diamond problem), this type of inheritance can only be implemented using interfaces alongside class inheritance.

Example :
```java
// Single inheritance
class Animal {
    void eat() {
        System.out.println("The animal eats food.");
    }
}

// Interface 1
interface Mammal {
    void walk();
}

// Interface 2
interface Pet {
    void play();
}

// Hybrid inheritance: class + multiple interfaces
class Dog extends Animal implements Mammal, Pet {
    @Override
    void eat() {
        System.out.println("The dog eats food.");
    }

    @Override
    public void walk() {
        System.out.println("The dog walks.");
    }

    @Override
    public void play() {
        System.out.println("The dog plays fetch.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();
        dog.walk();
        dog.play();
    }
}
```
![](../pics/Pasted%20image%2020250619133403.png)
## ğŸ‘ğŸ¼Advantages of Inheritance :Â 

### 1.Â Code Reusability:

Enables reuse of existing code, reducing redundancy and effort.

Example :
```java
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    // Inherits eat() method from Animal
}

class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat(); // Reuses the eat method from Animal
    }
}
```
### 2.Â Ease of Maintenance:

Centralizes common functionality, making updates and bug fixes more manageable.

Example :
```java
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    // Inherits eat() method from Animal
}

class Cat extends Animal {
    // Inherits eat() method from Animal
}

public class Main {
    public static void main(String[] args) {
        // Any improvement to eat() only needs to be done in Animal
        Animal animal = new Dog();
        animal.eat(); // Animal is eating

        animal = new Cat();
        animal.eat(); // Animal is eating
    }
}
```
### 3.Â Extensibility:

Allows developers to extend functionality without altering existing code.

Example :Â 
```java
class Animal {
    public void sleep() {
        System.out.println("Animal is sleeping");
    }
}

class Dog extends Animal {
    @Override
    public void sleep() {
        System.out.println("Dog is sleeping in its kennel");
    }
}

class Cat extends Animal {
    @Override
    public void sleep() {
        System.out.println("Cat sleeps in a tree");
    }
}

class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        myAnimal.sleep(); // Animal is sleeping
        myDog.sleep();    // Dog is sleeping in its kennel
        myCat.sleep();    // Cat sleeps in a tree
    }
}
```

In this example, Dog and Cat both inherit the sleep() method from Animal. You can extend the functionality of the sleep() method in each subclass by overriding it to add specific behavior for each subclass (Dog sleeping in a kennel, Cat sleeping in a tree).Â 

This is an example of extensibilityâ€”you donâ€™t need to modify the Animal class itself to extend its behavior for each subclass. You only need to add new behavior or change behavior in the subclasses as needed.

Inheritance makes it easier to add new types of animals with different sleeping behaviors by extending Animal without changing the original Animal class.

### 4.Â Supports Polymorphism:

Facilitates runtime polymorphism, enabling dynamic behaviour.

â€Example :Â 
```java
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Cat meows");
    }
}

class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog();
        myAnimal.sound(); // Dog barks

        myAnimal = new Cat();
        myAnimal.sound(); // Cat meows
    }
}
```
## ğŸ‘ğŸ¼Disadvantages of Inheritance :Â 

### 1.Â Increased Coupling:

Creates a tightly coupled relationship between classes, making changes in the superclass impact all subclasses.

Example :Â 
```java
class Animal {
    public void eat() {
        System.out.println("Animal eats");
    }
}

class Dog extends Animal {
    // Inherits eat() method from Animal
}

class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat(); // Reuses the eat method from Animal
    }
}
```

If we change Animal's eat method, it could break Dog's functionality leading to an ExceptionÂ Â Â Â Â Â which shows how a change in one particular method of the Parent class can break the properties ofÂ it's subclasses.
### 2.Â Complexity:

Overuse of inheritance can lead to overly complex and hard-to-maintain hierarchies.

Example :
```java
class Animal {}
class Mammal extends Animal {}
class Dog extends Mammal {}
class Bulldog extends Dog {}

class Main {
    public static void main(String[] args) {
        Bulldog bulldog = new Bulldog(); // Inherits from Dog â†’ Mammal â†’ Animal
    }
}
```

Understanding this deep nested level ofÂ inheritance structure may be difficult in larger systems to maintain and may require refactoring to make the structure more maintainable and scalable.

### 3.Â Reduced Flexibility:

A subclass is heavily dependent on the implementation of its superclass, which may limit customization.

Example :
```java
class Animal {
    public void sleep() {
        System.out.println("Animal is sleeping");
    }
}

class Dog extends Animal {
    // Inherits sleep() from Animal
}

class Cat extends Animal {
    // Inherits sleep() from Animal
}

class Main {
    public static void main(String[] args) {
        Animal dog = new Dog();
        Animal cat = new Cat();

        dog.sleep(); // Animal is sleeping
        cat.sleep(); // Animal is sleeping
    }
}
```

In this example, the Dog and Cat classes are both inheriting the sleep() method from Animal. However, suppose you wanted to make Dog sleep in a specific way, for instance, "Dog is sleeping in its kennel" ğŸ¶ğŸ  and Cat sleep in another way, "Cat sleeps in a tree" ğŸ±ğŸŒ³.

You would be forced to modify the sleep() method in the parent class, Animal, or override it in each subclass. This reduces flexibility because you can't change or extend sleep() behavior independently for each subclass without affecting the others. ğŸ”„

â€