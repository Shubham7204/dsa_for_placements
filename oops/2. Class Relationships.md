## ğŸŒ³The Family Tree of Classes: Inheritance

> Inheritance represents an "is-a" relationship where a subclass inherits properties and behaviors from its parent class.

Think of it like a family treeâ€”just as a Dog is an Animal, a subclass extends the functionality of itsÂ superclass.

```java
// Parent class
class Animal {
    void eat() {
        System.out.println("Animal is eating.");
    }
}

// Subclass inheriting from Animal
class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks: Woof Woof!");
    }
}

public class InheritanceDemo {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();  // Inherited behavior
        dog.bark(); // Specific behavior
    }
}
```

![](../pics/1741404500169-Frame-237-(2).png)
### Explanation:

- Animal is the parent class with a basic eat() method.
- Dog extends Animal and adds its own bark() method.
- The Dog class inherits behavior from Animal while adding its unique actions.
## ğŸ¤Side by Side: Association

Association is a general relationship where one class knows about or uses another. It's like a friendshipâ€”two entities are aware of each other, but they exist independently.

```java
// A Person can have a Car.
class Car {
    String model;

    Car(String model) {
        this.model = model;
    }

    void drive() {
        System.out.println("Driving a " + model);
    }
}

class Person {
    String name;

    // Association: A Person "has a" Car.
    Car car;

    Person(String name, Car car) {
        this.name = name;
        this.car = car;
    }

    void goForDrive() {
        System.out.println(name + " is going for a drive.");
        car.drive();
    }
}

public class AssociationDemo {
    public static void main(String[] args) {
        Car car = new Car("Tesla Model 3");
        Person person = new Person("Alice", car);
        person.goForDrive();
    }
}
```

![](../pics/Pasted%20image%2020250619121120.png)
### Explanation:

â€¢ Person has a reference to Car, representing an association.
â€¢ Both Person and Car exist independently. The Car doesn't rely solely on the Person for its existence.
## ğŸ¤—Â Aggregation: Grouping with a Twist

Aggregation is a specialized form of association that represents a "has-a" relationship where the parts can exist independently of the wholeâ€”but they are grouped together by a container.

Think of a Team and its Players: a team has players, yet the players can exist even if the team is disbanded.

```java
import java.util.ArrayList;
import java.util.List;

class Player {
    String name;

    Player(String name) {
        this.name = name;
    }
}

class Team {
    String teamName;

    // Aggregation: A team "has" players.
    List<Player> players = new ArrayList<>();

    Team(String teamName) {
        this.teamName = teamName;
    }

    void addPlayer(Player player) {
        players.add(player);
    }

    void showTeam() {
        System.out.println("Team " + teamName + " has players:");
        for (Player p : players) {
            System.out.println(" - " + p.name);
        }
    }
}

public class AggregationDemo {
    public static void main(String[] args) {
        Team team = new Team("Warriors");
        team.addPlayer(new Player("Stephen"));
        team.addPlayer(new Player("Klay"));
        team.showTeam();
    }
}
```
![](../pics/Pasted%20image%2020250619121704.png)
### Explanation:
â€¢ Team aggregates Player objects.
â€¢ Players exist independently of the teamâ€”they can join or leave different teams.
â€¢ This indicates that while the Team holds and manages Player instances, the players are not solely dependent on the team for their existence.
### Key Differences Between Association and Aggregation:

â€¢ Association is a general relationship (friendship) with no ownership implied; objects simply interact or use each other.
â€¢ Aggregation represents a â€œhas-aâ€ relationship where one object (the whole) contains or references other objects (the parts), but the parts can exist independently of the whole.
## â¤ï¸Bond for Life: Composition

Composition is a stronger form of aggregation with full ownershipâ€”if the whole is destroyed, the parts cannot exist independently. Think of a House and its Rooms: without the house, the rooms cease to exist.

```java
class Room {
    String name;

    Room(String name) {
        this.name = name;
    }
}

class House {
    // Composition: A House is composed of Rooms.
    private Room livingRoom;
    private Room kitchen;

    House() {
        // Rooms are created and owned by the House.
        livingRoom = new Room("Living Room");
        kitchen = new Room("Kitchen");
    }

    void showHouse() {
        System.out.println(
            "House contains: " + livingRoom.name + " and " + kitchen.name);
    }
}

public class CompositionDemo {
    public static void main(String[] args) {
        House house = new House();
        house.showHouse();
    }
}
```

![](../pics/Pasted%20image%2020250619121958.png)
### Explanation:

â€¢ House creates and controls the lifecycle of Room objects.
â€¢ The Room objects do not exist outside the context of the House.
â€¢ The composition relationships indicate that a House is composed of Room objects, meaning the rooms are created and owned by the house and do not exist independently.

## â³Just a Little Dependency: Dependency

Dependency represents a temporary relationship where one class uses another class, typically via method parameters or local variables. Itâ€™s like borrowing a tool for a short while.

```java
class Printer {
    void print(String message) {
        System.out.println("Printing: " + message);
    }
}

class Document {
    String content;

    Document(String content) {
        this.content = content;
    }

    // Dependency: Document uses Printer to print its content.
    void printDocument(Printer printer) {
        printer.print(content);
    }
}

public class DependencyDemo {
    public static void main(String[] args) {
        Document doc = new Document("Hello, World!");
        Printer printer = new Printer();
        doc.printDocument(printer);
    }
}
```
### Explanation:
â€¢ Document doesnâ€™t store a Printer; it simply uses one when needed.
â€¢ The relationship is transient and exists only during the method call.

### Key Differences Between Association and Dependency:

ğŸ”— **Association:**
Objects are passed (often via constructors or setters) and stored as persistent fields. This creates a long-term relationship where the object is available throughout the lifetime of the class. For example, a Person stores a reference to a Car and uses it whenever needed.

â¡ï¸ **Dependency:**
Objects are passed as method parameters and used only within that method's scope. This creates a short-term, temporary relationship where the object is used just for the duration of the method call, and isn't stored for later use. For example, a Document receives a Printer to print its content and doesn't keep a reference to the Printer afterward.

## ğŸ­Â Walking the Interface Tightrope: Realization (Interface Implementation)
Realization represents a relationship where a class implements an interface. Itâ€™s like signing a contract to provide specific behaviors.

```java
interface Payment {
    void pay();
}

class CreditCardPayment implements Payment {
    @Override
    public void pay() {
        System.out.println("Paid using Credit Card.");
    }
}

class CashPayment implements Payment {
    @Override
    public void pay() {
        System.out.println("Paid using Cash.");
    }
}

public class RealizationDemo {
    public static void main(String[] args) {
        Payment payment1 = new CreditCardPayment();
        Payment payment2 = new CashPayment();
        payment1.pay();
        payment2.pay();
    }
}
```

![](../pics/Pasted%20image%2020250619122209.png)
### Explanation:

â€¢ Payment is an interface that declares the pay() method.
â€¢ CreditCardPayment and CashPayment implement this interface, providing their own versions of pay().
## ğŸª¢Bringing It All Together

Simplified library management system
![](../pics/Pasted%20image%2020250619122226.png)
### Explanation

**ğŸ“– Readable Interface:**
Defines a contract with a read() method. The Book class implements this interface, ensuring that all books provide a reading behavior.

ğŸ“² **Book and EBook:**
Book has attributes for title and an associated Author. EBook extends Book by adding a fileFormat attribute. The inheritance arrow (solid line with a closed arrowhead) shows that EBook is a specialized type of Book.

ğŸ”— **Association (Book & Author):**
The arrow from Book to Author indicates that every book is written by an author. This is a simple association where both objects can exist independently.

ğŸ“š **Composition (Library & Book):**
The filled diamond from Library to Book indicates composition. A library is composed of books, meaning the library strongly owns its books.

ğŸ“–â¡ï¸ğŸ“• **Dependency (Reader & Book):**
The dashed arrow from Reader to Book denotes a dependency. A reader uses a book (for example, to read), but does not own it.

ğŸ“šâ¡ï¸ğŸ‘¥ **Aggregation (ReadingClub & Reader):**
The open diamond from ReadingClub to Reader represents aggregation. A reading club groups readers together, but readers can exist independently of the club.

|#|Relationship|Description|Nature|Direction|Ownership|Lifecycle Dependency|Cardinality|Example|Real-world Analogy|Code Example|UML Symbol|Use Case|Interview Insight|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|1ï¸âƒ£|**Association**|General relationship where one object uses or knows another|Loose|Bidirectional / Unidirectional|âŒ No|âŒ No|1:1, 1:N, M:N|`Person` â†” `Car`|A teacher and a student|`Person` has a `Car` field|Simple line â”€â”€â–¶|Any interaction where objects exist independently|**Common. Used when objects interact but don't depend on each other**|
|2ï¸âƒ£|**Aggregation**|Specialized Association where the "whole" can contain "parts" that exist independently|Loose (but structured)|Typically unidirectional|âœ… Weak/shared|âŒ No|1:N|`Team` aggregates `Player`|A university has professors; professors can leave|`List<Player>` in `Team` class|Line with **hollow diamond** â—‡â”€â”€â–¶|Modeling group/container patterns|**Part can belong to many wholes or none at all**|
|3ï¸âƒ£|**Composition**|Strong form of Aggregation where the "whole" owns and controls the "parts"|Tight|Unidirectional|âœ… Strong/exclusive|âœ… Yes|1:N|`House` composed of `Room`s|A human and their heart â€“ heart dies if human dies|`Room` objects created **inside** `House` constructor|Line with **filled diamond** â—†â”€â”€â–¶|Whole-part, tight lifecycle binding|**Parts die with whole; strong design ownership**|
|4ï¸âƒ£|**Dependency**|Temporary usage of one class by another through method or constructor|Very Loose|Unidirectional|âŒ No|âŒ No|Method-level|`Document` depends on `Printer` in `print()` method|Renting a cab â€” used and released|`printDocument(Printer p)`|**Dashed arrow** â”€â”€â•Œâ–¶|Utility functions, helper objects|**Object is used once and not retained**|
|5ï¸âƒ£|**Inheritance**|"Is-a" relationship where subclass inherits from a superclass|Static|Unidirectional (Topâ†’Down)|âŒ No|âŒ No|1:1|`Dog` is-an `Animal`|Triangle is-a triangle is-a shape|`class Dog extends Animal`|Solid line with **hollow triangle** ğŸ”¼|Polymorphism, code reuse|**"Is-a" check must always be logically valid**|
|6ï¸âƒ£|**Realization**|A class commits to implement an interface â€” contract-based|Static|Unidirectional|âŒ No|âŒ No|1:1|`CreditCardPayment implements Payment`|Agreeing to fulfill a service contract|`class A implements InterfaceX`|**Dashed line with hollow triangle** ğŸ”º|Plug-and-play modular design|**Allows polymorphism with flexibility**|

|Feature|Association|Aggregation|Composition|Dependency|Inheritance|Realization|
|---|---|---|---|---|---|---|
|**Type**|General|Wholeâ€“part|Strong wholeâ€“part|Temporary use|"Is-a"|"Implements"|
|**Lifespan Control**|No|Part lives after whole|Part dies with whole|Only during method call|N/A|N/A|
|**Binding Strength**|Loose|Moderate|Tight|Very loose|Strong|Strong|
|**Ownership**|No|Shared|Strong|None|N/A|N/A|
|**Example Object Use**|`Person` â†’ `Car`|`Team` â†’ `Players`|`House` â†’ `Rooms`|`Document` â†’ `Printer`|`Dog` â†’ `Animal`|`CreditCardPayment` â†’ `Payment`|
|**UML Symbol**|â”€â”€â–¶|â—‡â”€â”€â–¶|â—†â”€â”€â–¶|â”€â”€â•Œâ–¶|ğŸ”¼|ğŸ”º|
|**Code Location**|Fields|Fields (with List)|Fields (created internally)|Method params|Inheritance tree|Interface implementation|

|Relationship|Where Object Appears in Code|
|---|---|
|Association|`Car car;` in `Person` class|
|Aggregation|`List<Player> players = new ArrayList<>();` in `Team`|
|Composition|`Room room = new Room();` created inside `House` constructor|
|Dependency|`void printDocument(Printer printer)` â€” method param only|
|Inheritance|`class Dog extends Animal`|
|Realization|`class CashPayment implements Payment`|
