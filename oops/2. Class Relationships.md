## üå≥The Family Tree of Classes: Inheritance

> Inheritance represents an "is-a" relationship where a subclass inherits properties and behaviors from its parent class.

Think of it like a family tree‚Äîjust as a Dog is an Animal, a subclass extends the functionality of its¬†superclass.

```java
// Parent class
class Animal {
    void eat() {
        System.out.println("Animal is eating.");
    }
}

// Subclass inheriting from Animal
class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks: Woof Woof!");
    }
}

public class InheritanceDemo {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();  // Inherited behavior
        dog.bark(); // Specific behavior
    }
}
```

![](../pics/1741404500169-Frame-237-(2).png)
### Explanation:

- Animal is the parent class with a basic eat() method.
- Dog extends Animal and adds its own bark() method.
- The Dog class inherits behavior from Animal while adding its unique actions.
## ü§ùSide by Side: Association

Association is a general relationship where one class knows about or uses another. It's like a friendship‚Äîtwo entities are aware of each other, but they exist independently.

```java
// A Person can have a Car.
class Car {
    String model;

    Car(String model) {
        this.model = model;
    }

    void drive() {
        System.out.println("Driving a " + model);
    }
}

class Person {
    String name;

    // Association: A Person "has a" Car.
    Car car;

    Person(String name, Car car) {
        this.name = name;
        this.car = car;
    }

    void goForDrive() {
        System.out.println(name + " is going for a drive.");
        car.drive();
    }
}

public class AssociationDemo {
    public static void main(String[] args) {
        Car car = new Car("Tesla Model 3");
        Person person = new Person("Alice", car);
        person.goForDrive();
    }
}
```

![](../pics/Pasted%20image%2020250619121120.png)
### Explanation:

‚Ä¢ Person has a reference to Car, representing an association.
‚Ä¢ Both Person and Car exist independently. The Car doesn't rely solely on the Person for its existence.
## ü§ó¬†Aggregation: Grouping with a Twist

Aggregation is a specialized form of association that represents a "has-a" relationship where the parts can exist independently of the whole‚Äîbut they are grouped together by a container.

Think of a Team and its Players: a team has players, yet the players can exist even if the team is disbanded.

```java
import java.util.ArrayList;
import java.util.List;

class Player {
    String name;

    Player(String name) {
        this.name = name;
    }
}

class Team {
    String teamName;

    // Aggregation: A team "has" players.
    List<Player> players = new ArrayList<>();

    Team(String teamName) {
        this.teamName = teamName;
    }

    void addPlayer(Player player) {
        players.add(player);
    }

    void showTeam() {
        System.out.println("Team " + teamName + " has players:");
        for (Player p : players) {
            System.out.println(" - " + p.name);
        }
    }
}

public class AggregationDemo {
    public static void main(String[] args) {
        Team team = new Team("Warriors");
        team.addPlayer(new Player("Stephen"));
        team.addPlayer(new Player("Klay"));
        team.showTeam();
    }
}
```
![](../pics/Pasted%20image%2020250619121704.png)
### Explanation:
‚Ä¢ Team aggregates Player objects.
‚Ä¢ Players exist independently of the team‚Äîthey can join or leave different teams.
‚Ä¢ This indicates that while the Team holds and manages Player instances, the players are not solely dependent on the team for their existence.
### Key Differences Between Association and Aggregation:

‚Ä¢ Association is a general relationship (friendship) with no ownership implied; objects simply interact or use each other.
‚Ä¢ Aggregation represents a ‚Äúhas-a‚Äù relationship where one object (the whole) contains or references other objects (the parts), but the parts can exist independently of the whole.
## ‚ù§Ô∏èBond for Life: Composition

Composition is a stronger form of aggregation with full ownership‚Äîif the whole is destroyed, the parts cannot exist independently. Think of a House and its Rooms: without the house, the rooms cease to exist.

```java
class Room {
    String name;

    Room(String name) {
        this.name = name;
    }
}

class House {
    // Composition: A House is composed of Rooms.
    private Room livingRoom;
    private Room kitchen;

    House() {
        // Rooms are created and owned by the House.
        livingRoom = new Room("Living Room");
        kitchen = new Room("Kitchen");
    }

    void showHouse() {
        System.out.println(
            "House contains: " + livingRoom.name + " and " + kitchen.name);
    }
}

public class CompositionDemo {
    public static void main(String[] args) {
        House house = new House();
        house.showHouse();
    }
}
```

![](../pics/Pasted%20image%2020250619121958.png)
### Explanation:

‚Ä¢ House creates and controls the lifecycle of Room objects.
‚Ä¢ The Room objects do not exist outside the context of the House.
‚Ä¢ The composition relationships indicate that a House is composed of Room objects, meaning the rooms are created and owned by the house and do not exist independently.

## ‚è≥Just a Little Dependency: Dependency

Dependency represents a temporary relationship where one class uses another class, typically via method parameters or local variables. It‚Äôs like borrowing a tool for a short while.

```java
class Printer {
    void print(String message) {
        System.out.println("Printing: " + message);
    }
}

class Document {
    String content;

    Document(String content) {
        this.content = content;
    }

    // Dependency: Document uses Printer to print its content.
    void printDocument(Printer printer) {
        printer.print(content);
    }
}

public class DependencyDemo {
    public static void main(String[] args) {
        Document doc = new Document("Hello, World!");
        Printer printer = new Printer();
        doc.printDocument(printer);
    }
}
```
### Explanation:
‚Ä¢ Document doesn‚Äôt store a Printer; it simply uses one when needed.
‚Ä¢ The relationship is transient and exists only during the method call.

### Key Differences Between Association and Dependency:

üîó **Association:**
Objects are passed (often via constructors or setters) and stored as persistent fields. This creates a long-term relationship where the object is available throughout the lifetime of the class. For example, a Person stores a reference to a Car and uses it whenever needed.

‚û°Ô∏è **Dependency:**
Objects are passed as method parameters and used only within that method's scope. This creates a short-term, temporary relationship where the object is used just for the duration of the method call, and isn't stored for later use. For example, a Document receives a Printer to print its content and doesn't keep a reference to the Printer afterward.

## üé≠¬†Walking the Interface Tightrope: Realization (Interface Implementation)
Realization represents a relationship where a class implements an interface. It‚Äôs like signing a contract to provide specific behaviors.

```java
interface Payment {
    void pay();
}

class CreditCardPayment implements Payment {
    @Override
    public void pay() {
        System.out.println("Paid using Credit Card.");
    }
}

class CashPayment implements Payment {
    @Override
    public void pay() {
        System.out.println("Paid using Cash.");
    }
}

public class RealizationDemo {
    public static void main(String[] args) {
        Payment payment1 = new CreditCardPayment();
        Payment payment2 = new CashPayment();
        payment1.pay();
        payment2.pay();
    }
}
```

![](../pics/Pasted%20image%2020250619122209.png)
### Explanation:

‚Ä¢ Payment is an interface that declares the pay() method.
‚Ä¢ CreditCardPayment and CashPayment implement this interface, providing their own versions of pay().
## ü™¢Bringing It All Together

Simplified library management system
![](../pics/Pasted%20image%2020250619122226.png)
### Explanation

**üìñ Readable Interface:**
Defines a contract with a read() method. The Book class implements this interface, ensuring that all books provide a reading behavior.

üì≤ **Book and EBook:**
Book has attributes for title and an associated Author. EBook extends Book by adding a fileFormat attribute. The inheritance arrow (solid line with a closed arrowhead) shows that EBook is a specialized type of Book.

üîó **Association (Book & Author):**
The arrow from Book to Author indicates that every book is written by an author. This is a simple association where both objects can exist independently.

üìö **Composition (Library & Book):**
The filled diamond from Library to Book indicates composition. A library is composed of books, meaning the library strongly owns its books.

üìñ‚û°Ô∏èüìï **Dependency (Reader & Book):**
The dashed arrow from Reader to Book denotes a dependency. A reader uses a book (for example, to read), but does not own it.

üìö‚û°Ô∏èüë• **Aggregation (ReadingClub & Reader):**
The open diamond from ReadingClub to Reader represents aggregation. A reading club groups readers together, but readers can exist independently of the club.

### üîπ **1. Association**

- **Definition**: A general relationship where one object knows or uses another.
- **Nature**: Loose coupling.
- **Direction**: Can be bidirectional or unidirectional.
- **Ownership**: No ownership.
- **Lifecycle Dependency**: No dependency; both can live independently.
- **Cardinality**: Can be 1:1, 1:N, or M:N.
- **Example**: A `Person` is associated with a `Car`.
- **Real-world Analogy**: A teacher and a student‚Äîboth can exist independently.
- **Code**: `Car car;` inside the `Person` class.
- **UML Symbol**: Simple line (‚îÄ‚îÄ‚ñ∂).
- **Use Case**: Any interaction where objects work together but are not dependent.
- **Interview Insight**: Very common. Used when objects interact without ownership or lifecycle dependency.
### üîπ **2. Aggregation**

- **Definition**: A special form of association where a "whole" can contain "parts" that exist independently.
- **Nature**: Structured but still loosely coupled.
- **Direction**: Typically unidirectional.
- **Ownership**: Weak/shared ownership.
- **Lifecycle Dependency**: No. Parts can exist without the whole.
- **Cardinality**: 1:N.
- **Example**: A `Team` aggregates `Player` objects.
- **Real-world Analogy**: A university has professors who can leave or exist independently.
- **Code**: `List<Player> players = new ArrayList<>();` inside the `Team` class.
- **UML Symbol**: Hollow diamond (‚óá‚îÄ‚îÄ‚ñ∂).
- **Use Case**: Modeling containers or group relationships.
- **Interview Insight**: Part can belong to many wholes or none. Helpful in modular design.
### üîπ **3. Composition**

- **Definition**: A strong form of aggregation where the "whole" owns and controls the "parts".
- **Nature**: Tightly coupled.
- **Direction**: Unidirectional.
- **Ownership**: Strong/exclusive ownership.
- **Lifecycle Dependency**: Yes. Parts die when the whole is destroyed.
- **Cardinality**: 1:N.
- **Example**: A `House` is composed of `Room` objects.
- **Real-world Analogy**: A human and their heart ‚Äî the heart cannot live if the person dies.
- **Code**: `Room room = new Room();` created inside `House` constructor.
- **UML Symbol**: Filled diamond (‚óÜ‚îÄ‚îÄ‚ñ∂).
- **Use Case**: Whole-part modeling with tight lifecycle binding.
- **Interview Insight**: Shows strong design control; used when part cannot exist without the whole.
### üîπ **4. Dependency**
- **Definition**: A temporary relationship where one class uses another via a method or constructor.
- **Nature**: Very loosely coupled.
- **Direction**: Always unidirectional.
- **Ownership**: No ownership.
- **Lifecycle Dependency**: No.
- **Cardinality**: Applies at method level.
- **Example**: A `Document` depends on `Printer` in the `print()` method.
- **Real-world Analogy**: Renting a cab ‚Äî use and release.
- **Code**: `void printDocument(Printer printer)` ‚Äî used in method parameter only.
- **UML Symbol**: Dashed arrow (‚îÄ‚îÄ‚ïå‚ñ∂).
- **Use Case**: Utility functions, temporary helper classes.
- **Interview Insight**: Object is used briefly and not stored. Common in method calls and service layers.
### üîπ **5. Inheritance**
- **Definition**: "Is-a" relationship where a subclass inherits behavior and properties from a superclass.
- **Nature**: Static and tightly bound at compile time.
- **Direction**: Always unidirectional (top ‚Üí down).
- **Ownership**: No ownership.
- **Lifecycle Dependency**: No.
- **Cardinality**: 1:1.
- **Example**: A `Dog` is-an `Animal`.
- **Real-world Analogy**: A triangle is a shape.
- **Code**: `class Dog extends Animal`.
- **UML Symbol**: Solid line with a hollow triangle (üîº).
- **Use Case**: Reuse of common behavior, polymorphism.
- **Interview Insight**: Always check if the "is-a" relationship logically makes sense. Overuse can reduce flexibility.
### üîπ **6. Realization**
- **Definition**: A class implements an interface; i.e., it commits to a contract.    
- **Nature**: Static binding with flexibility.
- **Direction**: Unidirectional.
- **Ownership**: No ownership.
- **Lifecycle Dependency**: No.
- **Cardinality**: 1:1.
- **Example**: `CreditCardPayment` implements `Payment` interface.
- **Real-world Analogy**: Agreeing to a contract or service specification.
- **Code**: `class CashPayment implements Payment`.
- **UML Symbol**: Dashed line with hollow triangle (üî∫).
- **Use Case**: Plug-and-play modular systems, interface-driven design.
- **Interview Insight**: Encourages polymorphism with high flexibility. Interface methods must be implemented.

|Relationship|Where Object Appears in Code|
|---|---|
|Association|`Car car;` in `Person` class|
|Aggregation|`List<Player> players = new ArrayList<>();` in `Team`|
|Composition|`Room room = new Room();` created inside `House` constructor|
|Dependency|`void printDocument(Printer printer)` ‚Äî method param only|
|Inheritance|`class Dog extends Animal`|
|Realization|`class CashPayment implements Payment`|
