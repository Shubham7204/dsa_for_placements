## üå≥The Family Tree of Classes: Inheritance

> Inheritance represents an "is-a" relationship where a subclass inherits properties and behaviors from its parent class.

Think of it like a family tree‚Äîjust as a Dog is an Animal, a subclass extends the functionality of its¬†superclass.

```java
// Parent class
class Animal {
    void eat() {
        System.out.println("Animal is eating.");
    }
}

// Subclass inheriting from Animal
class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks: Woof Woof!");
    }
}

public class InheritanceDemo {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat();  // Inherited behavior
        dog.bark(); // Specific behavior
    }
}
```

![](../pics/1741404500169-Frame-237-(2).png)
### Explanation:

- Animal is the parent class with a basic eat() method.
- Dog extends Animal and adds its own bark() method.
- The Dog class inherits behavior from Animal while adding its unique actions.
## ü§ùSide by Side: Association

Association is a general relationship where one class knows about or uses another. It's like a friendship‚Äîtwo entities are aware of each other, but they exist independently.

```java
// A Person can have a Car.
class Car {
    String model;

    Car(String model) {
        this.model = model;
    }

    void drive() {
        System.out.println("Driving a " + model);
    }
}

class Person {
    String name;

    // Association: A Person "has a" Car.
    Car car;

    Person(String name, Car car) {
        this.name = name;
        this.car = car;
    }

    void goForDrive() {
        System.out.println(name + " is going for a drive.");
        car.drive();
    }
}

public class AssociationDemo {
    public static void main(String[] args) {
        Car car = new Car("Tesla Model 3");
        Person person = new Person("Alice", car);
        person.goForDrive();
    }
}
```

![](../pics/Pasted%20image%2020250619121120.png)
### Explanation:

‚Ä¢ Person has a reference to Car, representing an association.
‚Ä¢ Both Person and Car exist independently. The Car doesn't rely solely on the Person for its existence.
## ü§ó¬†Aggregation: Grouping with a Twist

Aggregation is a specialized form of association that represents a "has-a" relationship where the parts can exist independently of the whole‚Äîbut they are grouped together by a container.

Think of a Team and its Players: a team has players, yet the players can exist even if the team is disbanded.

```java
import java.util.ArrayList;
import java.util.List;

class Player {
    String name;

    Player(String name) {
        this.name = name;
    }
}

class Team {
    String teamName;

    // Aggregation: A team "has" players.
    List<Player> players = new ArrayList<>();

    Team(String teamName) {
        this.teamName = teamName;
    }

    void addPlayer(Player player) {
        players.add(player);
    }

    void showTeam() {
        System.out.println("Team " + teamName + " has players:");
        for (Player p : players) {
            System.out.println(" - " + p.name);
        }
    }
}

public class AggregationDemo {
    public static void main(String[] args) {
        Team team = new Team("Warriors");
        team.addPlayer(new Player("Stephen"));
        team.addPlayer(new Player("Klay"));
        team.showTeam();
    }
}
```
![](../pics/Pasted%20image%2020250619121704.png)
### Explanation:
‚Ä¢ Team aggregates Player objects.
‚Ä¢ Players exist independently of the team‚Äîthey can join or leave different teams.
‚Ä¢ This indicates that while the Team holds and manages Player instances, the players are not solely dependent on the team for their existence.
### Key Differences Between Association and Aggregation:

‚Ä¢ Association is a general relationship (friendship) with no ownership implied; objects simply interact or use each other.
‚Ä¢ Aggregation represents a ‚Äúhas-a‚Äù relationship where one object (the whole) contains or references other objects (the parts), but the parts can exist independently of the whole.
## ‚ù§Ô∏èBond for Life: Composition

Composition is a stronger form of aggregation with full ownership‚Äîif the whole is destroyed, the parts cannot exist independently. Think of a House and its Rooms: without the house, the rooms cease to exist.

```java
class Room {
    String name;

    Room(String name) {
        this.name = name;
    }
}

class House {
    // Composition: A House is composed of Rooms.
    private Room livingRoom;
    private Room kitchen;

    House() {
        // Rooms are created and owned by the House.
        livingRoom = new Room("Living Room");
        kitchen = new Room("Kitchen");
    }

    void showHouse() {
        System.out.println(
            "House contains: " + livingRoom.name + " and " + kitchen.name);
    }
}

public class CompositionDemo {
    public static void main(String[] args) {
        House house = new House();
        house.showHouse();
    }
}
```

![](../pics/Pasted%20image%2020250619121958.png)
### Explanation:

‚Ä¢ House creates and controls the lifecycle of Room objects.
‚Ä¢ The Room objects do not exist outside the context of the House.
‚Ä¢ The composition relationships indicate that a House is composed of Room objects, meaning the rooms are created and owned by the house and do not exist independently.

## ‚è≥Just a Little Dependency: Dependency

Dependency represents a temporary relationship where one class uses another class, typically via method parameters or local variables. It‚Äôs like borrowing a tool for a short while.

```java
class Printer {
    void print(String message) {
        System.out.println("Printing: " + message);
    }
}

class Document {
    String content;

    Document(String content) {
        this.content = content;
    }

    // Dependency: Document uses Printer to print its content.
    void printDocument(Printer printer) {
        printer.print(content);
    }
}

public class DependencyDemo {
    public static void main(String[] args) {
        Document doc = new Document("Hello, World!");
        Printer printer = new Printer();
        doc.printDocument(printer);
    }
}
```
### Explanation:
‚Ä¢ Document doesn‚Äôt store a Printer; it simply uses one when needed.
‚Ä¢ The relationship is transient and exists only during the method call.

### Key Differences Between Association and Dependency:

üîó **Association:**
Objects are passed (often via constructors or setters) and stored as persistent fields. This creates a long-term relationship where the object is available throughout the lifetime of the class. For example, a Person stores a reference to a Car and uses it whenever needed.

‚û°Ô∏è **Dependency:**
Objects are passed as method parameters and used only within that method's scope. This creates a short-term, temporary relationship where the object is used just for the duration of the method call, and isn't stored for later use. For example, a Document receives a Printer to print its content and doesn't keep a reference to the Printer afterward.

## üé≠¬†Walking the Interface Tightrope: Realization (Interface Implementation)
Realization represents a relationship where a class implements an interface. It‚Äôs like signing a contract to provide specific behaviors.

```java
interface Payment {
    void pay();
}

class CreditCardPayment implements Payment {
    @Override
    public void pay() {
        System.out.println("Paid using Credit Card.");
    }
}

class CashPayment implements Payment {
    @Override
    public void pay() {
        System.out.println("Paid using Cash.");
    }
}

public class RealizationDemo {
    public static void main(String[] args) {
        Payment payment1 = new CreditCardPayment();
        Payment payment2 = new CashPayment();
        payment1.pay();
        payment2.pay();
    }
}
```

![](../pics/Pasted%20image%2020250619122209.png)
### Explanation:

‚Ä¢ Payment is an interface that declares the pay() method.
‚Ä¢ CreditCardPayment and CashPayment implement this interface, providing their own versions of pay().
## ü™¢Bringing It All Together

Simplified library management system
![](../pics/Pasted%20image%2020250619122226.png)
### Explanation

**üìñ Readable Interface:**
Defines a contract with a read() method. The Book class implements this interface, ensuring that all books provide a reading behavior.

üì≤ **Book and EBook:**
Book has attributes for title and an associated Author. EBook extends Book by adding a fileFormat attribute. The inheritance arrow (solid line with a closed arrowhead) shows that EBook is a specialized type of Book.

üîó **Association (Book & Author):**
The arrow from Book to Author indicates that every book is written by an author. This is a simple association where both objects can exist independently.

üìö **Composition (Library & Book):**
The filled diamond from Library to Book indicates composition. A library is composed of books, meaning the library strongly owns its books.

üìñ‚û°Ô∏èüìï **Dependency (Reader & Book):**
The dashed arrow from Reader to Book denotes a dependency. A reader uses a book (for example, to read), but does not own it.

üìö‚û°Ô∏èüë• **Aggregation (ReadingClub & Reader):**
The open diamond from ReadingClub to Reader represents aggregation. A reading club groups readers together, but readers can exist independently of the club.

|#|Relationship|Description|Nature|Direction|Ownership|Lifecycle Dependency|Cardinality|Example|Real-world Analogy|Code Example|UML Symbol|Use Case|Interview Insight|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|1Ô∏è‚É£|**Association**|General relationship where one object uses or knows another|Loose|Bidirectional / Unidirectional|‚ùå No|‚ùå No|1:1, 1:N, M:N|`Person` ‚Üî `Car`|A teacher and a student|`Person` has a `Car` field|Simple line ‚îÄ‚îÄ‚ñ∂|Any interaction where objects exist independently|**Common. Used when objects interact but don't depend on each other**|
|2Ô∏è‚É£|**Aggregation**|Specialized Association where the "whole" can contain "parts" that exist independently|Loose (but structured)|Typically unidirectional|‚úÖ Weak/shared|‚ùå No|1:N|`Team` aggregates `Player`|A university has professors; professors can leave|`List<Player>` in `Team` class|Line with **hollow diamond** ‚óá‚îÄ‚îÄ‚ñ∂|Modeling group/container patterns|**Part can belong to many wholes or none at all**|
|3Ô∏è‚É£|**Composition**|Strong form of Aggregation where the "whole" owns and controls the "parts"|Tight|Unidirectional|‚úÖ Strong/exclusive|‚úÖ Yes|1:N|`House` composed of `Room`s|A human and their heart ‚Äì heart dies if human dies|`Room` objects created **inside** `House` constructor|Line with **filled diamond** ‚óÜ‚îÄ‚îÄ‚ñ∂|Whole-part, tight lifecycle binding|**Parts die with whole; strong design ownership**|
|4Ô∏è‚É£|**Dependency**|Temporary usage of one class by another through method or constructor|Very Loose|Unidirectional|‚ùå No|‚ùå No|Method-level|`Document` depends on `Printer` in `print()` method|Renting a cab ‚Äî used and released|`printDocument(Printer p)`|**Dashed arrow** ‚îÄ‚îÄ‚ïå‚ñ∂|Utility functions, helper objects|**Object is used once and not retained**|
|5Ô∏è‚É£|**Inheritance**|"Is-a" relationship where subclass inherits from a superclass|Static|Unidirectional (Top‚ÜíDown)|‚ùå No|‚ùå No|1:1|`Dog` is-an `Animal`|Triangle is-a triangle is-a shape|`class Dog extends Animal`|Solid line with **hollow triangle** üîº|Polymorphism, code reuse|**"Is-a" check must always be logically valid**|
|6Ô∏è‚É£|**Realization**|A class commits to implement an interface ‚Äî contract-based|Static|Unidirectional|‚ùå No|‚ùå No|1:1|`CreditCardPayment implements Payment`|Agreeing to fulfill a service contract|`class A implements InterfaceX`|**Dashed line with hollow triangle** üî∫|Plug-and-play modular design|**Allows polymorphism with flexibility**|

|Feature|Association|Aggregation|Composition|Dependency|Inheritance|Realization|
|---|---|---|---|---|---|---|
|**Type**|General|Whole‚Äìpart|Strong whole‚Äìpart|Temporary use|"Is-a"|"Implements"|
|**Lifespan Control**|No|Part lives after whole|Part dies with whole|Only during method call|N/A|N/A|
|**Binding Strength**|Loose|Moderate|Tight|Very loose|Strong|Strong|
|**Ownership**|No|Shared|Strong|None|N/A|N/A|
|**Example Object Use**|`Person` ‚Üí `Car`|`Team` ‚Üí `Players`|`House` ‚Üí `Rooms`|`Document` ‚Üí `Printer`|`Dog` ‚Üí `Animal`|`CreditCardPayment` ‚Üí `Payment`|
|**UML Symbol**|‚îÄ‚îÄ‚ñ∂|‚óá‚îÄ‚îÄ‚ñ∂|‚óÜ‚îÄ‚îÄ‚ñ∂|‚îÄ‚îÄ‚ïå‚ñ∂|üîº|üî∫|
|**Code Location**|Fields|Fields (with List)|Fields (created internally)|Method params|Inheritance tree|Interface implementation|

|Relationship|Where Object Appears in Code|
|---|---|
|Association|`Car car;` in `Person` class|
|Aggregation|`List<Player> players = new ArrayList<>();` in `Team`|
|Composition|`Room room = new Room();` created inside `House` constructor|
|Dependency|`void printDocument(Printer printer)` ‚Äî method param only|
|Inheritance|`class Dog extends Animal`|
|Realization|`class CashPayment implements Payment`|
