
Notification systems alert users about important news, product updates, events, and similar items. Common delivery channels include mobile push notifications, SMS, and email.

- Mobile push notification
- SMS
- Email

 

## Step 1 - Understand the Problem and Establish Design Scope

Clarify functional and non-functional requirements before diving into design. Example clarifying Q&A:

- **Candidate:** What types of notifications should the system support?
- **Interviewer:** Push notifications, SMS, Email.
- **Candidate:** Is this a real-time system?
- **Interviewer:** Soft real-time - deliver as soon as possible, but delays are acceptable under high load.
- **Candidate:** Which devices are supported?
- **Interviewer:** iOS, Android, and web (desktop/laptop).
- **Candidate:** What triggers notifications?
- **Interviewer:** Client applications or server-side events.
- **Candidate:** Can users opt out?
- **Interviewer:** Yes.
- **Candidate:** Expected volume?
- **Interviewer:** 10M mobile push, 1M SMS, 5M email per day.

Primary goals: reliability, scalability, throughput for the given volumes, extensibility to add providers, rate limiting and opt-out handling, and robust retry semantics.

 

## Step 2 - High-Level Design

Notification systems typically separate concerns: producers (services that request notifications), a notification service that validates and enqueues events, worker pools that deliver to third-party providers, and persistence/caching layers for metadata and throttling.

### Provider Overviews

#### iOS Push Notifications

A provider builds and sends notification requests to Apple Push Notification Service (APNs). Inputs include a device token (unique per app/device) and a JSON payload. APNs delivers to the iOS device.

![iOS push notifications](https://nextleet.com/images/ios-push-notifications.png)

#### Android Push Notifications

Android commonly uses Firebase Cloud Messaging (FCM) which functions similarly to APNs.

![Android push notifications](https://nextleet.com/images/android-push-notifications.png)

#### SMS

SMS delivery is handled by third-party providers like Twilio or Nexmo.

![SMS messages](https://nextleet.com/images/sms-messages.png)

#### Email

Email can be sent via third-party services such as SendGrid or Mailchimp.

![Email sending](https://nextleet.com/images/email-sending.png)

### High-Level Architecture

Components:

- Producers (service components or cron jobs) that trigger notifications.
- Notification API servers that validate requests and accept client authentication (appKey/appSecret).
- Cache for user/device metadata and templates.
- Persistent database for user preferences, templates, logs.
- Message queues to decouple ingestion from delivery (separate queues per provider recommended).
- Delivery workers that pull from queues and call third-party providers.
- Third-party providers (APNs, FCM, Twilio, Mailgun, etc.).

![Notification providers design](https://nextleet.com/images/notification-providers-design.png)

 

## Contact Info and Opt-In Handling

Collect and store contact information at signup or via user profile settings. Store device tokens, phone numbers, and email addresses with opt-in preferences for each channel.

![Contact info gathering](https://nextleet.com/images/contact-info-gathering.png)

Example tables: _users_, _devices_, _contact_preferences_, and _notification_templates_. Cache commonly accessed records for low-latency checks.

![Contact info db](https://nextleet.com/images/contact-info-db.png)

 

## Notification Sending/Receiving Flow

Typical lifecycle:

1. A service calls the Notification API to create a notification (with template id, recipients, and payload).
2. API servers validate input and authentication, fetch user/device metadata and templates from cache/database.
3. API servers push notification events into provider-specific message queues.
4. Workers pull events from queues, render provider-specific payloads, and call third-party providers.
5. Third-party providers deliver the message to the device or phone/email.
6. Workers record delivery status into a Notification Log DB and send metrics/events to analytics.

![High level design](https://nextleet.com/images/high-level-design.png)

Problems in a naive design: single point of failure, scaling difficulties, and performance bottlenecks when building heavy payloads (e.g., HTML emails) synchronously. Use queues and autoscaling to mitigate.

 

## Step 3 - Design Deep Dive: Reliability and Delivery Guarantees

Key reliability questions: how to avoid data loss and how to handle duplicates? What delivery semantics do we provide?

### Delivery Semantics

Often, notification systems target **at-least-once** delivery, because third-party providers or networks may cause retries. Exactly-once is difficult without provider support for idempotency keys. Where possible, use provider idempotency keys; otherwise deduplicate at higher layers.

### Notification Log and Retries

Workers should persist events and statuses to a Notification Log DB. If a delivery fails, the worker moves the event to a retry queue with exponential backoff. After a maximum retry count, the event is flagged for human investigation or routed to a dead-letter queue.

![Notification log DB](https://nextleet.com/images/notification-log-db.png)

### Deduplication

To reduce duplicate notifications, include a unique event id and track seen ids in a deduplication store (e.g., Redis set with TTL). If the third-party provider supports idempotency tokens, pass those when sending to avoid duplicate deliveries from provider retries.

 

## Additional Components and Considerations

### Notification Templates

Store templates for each notification type to avoid rebuilding payloads repeatedly. Templates can include placeholders and channel-specific variants (e.g., short text for push, HTML for email).

```
BODY:
You dreamed of it. We dared it. [ITEM NAME] is back - only until [DATE].

CTA:
Order Now. Or, Save My [ITEM NAME]
```

### Notification Settings

Respect user opt-ins and per-channel preferences. Example table: `user_id, channel, opt_in (boolean)`. Check preferences before queueing events.

### Rate Limiting

Implement rate limiting to prevent spamming users and to protect downstream providers. Enforce per-user and per-app quotas and backpressure when queues grow.

### Retry Mechanism

Workers should implement exponential backoff for transient errors and move permanently failing events to a dead-letter queue after configurable attempts. Alert developers on persistent failures.

### Security

Only authenticated, authorized clients should send notifications. Use appKey/appSecret or OAuth to authenticate producers. Validate templates and sanitize content to avoid injection attacks.

### Monitoring

Monitor queued notification counts, retry rates, provider error rates, delivery latencies, and opt-out rates. Dashboards and alerts should trigger autoscaling or ops intervention.

![Notifications queue monitoring](https://nextleet.com/images/notifications-queue.png)

### Events Tracking

Track opens, clicks, bounces, and delivery receipts. Emit these events asynchronously to analytics pipelines for business insights and product metrics.

![Notification events](https://nextleet.com/images/notification-events.png)

 

## Updated Detailed Design

Putting pieces together:

- API servers: Accept requests, validate, apply rate limits and auth, fetch metadata from cache, and enqueue events.
- Per-provider queues: Separate queues (or topics) per provider to isolate failures.
- Worker pools: Autoscaled workers that pull from provider queues and deliver messages to third-party providers while recording outcomes.
- Notification Log DB: Persistent log of all attempts and statuses for auditing, retries, and reporting.
- Cache & DB: Device tokens, preferences, templates, and user metadata in cache with database as source of truth.
- Dead-letter and retry queueing: For failed deliveries and long-term errors.

![Final notification design](https://nextleet.com/images/final-design.png)

Added features: authentication, rate limiting, retry logic, monitoring, and separate queues per third-party provider for fault isolation.

 

## Step 4 - Wrap Up and Operational Considerations

We designed a robust notification system that supports push, SMS, and email, scales with message queues and worker pools, respects user preferences, and uses retries and logs to improve reliability.

### Reliability

Persist events, use retries with exponential backoff, isolate providers with per-provider queues, and maintain a replayable notification log.

### Security

Authenticate and authorize producers, sanitize templates, and require appKey/appSecret for clients that send notifications.

### Monitoring & Scaling

Monitor queue lengths, worker health, provider error rates, and delivery success rates. Use these signals for autoscaling and alerts.

### User Experience

Offer granular opt-in controls, enforce rate limits to avoid spam, and provide users with preference management. Choose redirect codes (301 vs. 302) and message formats thoughtfully to balance analytics needs and performance.

### Analytics

Track delivery and engagement events and integrate with analytics pipelines to measure effectiveness and improve policies.

![Notification system final](https://nextleet.com/images/notification-providers-design.png)

Final note: design trade-offs include consistency of delivery state vs. availability, cost of retries vs. delivery guarantees, and how much complexity to push to third-party providers. State assumptions clearly and pick pragmatic defaults for production.