We'll design a distributed email service, similar to Gmail, in this chapter.

In 2020, Gmail had 1.8 billion active users, while Outlook had 400 million users worldwide.

Ask AI

## Step 1 - Understand the Problem and Establish Design Scope

- **C:** How many users use the system?
- **I:** 1 billion users.
- **C:** I think the following features are important - auth, send/receive email, fetch email, filter emails, search email, anti-spam protection.
- **I:** Good list. Don't worry about auth for now.
- **C:** How do users connect with email servers?
- **I:** Typically, email clients connect via SMTP, POP, IMAP, but we'll use HTTP for this problem.
- **C:** Can emails have attachments?
- **I:** Yes.

Ask AI

### Non-functional requirements

- Reliability - we shouldn't lose data.
- Availability - Use replication to prevent single points of failure and tolerate partial system failures.
- Scalability - The system should handle growth in the userbase.
- Flexibility and extensibility - The system should be easy to extend; we chose HTTP for web clients.

### Back-of-the-envelope estimation

- 1 billion users.
- Assume one person sends 10 emails per day -> ~100k emails per second.
- Assume one person receives 40 emails per day and each email has ~50KB metadata -> ~730 PB storage per year.
- Assume 20% of emails have attachments avg 500KB -> ~1,460 PB per year.

Ask AI

## Step 2 - Propose High-Level Design and Get Buy-In

We'll cover email basics, traditional vs distributed mail servers, high-level architecture, and send/receive flows.

Ask AI

### Email knowledge 101

Common protocols:

- SMTP - sending between servers.
- POP - download + remove from server.
- IMAP - server-side mail access/sync.
- HTTPS - used by webmail clients (not a mail protocol but common for web UI).

DNS MX records route mail between domains:

![dns-lookup](https://nextleet.com/images/dns-lookup.png)

Attachments are base64-encoded in emails and commonly limited (e.g., 25MB). Limits are configurable and differ between providers.

Ask AI

### Traditional mail servers

Traditional mail servers work well for smaller deployments and rely on SMTP/IMAP/POP. Emails were often stored as files on local disks.

![traditional-mail-server](https://nextleet.com/images/traditional-mail-server.png)

![local-dir-storage](https://nextleet.com/images/local-dir-storage.png)

As scale grows, local-disk per-mail becomes a bottleneck for IOPS and availability; disks fail and single servers become insufficient.

Ask AI

### Distributed mail servers

A distributed architecture supports high availability, reliability, and scale. It still supports SMTP/IMAP/POP for traditional clients but offers HTTP APIs for web clients.

Example REST APIs:

- POST /v1/messages - send a message to recipients (To/Cc/Bcc).
- GET /v1/folders - list folders for an account.
- GET /v1/folders/{:folder_id}/messages - list messages in a folder with pagination.
- GET /v1/messages/{:message_id} - get a specific message.

Example folders response:

```
[{id: string, name: string, user_id: string}]
```

Example message response:

```
{
  user_id: string,
  from: {name: string, email: string},
  to: [{name: string, email: string}],
  subject: string,
  body: string,
  is_read: boolean
}
```

![high-level-architecture](https://nextleet.com/images/high-level-architecture.png)

- Webmail - browser-based UI.
- Web servers - public request/response endpoints.
- Real-time servers - push notifications via WebSockets (fallback to long-polling).
- Metadata DB - stores email metadata (headers, small bodies).
- Attachment store - object store (e.g., S3) for large attachments.
- Distributed cache - Redis/others for recent emails.
- Search store - full-text search (Elasticsearch or similar).

Ask AI

### Email sending flow

![email-sending-flow](https://nextleet.com/images/email-sending-flow.png)

1. User presses send; a request goes to the load balancer.
2. The load balancer rate limits and routes to the web server.
3. The web server validates (size, recipients) and optionally short-circuits for same-domain delivery, but runs spam checks first.
4. Valid messages are placed on a message queue; attachment references point to the object store.
5. Invalid messages go to an error queue.
6. SMTP outgoing workers consume the queue, run spam/virus checks, and attempt delivery to destination servers (with retries, backoff).
7. Store a copy in the sender's Sent folder.

Monitor outgoing queue size - growth indicates destination server issues or insufficient consumers.

Ask AI

### Email receiving flow

![email-receiving-flow](https://nextleet.com/images/email-receiving-flkow.png)

1. Incoming SMTP load balancer distributes inbound mail to SMTP servers.
2. SMTP servers enforce acceptance policy (spam checks, invalid addresses).
3. For large attachments, store data in the object store and keep a reference in metadata.
4. Mail processing workers perform checks then persist metadata, write attachments to the object store, update caches, and notify real-time servers.
5. Offline users get messages via the HTTP API when they reconnect.

Ask AI

## Step 3 - Design Deep Dive

Deep dives into metadata DB, deliverability, search, and scalability.

Ask AI

### Metadata database

Characteristics:

- Headers are small and frequently accessed.
- Body size varies; typically read once.
- Most operations are per-user isolated (fetch, mark-read, search).
- Recency matters: recent emails are accessed more.
- High reliability: data loss is unacceptable.

Options and trade-offs:

- Relational DB - indexes good for headers/body but not optimized for huge single-row blobs.
- Distributed object store - good for attachments/backups but poor for indexing/queries.
- NoSQL / wide-column stores (e.g., BigTable/Cassandra) - used at large scale for throughput and locality; Google BigTable powers Gmail internally.

Partition by `user_id` so one user's data resides on the same shard - this simplifies per-user queries.

Suggested tables (logical):

- folders - list folders per user.
- emails - primary store for email metadata (email_id as timeuuid for time-sorted queries).
- attachments - references to the object store.

Because filtering on non-partition keys is expensive in certain distributed stores, denormalize for read patterns (e.g., maintain read/unread tables or inverted indices scoped per user).

Favor consistency over availability (CP) for email metadata: in case of failover, updates may be briefly unavailable.

Ask AI

### Email deliverability

Getting mail into recipients' inboxes (not spam) requires reputation and operational effort.

- Dedicated IPs - separate IPs for different sending categories.
- Classify emails - separate marketing vs. transactional to protect reputation.
- IP warm-up - gradually increase send volume over weeks to build reputation.
- Ban spammers quickly.
- Feedback loops - receive ISP complaints and act.
- Email authentication - SPF, DKIM, DMARC to prevent phishing and improve trust.

These are operational practices - crucial, but domain-specific.

Ask AI

### Search

Email search is user-scoped full-text search with filters. Indexing is write-heavy because operations mutate the index, but read/queries can be less frequent.

Options:

- Use Elasticsearch (or similar) with `user_id` as partitioning to localize user data.
- Mutations are processed asynchronously (via Kafka) to decouple reindexing from metadata writes.
- Search queries execute synchronously against the search cluster.

To build write-optimized indexes consider LSM-tree techniques (as in RocksDB/Cassandra) to favor sequential writes and merge compactions.

Trade-offs:

- Elasticsearch: off-the-shelf, scales reasonably, a separate service to maintain.
- Custom engine: tailored to email workload, potentially more efficient at extreme scale, but a large engineering cost.

Ask AI

### Scalability and availability

Most user operations are independent, so services can scale horizontally. Key availability techniques:

- Stateless frontends behind LB - scale by replication.
- Stateful stores replicated across regions.
- Multi-DC deployment with leader-follower failover.
- Use message queues (Kafka) to buffer spikes and decouple components.

![multi-dc-example](https://nextleet.com/images/multi-dc-example.png)

For attachment storage, use object storage with lifecycle policies (hot/cold tiers) and deduplication to save space.

Ask AI

## Step 4 - Wrap up

Designing a distributed email service touches on many hard problems: storage at petabyte+ scale, delivery reliability, spam and reputation management, full-text search, and operational practices.

Additional talking points you can mention:

- Fault tolerance - handling node failures and retries in queues/workers.
- Compliance - PII handling and GDPR requirements.
- Security - encryption at rest/in transit, phishing protection.
- Optimizations - deduplication of attachments, CDN for static assets, caching of recent messages.