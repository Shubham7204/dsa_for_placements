We'll design a payment system in this chapter, which underpins all of modern e-commerce. A payment system is used to settle financial transactions, transferring monetary value.

Ask AI

## Step 1 - Understand the Problem and Establish Design Scope

- **C:** What kind of payment system are we building?
- **I:** A payment backend for an e-commerce system, similar to Amazon.com. It handles everything related to money movement.
- **C:** What payment options are supported?
- **I:** The system should support many options; for the interview we focus on credit card payments.
- **C:** Do we handle credit card processing ourselves?
- **I:** No - due to compliance we rely on PSPs / tokenization.
- **C:** Do we store credit card data?
- **I:** No - due to compliance we rely on PSPs / tokenization.
- **C:** Is the application global / multi-currency?
- **I:** Global, but assume a single currency for interview simplicity.
- **C:** How many transactions/day?
- **I:** 1 million transactions per day.
- **C:** Do we support payouts?
- **I:** Yes - we need pay-out flows for sellers.
- We must support reconciliations to fix inconsistencies between internal and external systems.

Ask AI

### Functional requirements

- Pay-in flow - accept money from customers on behalf of merchants.
- Pay-out flow - send money to sellers (payouts).

### Non-functional requirements

- Reliability and fault tolerance - failed payments must be handled carefully.
- Reconciliation - nightly/periodic reconciliation with PSPs and the ledger.

### Back-of-the-envelope estimation

1M transactions/day -> ~10 TPS average; strong consistency and correctness are more important than raw throughput.

Ask AI

## Step 2 - Propose High-Level Design and Get Buy-In

At a high level there are three actors participating in money movement: a buyer, the payment service (ours), and an external PSP / banks.

![high-level-flow](https://nextleet.com/images/high-level-flow.png)

Ask AI

### Pay-in Flow

High-level components: payment service, payment executor, PSP (Payment Service Provider), card schemes, ledger, wallet.

![pay-in-flow-high-level](https://nextleet.com/images/payin-flow-high-level.png)

1. A user places an order; a payment event is sent to the payment service.
2. The payment service persists the event and validates (fraud/risk checks).
3. The payment executor processes payment orders (idempotent), and calls the PSP API.
4. The PSP communicates with card schemes / banks to capture funds.
5. On success, the payment service updates wallet balances and records entries in the ledger.

Ask AI

### APIs for Payment Service

Create payment (Pay-in):

```
POST /v1/payments
{
  "buyer_info": { ... },
  "checkout_id": "some_id",
  "credit_card_info": { ... },
  "payment_orders": [{ ... }, { ... }]
}
```

Example payment_order:

```
{
  "seller_account": "SELLER_IBAN",
  "amount": "3.15",
  "currency": "USD",
  "payment_order_id": "globally_unique_payment_id"
}
```

Notes: `payment_order_id` is forwarded to PSP as an idempotency key; amounts are strings (avoid floating point).

Fetch payment status:

```
GET /v1/payments/{:id}
// Returns execution status by payment_order_id
```

Ask AI

### Payment service data model

We maintain `payment_events` and `payment_orders`. Strong consistency is required - prefer a relational DB with ACID guarantees.

`payment_events` table (example fields): `checkout_id` (PK), `buyer_info` (FK/string), `seller_info`, `credit_card_info/token`, `is_payment_done` (boolean), `created_at`.

`payment_orders` table (example fields): `payment_order_id` (PK), `buyer_account`, `amount` (string), `currency`, `checkout_id` (FK), `payment_order_status` ENUM (NOT_STARTED, EXECUTING, SUCCESS, FAILED), `ledger_updated` (bool), `wallet_updated` (bool), `created_at`.

Payment transitions are managed by background jobs monitoring in-flight payments and alerting if stuck.

Ask AI

### Double-entry Ledger & Wallet

Use double-entry accounting: every movement generates two entries (debit and credit). This guarantees traceability and that all entries sum to zero.

Example:

|Account|Debit|Credit|
|---|---|---|
|buyer|$1||
|seller||$1|

The wallet keeps a merchant's balance; the ledger stores immutable transaction history. Ledger updates must be atomic with wallet balance updates.

Ask AI

### Hosted Payment Page & Tokenization

To avoid PCI compliance scope, prefer PSP-hosted payment pages or client-side tokenization where a PSP returns a token (card token) that our backend uses for charges.

![hosted-payment-page](https://nextleet.com/images/hosted-payment-page.png)

Ask AI

### Pay-out Flow

Pay-outs move money from our platform bank account to merchant bank accounts. We may use third-party payout providers (Tipalti, Stripe Connect Payouts) to handle KYC, compliance, and rails.

Pay-outs involve significant bookkeeping, regulatory checks, and settlement windows.

Ask AI

## Step 3 - Design Deep Dive

Focus: PSP integration, reconciliation, long-running payments, inter-service communication, failed payments, idempotency, and consistency.

Ask AI

### PSP Integration

Integrate with PSPs either via direct API (we collect tokens and call PSP) or via hosted pages. PSPs provide idempotency, webhooks, and settlement reports. Large organizations sometimes integrate directly with banks/card schemes but usually rely on PSPs.

![hosted-payment-page-workflow](https://nextleet.com/images/hosted-payment-page-workflow.png)

Ask AI

### Reconciliation

Nightly/periodic reconciliation: a PSP sends settlement files; we compare the PSP settlement to our ledger and wallet balances. We then classify mismatches into: auto-fixable, semi-automatic (for the finance team), and manual investigations.

![settlement-report](https://nextleet.com/images/settlement-report.png)

Ask AI

### Handling payment processing delays

Some payments can be pending (fraud review, 3D Secure). Strategies: show a pending status to users, poll the PSP if there are no webhooks, provide user-facing status pages and email updates, and have background jobs to re-check.

Ask AI

### Communication among internal services

Synchronous HTTP: simple but couples services and fails under downstream outages. Asynchronous (message queues) improves resilience and decoupling.

Use pub/sub patterns for multiple downstream consumers (ledger, notifications, analytics). Use single-consumer queues for operations requiring one consumer (payment executor).

![single-receiver](https://nextleet.com/images/single-receiver.png)

Ask AI

### Handling failed payments

Mechanisms: track payment state, push transient failures to a retry queue with exponential backoff, and send terminal failures to dead-letter queues for manual inspection.

![failed-payments](https://nextleet.com/images/failed-payments.png)

Ask AI

### Exactly-once processing & Idempotency

Prevent double charges using idempotency keys (UUID / `payment_order_id`). Persist idempotency keys in a DB with uniqueness constraints so repeated requests return the original result. Combine with PSP-side idempotency (nonce) for robust deduplication.

![idempotency-example](https://nextleet.com/images/idempotency-example.png)

Ask AI

### Consistency

Services involved: PSP, ledger, wallet, payment service. Use an ACID relational DB for critical state. Serve reads/writes from the primary to avoid replica lag anomalies. For cross-service coordination, consider distributed transactions only if necessary - otherwise use reliable asynchronous flows + reconciliation.

If strong distributed consistency is needed across regions, consider consensus-based databases (CockroachDB/YugabyteDB) or coordinate with strongly-consistent primitives.

Ask AI

### Payment security

- Use TLS for all communications.
- Encrypt sensitive fields and rely on PSP tokenization for card data.
- Certificate pinning to mitigate MITM.
- Rate limiting and WAF to mitigate DDoS.
- PCI-DSS compliance when applicable - minimize scope via tokenization/hosted pages.
- Fraud detection: AVS, CVV, behavioral analysis, risk-scoring.

Ask AI

## Step 4 - Wrap Up

Summary: Payment systems prioritize correctness, auditability, and reliability over raw throughput. Use PSPs for card rails and tokenization; keep a strong ACID-backed ledger and wallet; implement idempotency, retries, and robust reconciliation pipelines.

Additional talking points: monitoring & alerting, debugging tools for failed payments, multi-currency and FX considerations, regional payment methods, payout compliance/KYC, Google/Apple Pay integration.