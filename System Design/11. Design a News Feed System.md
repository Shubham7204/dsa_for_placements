
A news feed is a constantly updating list of stories presented on a user's home page. It can include status updates, photos, videos, links, and other media.

This problem appears in many interview forms: design Facebook News Feed, Twitter timeline, Instagram feed, etc. The core challenge is how to deliver relevant, up-to-date posts to many users with low latency and high availability.

 

## Step 1 - Understand the problem and establish design scope

Clarify the exact requirements before designing. Example Q&A from the interviewer:

- **Q:** Mobile, web app?
- **A:** Both.
- **Q:** Important features?
- **A:** Users can publish posts and see friends' posts on their feed.
- **Q:** Sorting: reverse-chronological or ranked?
- **A:** For simplicity, assume reverse chronological order.
- **Q:** Max number of friends per user?
- **A:** 5000.
- **Q:** Traffic volume?
- **A:** 10 million daily active users (DAU).
- **Q:** Can feeds contain media?
- **A:** Yes; images and video are allowed.

Non-functional goals: low latency retrieval, high throughput for reads and writes, scalability, and fault tolerance.

 

## Step 2 - High-level design and get buy-in

There are two main pieces to design:

- **Feed publishing** - persist a user's post and populate friends' feeds.
- **Newsfeed building** - aggregate a user's friends' posts into a feed for display.

### Newsfeed API

Main endpoints:

- `POST /v1/me/feed` - publish a post; payload includes content and an auth token.
- `GET /v1/me/feed` - retrieve the user's news feed; payload includes auth token and pagination.

### High-level flows

![feed publishing](https://nextleet.com/images/feed-publishing.png)

Feed publishing: client → load balancer → web servers → post service (persist to DB + cache) → fanout service (populate friends' feeds) → notification service.

![newsfeed building](https://nextleet.com/images/newsfeed-building.png)

Newsfeed building: client requests feed → load balancer → web servers → newsfeed service → read precomputed feed from cache (or compute on-the-fly) → hydrate posts and return JSON.

 

## Step 3 - Design deep dive

We dive into the publishing and retrieval flows, caching, and trade-offs of different fanout strategies.

 

### Feed publishing deep dive

Web servers authenticate requests, enforce rate limits (to prevent spam), and forward valid posts to the post service.

The post service persists the post to durable storage and updates caches for quick reads.

#### Fanout service

Fanout delivers a new post to followers' feeds. There are three main approaches: push (fanout on write), pull (fanout on read), and hybrid:

- **Fanout on write (push)**: when a user posts, the system pushes the post to every follower's feed cache. Pros: reads are fast. Cons: expensive for users with many followers (hotkey/celebrity problem), and wasted work for inactive followers.
- **Fanout on read (pull)**: at read time, fetch the latest posts from friends. Pros: cheaper for write-heavy workloads and inactive followers. Cons: read latency increases.
- **Hybrid**: precompute feeds for regular users (push) and compute on read for celebrities/very popular accounts (pull).

![fanout service](https://nextleet.com/images/fanout-service.png)

Typical fanout workflow: fetch follower IDs from the social graph DB, filter (muted/blocked), and enqueue fanout jobs. Fanout workers consume jobs and write `<user_id, post_id>` entries into the feed store (cache) for each follower.

Note: the example in some references shows storing a `<post_id, user_id>` mapping in cache; that is likely an error. Storing `<user_id, post_id>` (e.g., a list or sorted set of post IDs keyed by user) allows quick retrieval of a user's feed.

![feed publishing deep dive](https://nextleet.com/images/feed-publishing-deep-dive.png)

 

### News feed retrieval deep dive

When a user requests their feed:

1. Load balancer directs the request to a web server.
2. Web server calls the newsfeed service (authenticated).
3. Newsfeed service reads a list of `post_id`s from the newsfeed cache (if precomputed) or composes the list by querying friend feeds (pull).
4. Hydrate each `post_id`: fetch post content, user metadata (username, avatar), action states (liked, commented), and media references.
5. Return the fully-hydrated feed JSON to the client; media files are referenced via CDN URLs.

Hydration can be parallelized and backed by several caches: content cache (post body), user cache (profiles), and action counters. If items are not in cache, read from the DB.

![news feed retrieval deep dive](https://nextleet.com/images/news-feed-retrieval-deep-dive.png)

 

### Cache architecture

Caching is critical in a news feed system to achieve low-latency responses. We typically use multiple cache layers:

1. **Newsfeed cache** - stores lists of post IDs for a user (precomputed feed).
2. **Content cache** - stores full post data; hot posts live in memory.
3. **Social graph cache** - caches friend/follower lists to speed fanout and pull operations.
4. **Action cache** - stores user actions on posts (likes, replies) for fast hydration.
5. **Counters cache** - counters for likes, comments, followers, etc.

![cache layers](https://nextleet.com/images/cache-layer.png)

Use LRU or LFU eviction policies and warm caches for popular users. A combination of Redis (in-memory) and CDN for media is common.

 

### Scaling considerations and hotkeys

Key challenges and mitigation strategies:

- **Celebrity accounts (hotkeys):** accounts with millions of followers create massive fanout work. Use pull for these accounts, or special sharding strategies and fanout scheduling.
- **Sharding:** shard users and their feeds by user-id hash or consistent hashing to distribute load.
- **Asynchronous processing:** push expensive work (fanout, notifications) to background workers and queues.
- **Rate limiting:** limit posting rate to protect the system from abuse.
- **Media handling:** store images and videos in object storage and serve via CDN to avoid hitting the feed service with large payloads.

 

### Operational concerns

Monitor key metrics: read/write QPS, feed retrieval latency, cache hit ratios, fanout job queue depth, and error rates.

Automated deployments and canary rollouts are important to prevent breaking the feed generation pipeline. Have circuit breakers for downstream services (DB, cache, CDN).

Multi-datacenter support: route users to nearest datacenter and replicate or cross-populate feeds as required. Decide on consistency model: relaxed eventual consistency is commonly acceptable for feeds.

 

## Step 4 - Wrap up

We designed a news feed system that covers feed publishing (post persistence and fanout) and feed retrieval (precomputed and on-the-fly strategies). Major takeaways:

- Use a hybrid fanout model: push for typical users, pull for celebrities.
- Cache aggressively across multiple layers: feed lists, post content, social graph, actions, and counters.
- Decouple work via message queues and background workers for fanout and notifications.
- Mitigate hotkeys with special treatment (pull model, sharding, rate limiting).
- Store media in object storage and serve via CDN.

Related topics to discuss: vertical vs. horizontal DB scaling, SQL vs. NoSQL trade-offs, master-slave replication, read replicas, sharding strategies, consistency models, multiple data centers, and monitoring. Always state your assumptions and justify trade-offs when describing the design in an interview.

Key metrics to monitor: QPS and latency for both feed reads and writes, cache hit rates, and queue depths for fanout workers.