This chapter focuses on designing a scalable backend for an application which enables users to share their location and discover friends who are nearby.

The major difference with the proximity chapter is that in this problem, locations constantly change, whereas in that one, business addresses more or less stay the same.

Ask AI

## Step 1: Understand the Problem and Establish Design Scope

Some questions to drive the interview:

- **C:** How geographically close is considered to be "nearby"?
- **I:** 5 miles, this number should be configurable.
- **C:** Is distance calculated as straight-line distance vs. taking into consideration e.g. a river in-between friends?
- **I:** Yes, that is a reasonable assumption.
- **C:** How many users does the app have?
- **I:** 1 billion users and 10% of them use the nearby friends feature.
- **C:** Do we need to store location history?
- **I:** Yes, it can be valuable for e.g. machine learning.
- **C:** Can we assume inactive friends will disappear from the feature in 10 minutes?
- **I:** Yes.
- **C:** Do we need to worry about GDPR, etc?
- **I:** No, for simplicity's sake.

Ask AI

### Functional Requirements

- Users should be able to see nearby friends on their mobile app. Each friend has a distance and timestamp, indicating when the location was updated.
- Nearby friends list should be updated every few seconds.

Ask AI

### Non-functional Requirements

- Low latency - it's important to receive location updates without too much delay.
- Reliability - Occasional data point loss is acceptable, but the system should be generally available.
- Eventual consistency - Location data store doesn't need strong consistency. A few seconds delay in receiving location data in different replicas is acceptable.

Ask AI

### Back-of-the-Envelope Estimation

Some estimations to determine potential scale:

- Nearby friends are friends within 5-mile radius.
- Location refresh interval is 30 seconds. Human walking speed is slow, hence, no need to update location too frequently.
- On average, 100 million users use the feature every day with 10% concurrent users, i.e. 10 million.
- On average, a user has 400 friends, all of them use the nearby friends feature.
- App displays 20 nearby friends per page.
- Location Update QPS = 10 million / 30 â‰ˆ 334k updates per second.

Ask AI

## Step 2: Propose High-Level Design and Get Buy-In

Before exploring API and data model design, we'll study the communication protocol we'll use as it's less ubiquitous than traditional request-response communication model.

### High-level Design

At a high level we'd want to establish effective message passing between peers. This can be done via a peer-to-peer protocol, but that's not practical for a mobile app with flaky connection and tight power consumption constraints.

A more practical approach is to use a shared backend as a fan-out mechanism towards friends you want to reach:

What does the backend do?

- Receives location updates from all active users.
- For each location update, find all active users which should receive it and forward it to them.
- Do not forward location data if distance between friends is beyond the configured threshold.

This sounds simple but the challenge is to design the system for the scale we're operating with.

Ask AI

### System Architecture Components

We'll start with a simpler design at first and discuss a more advanced approach in the deep dive:

- The load balancer spreads traffic across REST API servers as well as bidirectional WebSocket servers.
- The REST API servers handle auxiliary tasks such as managing friends, updating profiles, etc.
- The WebSocket servers are stateful servers, which forward location update requests to respective clients. They also manage seeding the mobile client with nearby friends locations at initialization.
- Redis location cache is used to store the most recent location data for each active user. There is a TTL set on each entry in the cache. When the TTL expires, the user is no longer active and their data is removed from the cache.
- User database stores user and friendship data. Either a relational or NoSQL database can be used for this purpose.
- Location history database stores a history of user location data, not necessarily used directly within the nearby friends feature, but instead used to track historical data for analytical purposes.
- Redis pub/sub is used as a lightweight message bus which enables different topics for each user channel for location updates.

Ask AI

### Periodic Location Update Flow

Here's how the periodic location update flow works:

1. Mobile client sends a location update to the load balancer.
2. Load balancer forwards location update to the WebSocket server's persistent connection for that client.
3. WebSocket server saves location data to location history database.
4. Location data is updated in location cache. WebSocket server also saves location data in-memory for subsequent distance calculations for that user.
5. WebSocket server publishes location data in user's channel via Redis pub/sub.
6. Redis pub/sub broadcasts location update to all subscribers for that user channel, i.e. servers responsible for the friends of that user.
7. Subscribed WebSocket servers receive location update, calculate which users the update should be sent to and sends it.

On average, there's going to be 40 location updates to forward as a user has 400 friends on average and 10% of them are online at a time.

Ask AI

### API Design

#### WebSocket Routines

WebSocket routines we'll need to support:

- Periodic location update - user sends location data to WebSocket server.
- Client receives location update - server sends friend location data and timestamp.
- WebSocket client initialization - client sends user location, server sends back nearby friends location data.
- Subscribe to a new friend - WebSocket server sends a friend ID mobile client is supposed to track e.g. when friend appears online for the first time.
- Unsubscribe a friend - WebSocket server sends a friend ID, mobile client is supposed to unsubscribe from due to e.g. friend going offline.

#### HTTP API

Traditional request/response payloads for auxiliary responsibilities.

Ask AI

### Data Model

- The location cache will store a mapping between user_id and lat, long, timestamp. Redis is a great choice for this cache as we only care about current location and it supports TTL eviction which we need for our use case.
- Location history table stores the same data but in a relational table with the four columns stated above. Cassandra can be used for this data as it is optimized for write-heavy loads.

Ask AI

## Step 3: Design Deep Dive

Let's discuss how we scale the high-level design so that it works at the scale we're targeting.

Ask AI

### How Well Does Each Component Scale?

- **API servers** - can be easily scaled via autoscaling groups and replicating server instances.
- **WebSocket servers** - we can easily scale out the WebSocket servers, but we need to ensure we gracefully shutdown existing connections when tearing down a server. E.g. we can mark a server as "draining" in the load balancer and stop sending connections to it, prior to being finally removed from the server pool.
- **Client initialization** - when a client first connects to a server, it fetches the user's friends, subscribes to their channels on Redis pub/sub, fetches their location from cache and finally forwards to client.
- **User database** - We can shard the database based on user_id. It might also make sense to expose user/friends data via a dedicated service and API, managed by a dedicated team.
- **Location cache** - We can shard the cache easily by spinning up several Redis nodes. Also, the TTL puts a limit on the max memory we could have taken up at a time. But we still want to handle the large write load.
- **Redis pub/sub server** - we leverage the fact that no memory is consumed if there are channels initialized but are not in use. Hence, we can pre-allocate channels for all users who use the nearby friends feature to avoid having to deal with e.g. bringing up a new channel when a user comes online and notifying active WebSocket servers.

Ask AI

### Scaling Deep-dive on Redis Pub/Sub Component

We will need around 200GB of memory to maintain all pub/sub channels. This can be achieved by using 2 Redis servers with 100GB each.

Given that we need to push approximately 14 million location updates per second, we will however need at least 140 Redis servers to handle that amount of load, assuming that a single server can handle approximately 100k pushes per second.

Hence, we'll need a distributed Redis server cluster to handle the intense CPU load.

In order to support a distributed Redis cluster, we'll need to utilize a service discovery component, such as Zookeeper or etcd, to keep track of which servers are alive.

In terms of scaling the server cluster up or down, we can setup a daily job to scale the cluster as needed based on historical traffic data. We can also overprovision the cluster to handle spikes in loads.

Ask AI

### Scaling Operations and Considerations

The Redis cluster can be treated as a stateful storage server as there is some state maintained for the channels and there is a need for coordination with subscribers so that they hand-off to newly provisioned nodes in the cluster.

We have to be mindful of some potential issues during scaling operations:

- There will be a lot of resubscription requests from the WebSocket servers due to channels being moved around.
- Some location updates might be missed from clients during the operation, which is acceptable for this problem, but we should still minimize it from happening. Consider doing such operation when traffic is at lowest point of the day.
- We can leverage consistent hashing to minimize amount of channels moved in the event of adding/removing servers.

Ask AI

### Adding/Removing Friends

Whenever a friend is added/removed, WebSocket server responsible for affected user needs to subscribe/unsubscribe from the friend's channel.

Since the "nearby friends" feature is part of a larger app, we can assume that a callback on the mobile client side can be registered whenever any of the events occur and the client will send a message to the WebSocket server to do the appropriate action.

Ask AI

### Users with Many Friends

We can put a cap on the total number of friends one can have, e.g. Facebook has a cap of 5000 max friends.

The WebSocket server handling the "whale" user might have a higher load on its end, but as long as we have enough WebSocket servers, we should be okay.

Ask AI

### Nearby Random Person

What if the interviewer wants to update the design to include a feature where we can occasionally see a random person pop up on our nearby friends map?

One way to handle this is to define a pool of pub/sub channels, based on geohash.

Anyone within the geohash subscribes to the appropriate channel to receive location updates for random users.

We could also subscribe to several geohashes to handle cases where someone is close but in a bordering geohash.

Ask AI

### Alternative to Redis Pub/Sub

An alternative to using Redis for pub/sub is to leverage Erlang - a general programming language, optimized for distributed computing applications.

With it, we can spawn millions of small, Erlang processes which communicate with each other. We can handle both WebSocket connections and pub/sub channels within the distributed Erlang application.

A challenge with using Erlang, though, is that it's a niche programming language and it could be hard to source strong Erlang developers.

Ask AI

## Step 4: Wrap Up

We successfully designed a system, supporting the nearby friends features.

### Core Components:

- WebSocket servers - real-time communications between client and server.
- Redis - fast read and write of location data + pub/sub channels.

We also explored how to scale RESTful API servers, WebSocket servers, data layer, Redis pub/sub servers and we also explored an alternative to using Redis Pub/Sub. We also explored a "random nearby person" feature.