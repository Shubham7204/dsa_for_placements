
We're tackling a classical system design problem - designing a URL shortening service like TinyURL or bit.ly.

Given a long URL such as `https://www.systeminterview.com/q=chatsystem&c=loggedin&v=v3&l=long` we want to produce a short alias like `https://tinyurl.com/y7keocwj`. When a user opens the alias, they are redirected to the original long URL.

Functional goals: high availability, scalability, low latency redirects, and fault tolerance.

 

## Step 1 - Understand the Problem and Establish Design Scope

Sample interviewer-candidate Q&A that clarifies scope:

- **Candidate:** Can you give an example of how a URL shortening service works?
- **Interviewer:** Given a long URL, we return a short alias; opening the alias redirects to the original URL.
- **Candidate:** What is the traffic volume?
- **Interviewer:** 100 million URLs are generated per day.
- **Candidate:** How long should short URLs be?
- **Interviewer:** As short as possible (numbers & letters allowed).
- **Candidate:** Can shortened URLs be updated or deleted?
- **Interviewer:** For simplicity, assume they cannot.

Functional requirements: **create short URL**, **resolve short URL**. Non-functional: high availability, low latency, ability to store billions of mappings, and scale horizontally.

 

## Back-of-the-Envelope Calculation

- 100 million URLs/day - approximately 1,200 URLs/sec (writes).
- Assume read:write = 10:1 - approximately 12,000 reads/sec.
- Run for 10 years - approximately 365 billion records to store.
- Average long-URL length approximately 100 characters.
- Storage requirement for 10 years approximately 36.5 TB (raw URL bytes, excluding indices/compression/overhead).

These numbers guide design choices (caching, sharding, storage format, and capacity planning).

 

## Step 2 - Propose High-Level Design and Get Buy-In

High level components:

- Clients (browsers / services)
- Load balancer
- Shortener service instances (stateless)
- Cache layer (CDN or in-memory cache like Redis / Varnish)
- Persistent storage (sharded DB / NoSQL key-value store)

We'll surface two REST endpoints:

- `POST /api/v1/data/shorten` - accepts a long URL and returns a short alias.
- `GET /:shortId` - resolves the shortId and returns a redirect (301/302) to the long URL.

 

## URL Redirecting

When a short URL is visited, we must respond with an HTTP redirect. Two common codes:

- **301 Moved Permanently** - indicates permanent redirect. Clients and search engines can cache this and may bypass your service on subsequent requests (reduces load but prevents analytics tracking).
- **302 Found (Temporary)** - indicates temporary redirect. Clients typically do not cache the mapping, allowing you to collect analytics on each request.

Choose 301 for maximum performance and low load when mappings are permanent and analytics are not needed. Choose 302 if you need to collect click analytics or keep flexibility.

During redirect, simplest implementation: lookup `<shortId, longUrl>` mapping in a fast hash table or cache.

![tinyurl example](https://nextleet.com/images/tinyurl-example.png)

 

## URL Shortening: Hash + Collision Detection vs Base62 Conversion

Two common approaches to generate a short identifier:

1. **Hash + collision resolution**: compute a hash (MD5, SHA-256) and take the first N characters; detect collisions in datastore and iterate/pad input on collision.
2. **Base62 conversion of a unique integer ID**: allocate a unique numeric ID per URL (auto-increment-like or distributed generator) and convert that integer to a base62 string (0-9, a-z, A-Z).

Trade-offs:

|Hash + collision resolution|Base62 conversion|
|---|---|
|Fixed short URL length possible.|Short URL length grows with ID; early IDs are very short.|
|No need for a unique ID generator.|Depends on a unique ID generator (distributed or centralized).|
|Collisions are possible - need a DB lookup and collision-handling loop.|No collisions if ID generation is unique.|
|Hard to compute a predictable next short ID.|Next available short URL is predictable (security consideration).|

 

## Choosing Short-ID Length (Base62 Capacity)

Character set: 62 characters (0-9, a-z, A-Z). We must pick N where `62^N ≥ total URLs`.

If we expect approximately 365 billion records (approximately 3.65×10^11) over 10 years, solve `62^N ≥ 3.65×10^11`. That gives **N = 7** (since 62^7 ≈ 3.52×10^12), which supports approximately 3.5 trillion unique short IDs - comfortably above our target.

 

## ID Generation in Distributed Environment

Base62 relies on a globally unique numeric ID. In a distributed system we can generate numeric IDs in multiple ways:

- Central ticket server (single point of allocation; easy but a potential bottleneck / SPOF).
- Multi-master DB with strides (server-specific offsets) - works but complicates rack/multi-dc scaling.
- Twitter Snowflake / distributed ID generator - 64-bit time-sortable IDs, generated locally with unique worker IDs. This is a good fit for our needs (fast, distributed, sortable).

For a high-scale, low-latency system prefer a decentralized approach (e.g., Snowflake) to avoid synchronous coordination on each new URL.

 

## Step 3 - Design Deep Dive

### Data Model

Simplified relational table for persistence (one possible schema):

```
Table: urls
- id (bigint) PRIMARY KEY  -- numeric id (used for base62 conversion)
- short_id (varchar(7)) UNIQUE  -- base62-encoded id or stored short token
- long_url (text) NOT NULL
- created_at (timestamp)
- metadata (json)  -- optional: owner, expiry, analytics flags
```

In practice, we'll shard this table across many nodes (consistent hashing / range-sharding) and replicate for durability.

![url table](https://nextleet.com/images/url-table.png)

 

### Hash Function & Collision Handling

If using a truncated cryptographic hash (e.g., MD5/SHA) truncated to 7 characters, collisions can occur. Typical collision strategy:

1. Compute hash(text).
2. Take first N chars - candidate short token.
3. Check database if token already maps to the same long URL (idempotency) or a different URL (collision).
4. On collision with a different URL, rehash with a salt/nonce or append a counter and retry until unique.

This approach requires a DB lookup on generation and occasional retries. Bloom filters can reduce database hits for likely-absent tokens but cannot eliminate collision checks entirely.

 

### URL Shortening Deep Dive (Workflow)

1. Client calls `POST /api/v1/data/shorten` with the long URL.
2. Service validates the URL (optionally checks for blacklists / malware).
3. If you use base62: allocate a unique numeric ID (via Snowflake or other generator) and convert to base62 - shortId.
4. Store mapping `<shortId, longUrl>` in persistent storage and populate caches.
5. Return full short URL to client (e.g., `https://short.ly/{shortId}`).

![url shortening deep dive](https://nextleet.com/images/url-shortening-deep-dive.png)

 

### URL Redirection Deep Dive (Read Path & Cache)

Reads dominate writes, so introduce caching to reduce DB load and lower latency.

1. User requests `GET /{shortId}`.
2. Load balancer forwards to a service instance.
3. Service checks cache (in-memory or CDN edge). If found, return redirect immediately (301/302).
4. If miss, query the persistent store (shard appropriate for shortId), then populate cache and return redirect.
5. If shortId doesn't exist, return 404.

![url redirection deep dive](https://nextleet.com/images/url-redirection-deep-dive.png)

 

### Scaling & Storage Considerations

- Shard persistent storage across many nodes. Use consistent hashing or range partitioning.
- Replicate shards for durability and read scaling; use eventual consistency or tunable quorum depending on requirements.
- Cache hot mappings in-memory (Redis / memcached) and at the CDN/edge for global reads.
- Compress stored long URLs (if beneficial) and store only necessary metadata to save space.
- Consider TTL or archival policies for links that expire to reclaim space.

 

### Analytics, Rate Limiting & Other Features

- Analytics: instrument click events (store lightweight events in a queue for async processing into an analytics store).
- Rate limiter: protect endpoints (especially create endpoint) from abuse using per-IP / per-user quotas.
- Optional: expiry, custom aliases, password protection, or domain customization for customers.
- Security: block malicious URLs, monitor unusual traffic patterns, and implement abuse controls.

 

## Step 4 - Wrap Up

We discussed:

- API design for create & lookup endpoints.
- Data model and persistent storage choices.
- Hashing vs base62 approach; decided base62 + distributed ID generator (e.g., Snowflake) is a simple robust choice.
- Redirect flow and caching architecture for high read volumes.
- Scaling, sharding, replication, and operational concerns (monitoring, backups, and TTL/archival policies).

Additional talking points: rate limiting, web tier scaling (stateless services behind LB), database replication & sharding, analytics pipelines for click events, and availability/consistency trade-offs (see previous chapters for quorum/replication patterns).

![url shortener review](https://nextleet.com/images/url-shortening-deep-dive.png)